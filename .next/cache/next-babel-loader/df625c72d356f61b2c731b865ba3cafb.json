{"ast":null,"code":"var _Promise = require(\"@babel/runtime-corejs2/core-js/promise\");\n\nvar _parseInt = require(\"@babel/runtime-corejs2/core-js/parse-int\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\n// Copyright 2010 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof Module !== 'undefined' ? Module : {}; // --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\n\nvar moduleOverrides = {};\nvar key;\n\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\nvar arguments_ = [];\nvar thisProgram = './this.program';\n\nvar quit_ = function quit_(status, toThrow) {\n  throw toThrow;\n}; // Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\n\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\nENVIRONMENT_IS_WEB = true;\nENVIRONMENT_IS_WORKER = typeof importScripts === 'function'; // N.b. Electron.js environment is simultaneously a NODE-environment, but\n// also a web environment.\n\nENVIRONMENT_IS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\nif (Module['ENVIRONMENT']) {\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');\n} // `/` should be present at the end if `scriptDirectory` is not empty\n\n\nvar scriptDirectory = '';\n\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n\n  return scriptDirectory + path;\n} // Hooks that are implemented differently in different runtime environments.\n\n\nvar read_, readAsync, readBinary, setWindowTitle;\nvar nodeFS;\nvar nodePath;\n\nif (ENVIRONMENT_IS_NODE) {\n  if (ENVIRONMENT_IS_WORKER) {\n    scriptDirectory = require('path').dirname(scriptDirectory) + '/';\n  } else {\n    scriptDirectory = __dirname + '/';\n  }\n\n  read_ = function shell_read(filename, binary) {\n    if (!nodeFS) nodeFS = require('fs');\n    if (!nodePath) nodePath = require('path');\n    filename = nodePath['normalize'](filename);\n    return nodeFS['readFileSync'](filename, binary ? null : 'utf8');\n  };\n\n  readBinary = function readBinary(filename) {\n    var ret = read_(filename, true);\n\n    if (!ret.buffer) {\n      ret = new Uint8Array(ret);\n    }\n\n    assert(ret.buffer);\n    return ret;\n  };\n\n  if (process['argv'].length > 1) {\n    thisProgram = process['argv'][1].replace(/\\\\/g, '/');\n  }\n\n  arguments_ = process['argv'].slice(2);\n\n  if (typeof module !== 'undefined') {\n    module['exports'] = Module;\n  }\n\n  process['on']('uncaughtException', function (ex) {\n    // suppress ExitStatus exceptions from showing an error\n    if (!(ex instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n  process['on']('unhandledRejection', abort);\n\n  quit_ = function quit_(status) {\n    process['exit'](status);\n  };\n\n  Module['inspect'] = function () {\n    return '[Emscripten Module object]';\n  };\n} else if (ENVIRONMENT_IS_SHELL) {\n  if (typeof read != 'undefined') {\n    read_ = function shell_read(f) {\n      return read(f);\n    };\n  }\n\n  readBinary = function readBinary(f) {\n    var data;\n\n    if (typeof readbuffer === 'function') {\n      return new Uint8Array(readbuffer(f));\n    }\n\n    data = read(f, 'binary');\n    assert(typeof data === 'object');\n    return data;\n  };\n\n  if (typeof scriptArgs != 'undefined') {\n    arguments_ = scriptArgs;\n  } else if (typeof arguments != 'undefined') {\n    arguments_ = arguments;\n  }\n\n  if (typeof quit === 'function') {\n    quit_ = function quit_(status) {\n      quit(status);\n    };\n  }\n\n  if (typeof print !== 'undefined') {\n    // Prefer to use print/printErr where they exist, as they usually work better.\n    if (typeof console === 'undefined') console = {};\n    console.log = print;\n    console.warn = console.error = typeof printErr !== 'undefined' ? printErr : print;\n  }\n} else // Note that this includes Node.js workers when relevant (pthreads is enabled).\n  // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n  // ENVIRONMENT_IS_NODE.\n  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n    if (ENVIRONMENT_IS_WORKER) {\n      // Check worker, not web, since window could be polyfilled\n      scriptDirectory = self.location.href;\n    } else if (document.currentScript) {\n      // web\n      scriptDirectory = document.currentScript.src;\n    } // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n    // otherwise, slice off the final part of the url to find the script directory.\n    // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n    // and scriptDirectory will correctly be replaced with an empty string.\n\n\n    if (scriptDirectory.indexOf('blob:') !== 0) {\n      scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/') + 1);\n    } else {\n      scriptDirectory = '';\n    } // Differentiate the Web Worker from the Node Worker case, as reading must\n    // be done differently.\n\n\n    {\n      read_ = function shell_read(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.send(null);\n        return xhr.responseText;\n      };\n\n      if (ENVIRONMENT_IS_WORKER) {\n        readBinary = function readBinary(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, false);\n          xhr.responseType = 'arraybuffer';\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        };\n      }\n\n      readAsync = function readAsync(url, onload, onerror) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'arraybuffer';\n\n        xhr.onload = function xhr_onload() {\n          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n            // file URLs can return 0\n            onload(xhr.response);\n            return;\n          }\n\n          onerror();\n        };\n\n        xhr.onerror = onerror;\n        xhr.send(null);\n      };\n    }\n\n    setWindowTitle = function setWindowTitle(title) {\n      document.title = title;\n    };\n  } else {\n    throw new Error('environment detection error');\n  } // Set up the out() and err() hooks, which are how we can print to stdout or\n// stderr, respectively.\n\n\nvar out = Module['print'] || console.log.bind(console);\nvar err = Module['printErr'] || console.warn.bind(console); // Merge back in the overrides\n\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n} // Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n\n\nmoduleOverrides = null; // Emit code to handle expected values on the Module object. This applies Module.x\n// to the proper local x. This has two benefits: first, we only emit it if it is\n// expected to arrive, and second, by using a local everywhere else that can be\n// minified.\n\nif (Module['arguments']) arguments_ = Module['arguments'];\nif (!_Object$getOwnPropertyDescriptor(Module, 'arguments')) _Object$defineProperty(Module, 'arguments', {\n  configurable: true,\n  get: function get() {\n    abort('Module.arguments has been replaced with plain arguments_');\n  }\n});\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];\nif (!_Object$getOwnPropertyDescriptor(Module, 'thisProgram')) _Object$defineProperty(Module, 'thisProgram', {\n  configurable: true,\n  get: function get() {\n    abort('Module.thisProgram has been replaced with plain thisProgram');\n  }\n});\nif (Module['quit']) quit_ = Module['quit'];\nif (!_Object$getOwnPropertyDescriptor(Module, 'quit')) _Object$defineProperty(Module, 'quit', {\n  configurable: true,\n  get: function get() {\n    abort('Module.quit has been replaced with plain quit_');\n  }\n}); // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n// Assertions on removed incoming Module JS APIs.\n\nassert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['read'] === 'undefined', 'Module.read option was removed (modify read_ in JS)');\nassert(typeof Module['readAsync'] === 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\nassert(typeof Module['readBinary'] === 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\nassert(typeof Module['setWindowTitle'] === 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');\nif (!_Object$getOwnPropertyDescriptor(Module, 'read')) _Object$defineProperty(Module, 'read', {\n  configurable: true,\n  get: function get() {\n    abort('Module.read has been replaced with plain read_');\n  }\n});\nif (!_Object$getOwnPropertyDescriptor(Module, 'readAsync')) _Object$defineProperty(Module, 'readAsync', {\n  configurable: true,\n  get: function get() {\n    abort('Module.readAsync has been replaced with plain readAsync');\n  }\n});\nif (!_Object$getOwnPropertyDescriptor(Module, 'readBinary')) _Object$defineProperty(Module, 'readBinary', {\n  configurable: true,\n  get: function get() {\n    abort('Module.readBinary has been replaced with plain readBinary');\n  }\n}); // TODO: add when SDL2 is fixed if (!Object.getOwnPropertyDescriptor(Module, 'setWindowTitle')) Object.defineProperty(Module, 'setWindowTitle', { configurable: true, get: function() { abort('Module.setWindowTitle has been replaced with plain setWindowTitle') } });\n\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js'; // TODO remove when SDL2 is fixed (also see above)\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n// {{PREAMBLE_ADDITIONS}}\n\nvar STACK_ALIGN = 16; // stack management, and other functionality that is provided by the compiled code,\n// should not be used before it is ready\n\nstackSave = stackRestore = stackAlloc = function stackAlloc() {\n  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n};\n\nfunction staticAlloc(size) {\n  abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');\n}\n\nfunction dynamicAlloc(size) {\n  assert(DYNAMICTOP_PTR);\n  var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n  var end = ret + size + 15 & -16;\n\n  if (end > _emscripten_get_heap_size()) {\n    abort('failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly');\n  }\n\n  HEAP32[DYNAMICTOP_PTR >> 2] = end;\n  return ret;\n}\n\nfunction alignMemory(size, factor) {\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n\n  return Math.ceil(size / factor) * factor;\n}\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1':\n    case 'i8':\n      return 1;\n\n    case 'i16':\n      return 2;\n\n    case 'i32':\n      return 4;\n\n    case 'i64':\n      return 8;\n\n    case 'float':\n      return 4;\n\n    case 'double':\n      return 8;\n\n    default:\n      {\n        if (type[type.length - 1] === '*') {\n          return 4; // A pointer\n        } else if (type[0] === 'i') {\n          var bits = _parseInt(type.substr(1));\n\n          assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\n          return bits / 8;\n        } else {\n          return 0;\n        }\n      }\n  }\n}\n\nfunction warnOnce(text) {\n  if (!warnOnce.shown) warnOnce.shown = {};\n\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    err(text);\n  }\n} // Wraps a JS function as a wasm function with a given signature.\n\n\nfunction convertJsFunctionToWasm(func, sig) {\n  // If the type reflection proposal is available, use the new\n  // \"WebAssembly.Function\" constructor.\n  // Otherwise, construct a minimal wasm module importing the JS function and\n  // re-exporting it.\n  if (typeof WebAssembly.Function === \"function\") {\n    var typeNames = {\n      'i': 'i32',\n      'j': 'i64',\n      'f': 'f32',\n      'd': 'f64'\n    };\n    var type = {\n      parameters: [],\n      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\n    };\n\n    for (var i = 1; i < sig.length; ++i) {\n      type.parameters.push(typeNames[sig[i]]);\n    }\n\n    return new WebAssembly.Function(type, func);\n  } // The module is static, with the exception of the type section, which is\n  // generated based on the signature passed in.\n\n\n  var typeSection = [0x01, // id: section,\n  0x00, // length: 0 (placeholder)\n  0x01, // count: 1\n  0x60 // form: func\n  ];\n  var sigRet = sig.slice(0, 1);\n  var sigParam = sig.slice(1);\n  var typeCodes = {\n    'i': 0x7f,\n    // i32\n    'j': 0x7e,\n    // i64\n    'f': 0x7d,\n    // f32\n    'd': 0x7c // f64\n\n  }; // Parameters, length + signatures\n\n  typeSection.push(sigParam.length);\n\n  for (var i = 0; i < sigParam.length; ++i) {\n    typeSection.push(typeCodes[sigParam[i]]);\n  } // Return values, length + signatures\n  // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n\n\n  if (sigRet == 'v') {\n    typeSection.push(0x00);\n  } else {\n    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\n  } // Write the overall length of the type section back into the section header\n  // (excepting the 2 bytes for the section id and length)\n\n\n  typeSection[1] = typeSection.length - 2; // Rest of the module is static\n\n  var bytes = new Uint8Array([0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\n  0x01, 0x00, 0x00, 0x00 // version: 1\n  ].concat(typeSection, [0x02, 0x07, // import section\n  // (import \"e\" \"f\" (func 0 (type 0)))\n  0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00, 0x07, 0x05, // export section\n  // (export \"f\" (func 0 (type 0)))\n  0x01, 0x01, 0x66, 0x00, 0x00])); // We can compile this wasm module synchronously because it is very small.\n  // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n\n  var module = new WebAssembly.Module(bytes);\n  var instance = new WebAssembly.Instance(module, {\n    'e': {\n      'f': func\n    }\n  });\n  var wrappedFunc = instance.exports['f'];\n  return wrappedFunc;\n} // Add a wasm function to the table.\n\n\nfunction addFunctionWasm(func, sig) {\n  var table = wasmTable;\n  var ret = table.length; // Grow the table\n\n  try {\n    table.grow(1);\n  } catch (err) {\n    if (!(err instanceof RangeError)) {\n      throw err;\n    }\n\n    throw 'Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.';\n  } // Insert new element\n\n\n  try {\n    // Attempting to call this with JS function will cause of table.set() to fail\n    table.set(ret, func);\n  } catch (err) {\n    if (!(err instanceof TypeError)) {\n      throw err;\n    }\n\n    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');\n    var wrapped = convertJsFunctionToWasm(func, sig);\n    table.set(ret, wrapped);\n  }\n\n  return ret;\n}\n\nfunction removeFunctionWasm(index) {} // TODO(sbc): Look into implementing this to allow re-using of table slots\n// 'sig' parameter is required for the llvm backend but only when func is not\n// already a WebAssembly function.\n\n\nfunction addFunction(func, sig) {\n  assert(typeof func !== 'undefined');\n  return addFunctionWasm(func, sig);\n}\n\nfunction removeFunction(index) {\n  removeFunctionWasm(index);\n}\n\nvar funcWrappers = {};\n\nfunction getFuncWrapper(func, sig) {\n  if (!func) return; // on null pointer, return undefined\n\n  assert(sig);\n\n  if (!funcWrappers[sig]) {\n    funcWrappers[sig] = {};\n  }\n\n  var sigCache = funcWrappers[sig];\n\n  if (!sigCache[func]) {\n    // optimize away arguments usage in common cases\n    if (sig.length === 1) {\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func);\n      };\n    } else if (sig.length === 2) {\n      sigCache[func] = function dynCall_wrapper(arg) {\n        return dynCall(sig, func, [arg]);\n      };\n    } else {\n      // general case\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func, Array.prototype.slice.call(arguments));\n      };\n    }\n  }\n\n  return sigCache[func];\n}\n\nfunction makeBigInt(low, high, unsigned) {\n  return unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296.0 : +(low >>> 0) + +(high | 0) * 4294967296.0;\n}\n\nfunction dynCall(sig, ptr, args) {\n  if (args && args.length) {\n    // j (64-bit integer) must be passed in as two numbers [low 32, high 32].\n    assert(args.length === sig.substring(1).replace(/j/g, '--').length);\n    assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n  } else {\n    assert(sig.length == 1);\n    assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].call(null, ptr);\n  }\n}\n\nvar tempRet0 = 0;\n\nvar setTempRet0 = function setTempRet0(value) {\n  tempRet0 = value;\n};\n\nvar getTempRet0 = function getTempRet0() {\n  return tempRet0;\n};\n\nfunction getCompilerSetting(name) {\n  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n}\n\nvar Runtime = {\n  // helpful errors\n  getTempRet0: function getTempRet0() {\n    abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n  },\n  staticAlloc: function staticAlloc() {\n    abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n  },\n  stackAlloc: function stackAlloc() {\n    abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n  }\n}; // The address globals begin at. Very low in memory, for code size and optimization opportunities.\n// Above 0 is static memory, starting with globals.\n// Then the stack.\n// Then 'dynamic' memory for sbrk.\n\nvar GLOBAL_BASE = 1024; // === Preamble library stuff ===\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\nvar wasmBinary;\nif (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\nif (!_Object$getOwnPropertyDescriptor(Module, 'wasmBinary')) _Object$defineProperty(Module, 'wasmBinary', {\n  configurable: true,\n  get: function get() {\n    abort('Module.wasmBinary has been replaced with plain wasmBinary');\n  }\n});\nvar noExitRuntime;\nif (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];\nif (!_Object$getOwnPropertyDescriptor(Module, 'noExitRuntime')) _Object$defineProperty(Module, 'noExitRuntime', {\n  configurable: true,\n  get: function get() {\n    abort('Module.noExitRuntime has been replaced with plain noExitRuntime');\n  }\n});\n\nif (typeof WebAssembly !== 'object') {\n  abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');\n} // In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.\n// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)\n\n/** @type {function(number, number, string, boolean=)} */\n\n\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n  switch (type) {\n    case 'i1':\n      HEAP8[ptr >> 0] = value;\n      break;\n\n    case 'i8':\n      HEAP8[ptr >> 0] = value;\n      break;\n\n    case 'i16':\n      HEAP16[ptr >> 1] = value;\n      break;\n\n    case 'i32':\n      HEAP32[ptr >> 2] = value;\n      break;\n\n    case 'i64':\n      tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? (Math_min(+Math_floor(tempDouble / 4294967296.0), 4294967295.0) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n      break;\n\n    case 'float':\n      HEAPF32[ptr >> 2] = value;\n      break;\n\n    case 'double':\n      HEAPF64[ptr >> 3] = value;\n      break;\n\n    default:\n      abort('invalid type for setValue: ' + type);\n  }\n}\n/** @type {function(number, string, boolean=)} */\n\n\nfunction getValue(ptr, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n  switch (type) {\n    case 'i1':\n      return HEAP8[ptr >> 0];\n\n    case 'i8':\n      return HEAP8[ptr >> 0];\n\n    case 'i16':\n      return HEAP16[ptr >> 1];\n\n    case 'i32':\n      return HEAP32[ptr >> 2];\n\n    case 'i64':\n      return HEAP32[ptr >> 2];\n\n    case 'float':\n      return HEAPF32[ptr >> 2];\n\n    case 'double':\n      return HEAPF64[ptr >> 3];\n\n    default:\n      abort('invalid type for getValue: ' + type);\n  }\n\n  return null;\n} // Wasm globals\n\n\nvar wasmMemory; // In fastcomp asm.js, we don't need a wasm Table at all.\n// In the wasm backend, we polyfill the WebAssembly object,\n// so this creates a (non-native-wasm) table for us.\n\nvar wasmTable = new WebAssembly.Table({\n  'initial': 6,\n  'maximum': 6 + 0,\n  'element': 'anyfunc'\n}); //========================================\n// Runtime essentials\n//========================================\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\n\nvar ABORT = false; // set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\n\nvar EXITSTATUS = 0;\n/** @type {function(*, string=)} */\n\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed: ' + text);\n  }\n} // Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\n\n\nfunction getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n  return func;\n} // C calling interface.\n\n\nfunction ccall(ident, returnType, argTypes, args, opts) {\n  // For fast lookup of conversion functions\n  var toC = {\n    'string': function string(str) {\n      var ret = 0;\n\n      if (str !== null && str !== undefined && str !== 0) {\n        // null string\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n        var len = (str.length << 2) + 1;\n        ret = stackAlloc(len);\n        stringToUTF8(str, ret, len);\n      }\n\n      return ret;\n    },\n    'array': function array(arr) {\n      var ret = stackAlloc(arr.length);\n      writeArrayToMemory(arr, ret);\n      return ret;\n    }\n  };\n\n  function convertReturnValue(ret) {\n    if (returnType === 'string') return UTF8ToString(ret);\n    if (returnType === 'boolean') return Boolean(ret);\n    return ret;\n  }\n\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  assert(returnType !== 'array', 'Return type should not be \"array\".');\n\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n\n  var ret = func.apply(null, cArgs);\n  ret = convertReturnValue(ret);\n  if (stack !== 0) stackRestore(stack);\n  return ret;\n}\n\nfunction cwrap(ident, returnType, argTypes, opts) {\n  return function () {\n    return ccall(ident, returnType, argTypes, arguments, opts);\n  };\n}\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\n\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\n\nvar ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk\n\nvar ALLOC_NONE = 3; // Do not allocate\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\n//        affect this!)\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\n//         or a single type which is used for the entire block. This only matters if there\n//         is initial data - if @slab is a number, then this does not matter at all and is\n//         ignored.\n// @allocator: How to allocate memory, see ALLOC_*\n\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\n\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n\n  if (typeof slab === 'number') {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n\n  var singleType = typeof types === 'string' ? types : null;\n  var ret;\n\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n\n  if (zeroinit) {\n    var stop;\n    ptr = ret;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[ptr >> 2] = 0;\n    }\n\n    stop = ret + size;\n\n    while (ptr < stop) {\n      HEAP8[ptr++ >> 0] = 0;\n    }\n\n    return ret;\n  }\n\n  if (singleType === 'i8') {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(\n      /** @type {!Uint8Array} */\n      slab, ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n\n    return ret;\n  }\n\n  var i = 0,\n      type,\n      typeSize,\n      previousType;\n\n  while (i < size) {\n    var curr = slab[i];\n    type = singleType || types[i];\n\n    if (type === 0) {\n      i++;\n      continue;\n    }\n\n    assert(type, 'Must know what type to store in allocate!');\n    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n    setValue(ret + i, curr, type); // no need to look up size unless type changes, so cache it\n\n    if (previousType !== type) {\n      typeSize = getNativeTypeSize(type);\n      previousType = type;\n    }\n\n    i += typeSize;\n  }\n\n  return ret;\n} // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\n\n\nfunction getMemory(size) {\n  if (!runtimeInitialized) return dynamicAlloc(size);\n  return _malloc(size);\n} // runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\n\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n/**\n * @param {number} idx\n * @param {number=} maxBytesToRead\n * @return {string}\n */\n\nfunction UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\n\n  while (u8Array[endPtr] && !(endPtr >= endIdx)) {\n    ++endPtr;\n  }\n\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n  } else {\n    var str = ''; // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\n\n    while (idx < endPtr) {\n      // For UTF8 byte structure, see:\n      // http://en.wikipedia.org/wiki/UTF-8#Description\n      // https://www.ietf.org/rfc/rfc2279.txt\n      // https://tools.ietf.org/html/rfc3629\n      var u0 = u8Array[idx++];\n\n      if (!(u0 & 0x80)) {\n        str += String.fromCharCode(u0);\n        continue;\n      }\n\n      var u1 = u8Array[idx++] & 63;\n\n      if ((u0 & 0xE0) == 0xC0) {\n        str += String.fromCharCode((u0 & 31) << 6 | u1);\n        continue;\n      }\n\n      var u2 = u8Array[idx++] & 63;\n\n      if ((u0 & 0xF0) == 0xE0) {\n        u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n      } else {\n        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');\n        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;\n      }\n\n      if (u0 < 0x10000) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 0x10000;\n        str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n      }\n    }\n  }\n\n  return str;\n} // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\n// copy of that string as a Javascript String object.\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\n//                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\n//                 style or the other.\n\n/**\n * @param {number} ptr\n * @param {number=} maxBytesToRead\n * @return {string}\n */\n\n\nfunction UTF8ToString(ptr, maxBytesToRead) {\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n} // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n//                    This count should include the null terminator,\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n\n    if (u >= 0xD800 && u <= 0xDFFF) {\n      var u1 = str.charCodeAt(++i);\n      u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;\n    }\n\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      outU8Array[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      outU8Array[outIdx++] = 0xC0 | u >> 6;\n      outU8Array[outIdx++] = 0x80 | u & 63;\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      outU8Array[outIdx++] = 0xE0 | u >> 12;\n      outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n      outU8Array[outIdx++] = 0x80 | u & 63;\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');\n      outU8Array[outIdx++] = 0xF0 | u >> 18;\n      outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n      outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n      outU8Array[outIdx++] = 0x80 | u & 63;\n    }\n  } // Null-terminate the pointer to the buffer.\n\n\n  outU8Array[outIdx] = 0;\n  return outIdx - startIdx;\n} // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n} // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\n\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\n    if (u <= 0x7F) ++len;else if (u <= 0x7FF) len += 2;else if (u <= 0xFFFF) len += 3;else len += 4;\n  }\n\n  return len;\n} // runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\n\nfunction AsciiToString(ptr) {\n  var str = '';\n\n  while (1) {\n    var ch = HEAPU8[ptr++ >> 0];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n} // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\n\nfunction stringToAscii(str, outPtr) {\n  return writeAsciiToMemory(str, outPtr, false);\n} // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\n\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\nfunction UTF16ToString(ptr) {\n  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n  var endPtr = ptr; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n  var idx = endPtr >> 1;\n\n  while (HEAP16[idx]) {\n    ++idx;\n  }\n\n  endPtr = idx << 1;\n\n  if (endPtr - ptr > 32 && UTF16Decoder) {\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n  } else {\n    var i = 0;\n    var str = '';\n\n    while (1) {\n      var codeUnit = HEAP16[ptr + i * 2 >> 1];\n      if (codeUnit == 0) return str;\n      ++i; // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n\n      str += String.fromCharCode(codeUnit);\n    }\n  }\n} // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2; // Null terminator.\n\n  var startPtr = outPtr;\n  var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n    HEAP16[outPtr >> 1] = codeUnit;\n    outPtr += 2;\n  } // Null-terminate the pointer to the HEAP.\n\n\n  HEAP16[outPtr >> 1] = 0;\n  return outPtr - startPtr;\n} // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\nfunction lengthBytesUTF16(str) {\n  return str.length * 2;\n}\n\nfunction UTF32ToString(ptr) {\n  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n  var i = 0;\n  var str = '';\n\n  while (1) {\n    var utf32 = HEAP32[ptr + i * 4 >> 2];\n    if (utf32 == 0) return str;\n    ++i; // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n\n    if (utf32 >= 0x10000) {\n      var ch = utf32 - 0x10000;\n      str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n    } else {\n      str += String.fromCharCode(utf32);\n    }\n  }\n} // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n\n  if (maxBytesToWrite < 4) return 0;\n  var startPtr = outPtr;\n  var endPtr = startPtr + maxBytesToWrite - 4;\n\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n      var trailSurrogate = str.charCodeAt(++i);\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;\n    }\n\n    HEAP32[outPtr >> 2] = codeUnit;\n    outPtr += 4;\n    if (outPtr + 4 > endPtr) break;\n  } // Null-terminate the pointer to the HEAP.\n\n\n  HEAP32[outPtr >> 2] = 0;\n  return outPtr - startPtr;\n} // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\nfunction lengthBytesUTF32(str) {\n  var len = 0;\n\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i);\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n\n    len += 4;\n  }\n\n  return len;\n} // Allocate heap space for a JS string, and write it there.\n// It is the responsibility of the caller to free() that memory.\n\n\nfunction allocateUTF8(str) {\n  var size = lengthBytesUTF8(str) + 1;\n\n  var ret = _malloc(size);\n\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n} // Allocate stack space for a JS string, and write it there.\n\n\nfunction allocateUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n} // Deprecated: This function should not be called because it is unsafe and does not provide\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\n// to be secure from out of bounds writes.\n\n/** @deprecated */\n\n\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n  var\n  /** @type {number} */\n  lastChar,\n  /** @type {number} */\n  end;\n\n  if (dontAddNull) {\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\n    // character that existed at the location where the null will be placed, and restore\n    // that after the write (below).\n    end = buffer + lengthBytesUTF8(string);\n    lastChar = HEAP8[end];\n  }\n\n  stringToUTF8(string, buffer, Infinity);\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n}\n\nfunction writeArrayToMemory(array, buffer) {\n  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');\n  HEAP8.set(array, buffer);\n}\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);\n    HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n  } // Null-terminate the pointer to the HEAP.\n\n\n  if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n} // Memory management\n\n\nvar PAGE_SIZE = 16384;\nvar WASM_PAGE_SIZE = 65536;\nvar ASMJS_PAGE_SIZE = 16777216;\n\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - x % multiple;\n  }\n\n  return x;\n}\n\nvar HEAP,\n/** @type {ArrayBuffer} */\nbuffer,\n/** @type {Int8Array} */\nHEAP8,\n/** @type {Uint8Array} */\nHEAPU8,\n/** @type {Int16Array} */\nHEAP16,\n/** @type {Uint16Array} */\nHEAPU16,\n/** @type {Int32Array} */\nHEAP32,\n/** @type {Uint32Array} */\nHEAPU32,\n/** @type {Float32Array} */\nHEAPF32,\n/** @type {Float64Array} */\nHEAPF64;\n\nfunction updateGlobalBufferAndViews(buf) {\n  buffer = buf;\n  Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buf);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buf);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\n}\n\nvar STATIC_BASE = 1024,\n    STACK_BASE = 5246640,\n    STACKTOP = STACK_BASE,\n    STACK_MAX = 3760,\n    DYNAMIC_BASE = 5246640,\n    DYNAMICTOP_PTR = 3600;\nassert(STACK_BASE % 16 === 0, 'stack must start aligned');\nassert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');\nvar TOTAL_STACK = 5242880;\nif (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime');\nvar INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;\nif (!_Object$getOwnPropertyDescriptor(Module, 'TOTAL_MEMORY')) _Object$defineProperty(Module, 'TOTAL_MEMORY', {\n  configurable: true,\n  get: function get() {\n    abort('Module.TOTAL_MEMORY has been replaced with plain INITIAL_TOTAL_MEMORY');\n  }\n});\nassert(INITIAL_TOTAL_MEMORY >= TOTAL_STACK, 'TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'); // check for full engine support (use string 'subarray' to avoid closure compiler confusion)\n\nassert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, 'JS engine does not provide full typed array support'); // In standalone mode, the wasm creates the memory, and the user can't provide it.\n// In non-standalone/normal mode, we create the memory here.\n// Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm\n// memory is created in the wasm, not in JS.)\n\nif (Module['wasmMemory']) {\n  wasmMemory = Module['wasmMemory'];\n} else {\n  wasmMemory = new WebAssembly.Memory({\n    'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE,\n    'maximum': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE\n  });\n}\n\nif (wasmMemory) {\n  buffer = wasmMemory.buffer;\n} // If the user provides an incorrect length, just use that length instead rather than providing the user to\n// specifically provide the memory length with Module['TOTAL_MEMORY'].\n\n\nINITIAL_TOTAL_MEMORY = buffer.byteLength;\nassert(INITIAL_TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\nupdateGlobalBufferAndViews(buffer);\nHEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE; // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n\nfunction writeStackCookie() {\n  assert((STACK_MAX & 3) == 0); // The stack grows downwards\n\n  HEAPU32[(STACK_MAX >> 2) + 1] = 0x2135467;\n  HEAPU32[(STACK_MAX >> 2) + 2] = 0x89BACDFE; // Also test the global address 0 for integrity.\n  // We don't do this with ASan because ASan does its own checks for this.\n\n  HEAP32[0] = 0x63736d65;\n  /* 'emsc' */\n}\n\nfunction checkStackCookie() {\n  var cookie1 = HEAPU32[(STACK_MAX >> 2) + 1];\n  var cookie2 = HEAPU32[(STACK_MAX >> 2) + 2];\n\n  if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {\n    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' ' + cookie1.toString(16));\n  } // Also test the global address 0 for integrity.\n  // We don't do this with ASan because ASan does its own checks for this.\n\n\n  if (HEAP32[0] !== 0x63736d65\n  /* 'emsc' */\n  ) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n}\n\nfunction abortStackOverflow(allocSize) {\n  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');\n} // Endianness check (note: assumes compiler arch was little-endian)\n\n\n(function () {\n  var h16 = new Int16Array(1);\n  var h8 = new Int8Array(h16.buffer);\n  h16[0] = 0x6373;\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n})();\n\nfunction abortFnPtrError(ptr, sig) {\n  abort(\"Invalid function pointer \" + ptr + \" called with signature '\" + sig + \"'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). Build with ASSERTIONS=2 for more info.\");\n}\n\nfunction callRuntimeCallbacks(callbacks) {\n  while (callbacks.length > 0) {\n    var callback = callbacks.shift();\n\n    if (typeof callback == 'function') {\n      callback();\n      continue;\n    }\n\n    var func = callback.func;\n\n    if (typeof func === 'number') {\n      if (callback.arg === undefined) {\n        Module['dynCall_v'](func);\n      } else {\n        Module['dynCall_vi'](func, callback.arg);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\n\nvar __ATPRERUN__ = []; // functions called before the runtime is initialized\n\nvar __ATINIT__ = []; // functions called during startup\n\nvar __ATMAIN__ = []; // functions called when main() is to be run\n\nvar __ATEXIT__ = []; // functions called during shutdown\n\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\nfunction preRun() {\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n  checkStackCookie();\n  assert(!runtimeInitialized);\n  runtimeInitialized = true;\n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  checkStackCookie();\n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n  checkStackCookie();\n  runtimeExited = true;\n}\n\nfunction postRun() {\n  checkStackCookie();\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnPreMain(cb) {\n  __ATMAIN__.unshift(cb);\n}\n\nfunction addOnExit(cb) {}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\nfunction unSign(value, bits, ignore) {\n  if (value >= 0) {\n    return value;\n  }\n\n  return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n  : Math.pow(2, bits) + value;\n}\n\nfunction reSign(value, bits, ignore) {\n  if (value <= 0) {\n    return value;\n  }\n\n  var half = bits <= 32 ? Math.abs(1 << bits - 1) // abs is needed if bits == 32\n  : Math.pow(2, bits - 1);\n\n  if (value >= half && (bits <= 32 || value > half)) {\n    // for huge values, we can hit the precision limit and always get true here. so don't do that\n    // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n    // TODO: In i64 mode 1, resign the two parts separately and safely\n    value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n  }\n\n  return value;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\n\nassert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nvar Math_abs = Math.abs;\nvar Math_cos = Math.cos;\nvar Math_sin = Math.sin;\nvar Math_tan = Math.tan;\nvar Math_acos = Math.acos;\nvar Math_asin = Math.asin;\nvar Math_atan = Math.atan;\nvar Math_atan2 = Math.atan2;\nvar Math_exp = Math.exp;\nvar Math_log = Math.log;\nvar Math_sqrt = Math.sqrt;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_pow = Math.pow;\nvar Math_imul = Math.imul;\nvar Math_fround = Math.fround;\nvar Math_round = Math.round;\nvar Math_min = Math.min;\nvar Math_max = Math.max;\nvar Math_clz32 = Math.clz32;\nvar Math_trunc = Math.trunc; // A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\n\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n\n    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(function () {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n\n        var shown = false;\n\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            err('still waiting on run dependencies:');\n          }\n\n          err('dependency: ' + dep);\n        }\n\n        if (shown) {\n          err('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    err('warning: run dependency added without ID');\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    err('warning: run dependency removed without ID');\n  }\n\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\nModule[\"preloadedImages\"] = {}; // maps url to image data\n\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\n\nfunction abort(what) {\n  if (Module['onAbort']) {\n    Module['onAbort'](what);\n  }\n\n  what += '';\n  out(what);\n  err(what);\n  ABORT = true;\n  EXITSTATUS = 1;\n  var output = 'abort(' + what + ') at ' + stackTrace();\n  what = output; // Throw a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n\n  throw new WebAssembly.RuntimeError(what);\n}\n\nvar memoryInitializer = null; // show errors on likely calls to FS when it was not included\n\nvar FS = {\n  error: function error() {\n    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n  },\n  init: function init() {\n    FS.error();\n  },\n  createDataFile: function createDataFile() {\n    FS.error();\n  },\n  createPreloadedFile: function createPreloadedFile() {\n    FS.error();\n  },\n  createLazyFile: function createLazyFile() {\n    FS.error();\n  },\n  open: function open() {\n    FS.error();\n  },\n  mkdev: function mkdev() {\n    FS.error();\n  },\n  registerDevice: function registerDevice() {\n    FS.error();\n  },\n  analyzePath: function analyzePath() {\n    FS.error();\n  },\n  loadFilesFromDB: function loadFilesFromDB() {\n    FS.error();\n  },\n  ErrnoError: function ErrnoError() {\n    FS.error();\n  }\n};\nModule['FS_createDataFile'] = FS.createDataFile;\nModule['FS_createPreloadedFile'] = FS.createPreloadedFile; // Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\n\nvar dataURIPrefix = 'data:application/octet-stream;base64,'; // Indicates whether filename is a base64 data URI.\n\nfunction isDataURI(filename) {\n  return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n}\n\nvar wasmBinaryFile = 'a.out.wasm';\n\nif (!isDataURI(wasmBinaryFile)) {\n  wasmBinaryFile = locateFile(wasmBinaryFile);\n}\n\nfunction getBinary() {\n  try {\n    if (wasmBinary) {\n      return new Uint8Array(wasmBinary);\n    }\n\n    if (readBinary) {\n      return readBinary(wasmBinaryFile);\n    } else {\n      throw \"both async and sync fetching of the wasm failed\";\n    }\n  } catch (err) {\n    abort(err);\n  }\n}\n\nfunction getBinaryPromise() {\n  // if we don't have the binary yet, and have the Fetch api, use that\n  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n    return fetch(wasmBinaryFile, {\n      credentials: 'same-origin'\n    }).then(function (response) {\n      if (!response['ok']) {\n        throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n      }\n\n      return response['arrayBuffer']();\n    })[\"catch\"](function () {\n      return getBinary();\n    });\n  } // Otherwise, getBinary should be able to get it synchronously\n\n\n  return new _Promise(function (resolve, reject) {\n    resolve(getBinary());\n  });\n} // Create the wasm instance.\n// Receives the wasm imports, returns the exports.\n\n\nfunction createWasm() {\n  // prepare imports\n  var info = {\n    'env': asmLibraryArg,\n    'wasi_snapshot_preview1': asmLibraryArg\n  }; // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n\n  /** @param {WebAssembly.Module=} module*/\n\n  function receiveInstance(instance, module) {\n    var exports = instance.exports;\n    Module['asm'] = exports;\n    removeRunDependency('wasm-instantiate');\n  } // we can't run yet (except in a pthread, where we have a custom sync instantiator)\n\n\n  addRunDependency('wasm-instantiate'); // Async compilation can be confusing when an error on the page overwrites Module\n  // (for example, if the order of elements is wrong, and the one defining Module is\n  // later), so we save Module and check it later.\n\n  var trueModule = Module;\n\n  function receiveInstantiatedSource(output) {\n    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n    trueModule = null; // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\n\n    receiveInstance(output['instance']);\n  }\n\n  function instantiateArrayBuffer(receiver) {\n    return getBinaryPromise().then(function (binary) {\n      return WebAssembly.instantiate(binary, info);\n    }).then(receiver, function (reason) {\n      err('failed to asynchronously prepare wasm: ' + reason);\n      abort(reason);\n    });\n  } // Prefer streaming instantiation if available.\n\n\n  function instantiateAsync() {\n    if (!wasmBinary && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') {\n      fetch(wasmBinaryFile, {\n        credentials: 'same-origin'\n      }).then(function (response) {\n        var result = WebAssembly.instantiateStreaming(response, info);\n        return result.then(receiveInstantiatedSource, function (reason) {\n          // We expect the most common failure cause to be a bad MIME type for the binary,\n          // in which case falling back to ArrayBuffer instantiation should work.\n          err('wasm streaming compile failed: ' + reason);\n          err('falling back to ArrayBuffer instantiation');\n          instantiateArrayBuffer(receiveInstantiatedSource);\n        });\n      });\n    } else {\n      return instantiateArrayBuffer(receiveInstantiatedSource);\n    }\n  } // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n  // to any other async startup actions they are performing.\n\n\n  if (Module['instantiateWasm']) {\n    try {\n      var exports = Module['instantiateWasm'](info, receiveInstance);\n      return exports;\n    } catch (e) {\n      err('Module.instantiateWasm callback failed with error: ' + e);\n      return false;\n    }\n  }\n\n  instantiateAsync();\n  return {}; // no exports yet; we'll fill them in later\n} // Globals used by JS i64 conversions\n\n\nvar tempDouble;\nvar tempI64; // === Body ===\n\nvar ASM_CONSTS = {}; // STATICTOP = STATIC_BASE + 2736;\n\n/* global initializers */\n\n__ATINIT__.push({\n  func: function func() {\n    ___wasm_call_ctors();\n  }\n});\n/* no memory initializer */\n// {{PRE_LIBRARY}}\n\n\nfunction demangle(func) {\n  warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\n  return func;\n}\n\nfunction demangleAll(text) {\n  var regex = /\\b_Z[\\w\\d_]+/g;\n  return text.replace(regex, function (x) {\n    var y = demangle(x);\n    return x === y ? x : y + ' [' + x + ']';\n  });\n}\n\nfunction jsStackTrace() {\n  var err = new Error();\n\n  if (!err.stack) {\n    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n    // so try that as a special-case.\n    try {\n      throw new Error();\n    } catch (e) {\n      err = e;\n    }\n\n    if (!err.stack) {\n      return '(no stack trace available)';\n    }\n  }\n\n  return err.stack.toString();\n}\n\nfunction stackTrace() {\n  var js = jsStackTrace();\n  if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n  return demangleAll(js);\n}\n\nfunction ___handle_stack_overflow() {\n  abort('stack overflow');\n}\n\nfunction ___lock() {}\n\nfunction ___unlock() {}\n\nfunction _emscripten_get_heap_size() {\n  return HEAPU8.length;\n}\n\nfunction _emscripten_get_sbrk_ptr() {\n  return 3600;\n}\n\nfunction _emscripten_memcpy_big(dest, src, num) {\n  HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n}\n\nfunction abortOnCannotGrowMemory(requestedSize) {\n  abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n}\n\nfunction _emscripten_resize_heap(requestedSize) {\n  abortOnCannotGrowMemory(requestedSize);\n}\n\nfunction flush_NO_FILESYSTEM() {\n  // flush anything remaining in the buffers during shutdown\n  if (typeof _fflush !== 'undefined') _fflush(0);\n  var buffers = SYSCALLS.buffers;\n  if (buffers[1].length) SYSCALLS.printChar(1, 10);\n  if (buffers[2].length) SYSCALLS.printChar(2, 10);\n}\n\nvar PATH = {\n  splitPath: function splitPath(filename) {\n    var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n    return splitPathRe.exec(filename).slice(1);\n  },\n  normalizeArray: function normalizeArray(parts, allowAboveRoot) {\n    // if the path tries to go above the root, `up` ends up > 0\n    var up = 0;\n\n    for (var i = parts.length - 1; i >= 0; i--) {\n      var last = parts[i];\n\n      if (last === '.') {\n        parts.splice(i, 1);\n      } else if (last === '..') {\n        parts.splice(i, 1);\n        up++;\n      } else if (up) {\n        parts.splice(i, 1);\n        up--;\n      }\n    } // if the path is allowed to go above the root, restore leading ..s\n\n\n    if (allowAboveRoot) {\n      for (; up; up--) {\n        parts.unshift('..');\n      }\n    }\n\n    return parts;\n  },\n  normalize: function normalize(path) {\n    var isAbsolute = path.charAt(0) === '/',\n        trailingSlash = path.substr(-1) === '/'; // Normalize the path\n\n    path = PATH.normalizeArray(path.split('/').filter(function (p) {\n      return !!p;\n    }), !isAbsolute).join('/');\n\n    if (!path && !isAbsolute) {\n      path = '.';\n    }\n\n    if (path && trailingSlash) {\n      path += '/';\n    }\n\n    return (isAbsolute ? '/' : '') + path;\n  },\n  dirname: function dirname(path) {\n    var result = PATH.splitPath(path),\n        root = result[0],\n        dir = result[1];\n\n    if (!root && !dir) {\n      // No dirname whatsoever\n      return '.';\n    }\n\n    if (dir) {\n      // It has a dirname, strip trailing slash\n      dir = dir.substr(0, dir.length - 1);\n    }\n\n    return root + dir;\n  },\n  basename: function basename(path) {\n    // EMSCRIPTEN return '/'' for '/', not an empty string\n    if (path === '/') return '/';\n    var lastSlash = path.lastIndexOf('/');\n    if (lastSlash === -1) return path;\n    return path.substr(lastSlash + 1);\n  },\n  extname: function extname(path) {\n    return PATH.splitPath(path)[3];\n  },\n  join: function join() {\n    var paths = Array.prototype.slice.call(arguments, 0);\n    return PATH.normalize(paths.join('/'));\n  },\n  join2: function join2(l, r) {\n    return PATH.normalize(l + '/' + r);\n  }\n};\nvar SYSCALLS = {\n  buffers: [null, [], []],\n  printChar: function printChar(stream, curr) {\n    var buffer = SYSCALLS.buffers[stream];\n    assert(buffer);\n\n    if (curr === 0 || curr === 10) {\n      (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n      buffer.length = 0;\n    } else {\n      buffer.push(curr);\n    }\n  },\n  varargs: 0,\n  get: function get(varargs) {\n    SYSCALLS.varargs += 4;\n    var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n    return ret;\n  },\n  getStr: function getStr() {\n    var ret = UTF8ToString(SYSCALLS.get());\n    return ret;\n  },\n  get64: function get64() {\n    var low = SYSCALLS.get(),\n        high = SYSCALLS.get();\n    if (low >= 0) assert(high === 0);else assert(high === -1);\n    return low;\n  },\n  getZero: function getZero() {\n    assert(SYSCALLS.get() === 0);\n  }\n};\n\nfunction _fd_write(fd, iov, iovcnt, pnum) {\n  try {\n    // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n    var num = 0;\n\n    for (var i = 0; i < iovcnt; i++) {\n      var ptr = HEAP32[iov + i * 8 >> 2];\n      var len = HEAP32[iov + (i * 8 + 4) >> 2];\n\n      for (var j = 0; j < len; j++) {\n        SYSCALLS.printChar(fd, HEAPU8[ptr + j]);\n      }\n\n      num += len;\n    }\n\n    HEAP32[pnum >> 2] = num;\n    return 0;\n  } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n}\n\nfunction _memcpy(dest, src, num) {\n  dest = dest | 0;\n  src = src | 0;\n  num = num | 0;\n  var ret = 0;\n  var aligned_dest_end = 0;\n  var block_aligned_dest_end = 0;\n  var dest_end = 0; // Test against a benchmarked cutoff limit for when HEAPU8.set() becomes faster to use.\n\n  if ((num | 0) >= 8192) {\n    _emscripten_memcpy_big(dest | 0, src | 0, num | 0) | 0;\n    return dest | 0;\n  }\n\n  ret = dest | 0;\n  dest_end = dest + num | 0;\n\n  if ((dest & 3) == (src & 3)) {\n    // The initial unaligned < 4-byte front.\n    while (dest & 3) {\n      if ((num | 0) == 0) return ret | 0;\n      HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n      dest = dest + 1 | 0;\n      src = src + 1 | 0;\n      num = num - 1 | 0;\n    }\n\n    aligned_dest_end = dest_end & -4 | 0;\n    block_aligned_dest_end = aligned_dest_end - 64 | 0;\n\n    while ((dest | 0) <= (block_aligned_dest_end | 0)) {\n      HEAP32[dest >> 2] = HEAP32[src >> 2] | 0;\n      HEAP32[dest + 4 >> 2] = HEAP32[src + 4 >> 2] | 0;\n      HEAP32[dest + 8 >> 2] = HEAP32[src + 8 >> 2] | 0;\n      HEAP32[dest + 12 >> 2] = HEAP32[src + 12 >> 2] | 0;\n      HEAP32[dest + 16 >> 2] = HEAP32[src + 16 >> 2] | 0;\n      HEAP32[dest + 20 >> 2] = HEAP32[src + 20 >> 2] | 0;\n      HEAP32[dest + 24 >> 2] = HEAP32[src + 24 >> 2] | 0;\n      HEAP32[dest + 28 >> 2] = HEAP32[src + 28 >> 2] | 0;\n      HEAP32[dest + 32 >> 2] = HEAP32[src + 32 >> 2] | 0;\n      HEAP32[dest + 36 >> 2] = HEAP32[src + 36 >> 2] | 0;\n      HEAP32[dest + 40 >> 2] = HEAP32[src + 40 >> 2] | 0;\n      HEAP32[dest + 44 >> 2] = HEAP32[src + 44 >> 2] | 0;\n      HEAP32[dest + 48 >> 2] = HEAP32[src + 48 >> 2] | 0;\n      HEAP32[dest + 52 >> 2] = HEAP32[src + 52 >> 2] | 0;\n      HEAP32[dest + 56 >> 2] = HEAP32[src + 56 >> 2] | 0;\n      HEAP32[dest + 60 >> 2] = HEAP32[src + 60 >> 2] | 0;\n      dest = dest + 64 | 0;\n      src = src + 64 | 0;\n    }\n\n    while ((dest | 0) < (aligned_dest_end | 0)) {\n      HEAP32[dest >> 2] = HEAP32[src >> 2] | 0;\n      dest = dest + 4 | 0;\n      src = src + 4 | 0;\n    }\n  } else {\n    // In the unaligned copy case, unroll a bit as well.\n    aligned_dest_end = dest_end - 4 | 0;\n\n    while ((dest | 0) < (aligned_dest_end | 0)) {\n      HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n      HEAP8[dest + 1 >> 0] = HEAP8[src + 1 >> 0] | 0;\n      HEAP8[dest + 2 >> 0] = HEAP8[src + 2 >> 0] | 0;\n      HEAP8[dest + 3 >> 0] = HEAP8[src + 3 >> 0] | 0;\n      dest = dest + 4 | 0;\n      src = src + 4 | 0;\n    }\n  } // The remaining unaligned < 4 byte tail.\n\n\n  while ((dest | 0) < (dest_end | 0)) {\n    HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n    dest = dest + 1 | 0;\n    src = src + 1 | 0;\n  }\n\n  return ret | 0;\n}\n\nfunction _memset(ptr, value, num) {\n  ptr = ptr | 0;\n  value = value | 0;\n  num = num | 0;\n  var end = 0,\n      aligned_end = 0,\n      block_aligned_end = 0,\n      value4 = 0;\n  end = ptr + num | 0;\n  value = value & 0xff;\n\n  if ((num | 0) >= 67\n  /* 64 bytes for an unrolled loop + 3 bytes for unaligned head*/\n  ) {\n      while ((ptr & 3) != 0) {\n        HEAP8[ptr >> 0] = value;\n        ptr = ptr + 1 | 0;\n      }\n\n      aligned_end = end & -4 | 0;\n      value4 = value | value << 8 | value << 16 | value << 24;\n      block_aligned_end = aligned_end - 64 | 0;\n\n      while ((ptr | 0) <= (block_aligned_end | 0)) {\n        HEAP32[ptr >> 2] = value4;\n        HEAP32[ptr + 4 >> 2] = value4;\n        HEAP32[ptr + 8 >> 2] = value4;\n        HEAP32[ptr + 12 >> 2] = value4;\n        HEAP32[ptr + 16 >> 2] = value4;\n        HEAP32[ptr + 20 >> 2] = value4;\n        HEAP32[ptr + 24 >> 2] = value4;\n        HEAP32[ptr + 28 >> 2] = value4;\n        HEAP32[ptr + 32 >> 2] = value4;\n        HEAP32[ptr + 36 >> 2] = value4;\n        HEAP32[ptr + 40 >> 2] = value4;\n        HEAP32[ptr + 44 >> 2] = value4;\n        HEAP32[ptr + 48 >> 2] = value4;\n        HEAP32[ptr + 52 >> 2] = value4;\n        HEAP32[ptr + 56 >> 2] = value4;\n        HEAP32[ptr + 60 >> 2] = value4;\n        ptr = ptr + 64 | 0;\n      }\n\n      while ((ptr | 0) < (aligned_end | 0)) {\n        HEAP32[ptr >> 2] = value4;\n        ptr = ptr + 4 | 0;\n      }\n    } // The remaining bytes.\n\n\n  while ((ptr | 0) < (end | 0)) {\n    HEAP8[ptr >> 0] = value;\n    ptr = ptr + 1 | 0;\n  }\n\n  return end - num | 0;\n}\n\nfunction _setTempRet0($i) {\n  setTempRet0($i | 0);\n}\n\nvar ASSERTIONS = true; // Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n/** @type {function(string, boolean=, number=)} */\n\nfunction intArrayFromString(stringy, dontAddNull, length) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\n\nfunction intArrayToString(array) {\n  var ret = [];\n\n  for (var i = 0; i < array.length; i++) {\n    var chr = array[i];\n\n    if (chr > 0xFF) {\n      if (ASSERTIONS) {\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n      }\n\n      chr &= 0xFF;\n    }\n\n    ret.push(String.fromCharCode(chr));\n  }\n\n  return ret.join('');\n} // ASM_LIBRARY EXTERN PRIMITIVES: Int8Array,Int32Array\n\n\nvar asmGlobalArg = {};\nvar asmLibraryArg = {\n  \"__handle_stack_overflow\": ___handle_stack_overflow,\n  \"__lock\": ___lock,\n  \"__unlock\": ___unlock,\n  \"emscripten_get_sbrk_ptr\": _emscripten_get_sbrk_ptr,\n  \"emscripten_memcpy_big\": _emscripten_memcpy_big,\n  \"emscripten_resize_heap\": _emscripten_resize_heap,\n  \"fd_write\": _fd_write,\n  \"memory\": wasmMemory,\n  \"setTempRet0\": _setTempRet0,\n  \"table\": wasmTable\n};\nvar asm = createWasm();\nModule[\"asm\"] = asm;\n\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__wasm_call_ctors\"].apply(null, arguments);\n};\n\nvar _main = Module[\"_main\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"main\"].apply(null, arguments);\n};\n\nvar ___errno_location = Module[\"___errno_location\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__errno_location\"].apply(null, arguments);\n};\n\nvar _fflush = Module[\"_fflush\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"fflush\"].apply(null, arguments);\n};\n\nvar _setThrew = Module[\"_setThrew\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"setThrew\"].apply(null, arguments);\n};\n\nvar _malloc = Module[\"_malloc\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"malloc\"].apply(null, arguments);\n};\n\nvar _free = Module[\"_free\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"free\"].apply(null, arguments);\n};\n\nvar ___set_stack_limit = Module[\"___set_stack_limit\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__set_stack_limit\"].apply(null, arguments);\n};\n\nvar stackSave = Module[\"stackSave\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackSave\"].apply(null, arguments);\n};\n\nvar stackAlloc = Module[\"stackAlloc\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments);\n};\n\nvar stackRestore = Module[\"stackRestore\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackRestore\"].apply(null, arguments);\n};\n\nvar __growWasmMemory = Module[\"__growWasmMemory\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__growWasmMemory\"].apply(null, arguments);\n};\n\nvar dynCall_ii = Module[\"dynCall_ii\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments);\n};\n\nvar dynCall_iiii = Module[\"dynCall_iiii\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments);\n};\n\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_jiji\"].apply(null, arguments);\n};\n\nvar dynCall_iidiiii = Module[\"dynCall_iidiiii\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_iidiiii\"].apply(null, arguments);\n};\n\nvar dynCall_vii = Module[\"dynCall_vii\"] = function () {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_vii\"].apply(null, arguments);\n}; // === Auto-generated postamble setup entry stuff ===\n\n\nModule['asm'] = asm;\nif (!_Object$getOwnPropertyDescriptor(Module, \"intArrayFromString\")) Module[\"intArrayFromString\"] = function () {\n  abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"intArrayToString\")) Module[\"intArrayToString\"] = function () {\n  abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"ccall\")) Module[\"ccall\"] = function () {\n  abort(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"cwrap\")) Module[\"cwrap\"] = function () {\n  abort(\"'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"setValue\")) Module[\"setValue\"] = function () {\n  abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"getValue\")) Module[\"getValue\"] = function () {\n  abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"allocate\")) Module[\"allocate\"] = function () {\n  abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"getMemory\")) Module[\"getMemory\"] = function () {\n  abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"UTF8ArrayToString\")) Module[\"UTF8ArrayToString\"] = function () {\n  abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"UTF8ToString\")) Module[\"UTF8ToString\"] = function () {\n  abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"stringToUTF8Array\")) Module[\"stringToUTF8Array\"] = function () {\n  abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"stringToUTF8\")) Module[\"stringToUTF8\"] = function () {\n  abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"lengthBytesUTF8\")) Module[\"lengthBytesUTF8\"] = function () {\n  abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function () {\n  abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"addOnPreRun\")) Module[\"addOnPreRun\"] = function () {\n  abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"addOnInit\")) Module[\"addOnInit\"] = function () {\n  abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"addOnPreMain\")) Module[\"addOnPreMain\"] = function () {\n  abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"addOnExit\")) Module[\"addOnExit\"] = function () {\n  abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"addOnPostRun\")) Module[\"addOnPostRun\"] = function () {\n  abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"writeStringToMemory\")) Module[\"writeStringToMemory\"] = function () {\n  abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"writeArrayToMemory\")) Module[\"writeArrayToMemory\"] = function () {\n  abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"writeAsciiToMemory\")) Module[\"writeAsciiToMemory\"] = function () {\n  abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"addRunDependency\")) Module[\"addRunDependency\"] = function () {\n  abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"removeRunDependency\")) Module[\"removeRunDependency\"] = function () {\n  abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"FS_createFolder\")) Module[\"FS_createFolder\"] = function () {\n  abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"FS_createPath\")) Module[\"FS_createPath\"] = function () {\n  abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"FS_createDataFile\")) Module[\"FS_createDataFile\"] = function () {\n  abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"FS_createPreloadedFile\")) Module[\"FS_createPreloadedFile\"] = function () {\n  abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"FS_createLazyFile\")) Module[\"FS_createLazyFile\"] = function () {\n  abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"FS_createLink\")) Module[\"FS_createLink\"] = function () {\n  abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"FS_createDevice\")) Module[\"FS_createDevice\"] = function () {\n  abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"FS_unlink\")) Module[\"FS_unlink\"] = function () {\n  abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"dynamicAlloc\")) Module[\"dynamicAlloc\"] = function () {\n  abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"loadDynamicLibrary\")) Module[\"loadDynamicLibrary\"] = function () {\n  abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"loadWebAssemblyModule\")) Module[\"loadWebAssemblyModule\"] = function () {\n  abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"getLEB\")) Module[\"getLEB\"] = function () {\n  abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"getFunctionTables\")) Module[\"getFunctionTables\"] = function () {\n  abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"alignFunctionTables\")) Module[\"alignFunctionTables\"] = function () {\n  abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"registerFunctions\")) Module[\"registerFunctions\"] = function () {\n  abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"addFunction\")) Module[\"addFunction\"] = function () {\n  abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"removeFunction\")) Module[\"removeFunction\"] = function () {\n  abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = function () {\n  abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"prettyPrint\")) Module[\"prettyPrint\"] = function () {\n  abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"makeBigInt\")) Module[\"makeBigInt\"] = function () {\n  abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = function () {\n  abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"getCompilerSetting\")) Module[\"getCompilerSetting\"] = function () {\n  abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"print\")) Module[\"print\"] = function () {\n  abort(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"printErr\")) Module[\"printErr\"] = function () {\n  abort(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"getTempRet0\")) Module[\"getTempRet0\"] = function () {\n  abort(\"'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"setTempRet0\")) Module[\"setTempRet0\"] = function () {\n  abort(\"'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"callMain\")) Module[\"callMain\"] = function () {\n  abort(\"'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"abort\")) Module[\"abort\"] = function () {\n  abort(\"'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"PROCINFO\")) Module[\"PROCINFO\"] = function () {\n  abort(\"'PROCINFO' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"stringToNewUTF8\")) Module[\"stringToNewUTF8\"] = function () {\n  abort(\"'stringToNewUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"abortOnCannotGrowMemory\")) Module[\"abortOnCannotGrowMemory\"] = function () {\n  abort(\"'abortOnCannotGrowMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"emscripten_realloc_buffer\")) Module[\"emscripten_realloc_buffer\"] = function () {\n  abort(\"'emscripten_realloc_buffer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"ENV\")) Module[\"ENV\"] = function () {\n  abort(\"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"setjmpId\")) Module[\"setjmpId\"] = function () {\n  abort(\"'setjmpId' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"ERRNO_CODES\")) Module[\"ERRNO_CODES\"] = function () {\n  abort(\"'ERRNO_CODES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"ERRNO_MESSAGES\")) Module[\"ERRNO_MESSAGES\"] = function () {\n  abort(\"'ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"DNS__deps\")) Module[\"DNS__deps\"] = function () {\n  abort(\"'DNS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"DNS\")) Module[\"DNS\"] = function () {\n  abort(\"'DNS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"GAI_ERRNO_MESSAGES\")) Module[\"GAI_ERRNO_MESSAGES\"] = function () {\n  abort(\"'GAI_ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"Protocols\")) Module[\"Protocols\"] = function () {\n  abort(\"'Protocols' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"Sockets__deps\")) Module[\"Sockets__deps\"] = function () {\n  abort(\"'Sockets__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"Sockets\")) Module[\"Sockets\"] = function () {\n  abort(\"'Sockets' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"UNWIND_CACHE\")) Module[\"UNWIND_CACHE\"] = function () {\n  abort(\"'UNWIND_CACHE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"readAsmConstArgs\")) Module[\"readAsmConstArgs\"] = function () {\n  abort(\"'readAsmConstArgs' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"PATH\")) Module[\"PATH\"] = function () {\n  abort(\"'PATH' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"PATH_FS__deps\")) Module[\"PATH_FS__deps\"] = function () {\n  abort(\"'PATH_FS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"PATH_FS\")) Module[\"PATH_FS\"] = function () {\n  abort(\"'PATH_FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"SYSCALLS__deps\")) Module[\"SYSCALLS__deps\"] = function () {\n  abort(\"'SYSCALLS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"SYSCALLS\")) Module[\"SYSCALLS\"] = function () {\n  abort(\"'SYSCALLS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"flush_NO_FILESYSTEM\")) Module[\"flush_NO_FILESYSTEM\"] = function () {\n  abort(\"'flush_NO_FILESYSTEM' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"JSEvents\")) Module[\"JSEvents\"] = function () {\n  abort(\"'JSEvents' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"demangle__deps\")) Module[\"demangle__deps\"] = function () {\n  abort(\"'demangle__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"demangle\")) Module[\"demangle\"] = function () {\n  abort(\"'demangle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"demangleAll\")) Module[\"demangleAll\"] = function () {\n  abort(\"'demangleAll' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"jsStackTrace\")) Module[\"jsStackTrace\"] = function () {\n  abort(\"'jsStackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function () {\n  abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"writeI53ToI64__deps\")) Module[\"writeI53ToI64__deps\"] = function () {\n  abort(\"'writeI53ToI64__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"writeI53ToI64\")) Module[\"writeI53ToI64\"] = function () {\n  abort(\"'writeI53ToI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"writeI53ToI64Clamped\")) Module[\"writeI53ToI64Clamped\"] = function () {\n  abort(\"'writeI53ToI64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"writeI53ToI64Signaling\")) Module[\"writeI53ToI64Signaling\"] = function () {\n  abort(\"'writeI53ToI64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"writeI53ToU64Clamped\")) Module[\"writeI53ToU64Clamped\"] = function () {\n  abort(\"'writeI53ToU64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"writeI53ToU64Signaling\")) Module[\"writeI53ToU64Signaling\"] = function () {\n  abort(\"'writeI53ToU64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"readI53FromI64\")) Module[\"readI53FromI64\"] = function () {\n  abort(\"'readI53FromI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"readI53FromU64\")) Module[\"readI53FromU64\"] = function () {\n  abort(\"'readI53FromU64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"convertI32PairToI53\")) Module[\"convertI32PairToI53\"] = function () {\n  abort(\"'convertI32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"convertU32PairToI53\")) Module[\"convertU32PairToI53\"] = function () {\n  abort(\"'convertU32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"Browser__deps\")) Module[\"Browser__deps\"] = function () {\n  abort(\"'Browser__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"Browser__postset\")) Module[\"Browser__postset\"] = function () {\n  abort(\"'Browser__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"Browser\")) Module[\"Browser\"] = function () {\n  abort(\"'Browser' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"Browser__postset__deps\")) Module[\"Browser__postset__deps\"] = function () {\n  abort(\"'Browser__postset__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"FS__deps\")) Module[\"FS__deps\"] = function () {\n  abort(\"'FS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"FS__postset\")) Module[\"FS__postset\"] = function () {\n  abort(\"'FS__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"FS\")) Module[\"FS\"] = function () {\n  abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"MEMFS__deps\")) Module[\"MEMFS__deps\"] = function () {\n  abort(\"'MEMFS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"MEMFS\")) Module[\"MEMFS\"] = function () {\n  abort(\"'MEMFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"TTY__deps\")) Module[\"TTY__deps\"] = function () {\n  abort(\"'TTY__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"TTY__postset\")) Module[\"TTY__postset\"] = function () {\n  abort(\"'TTY__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"TTY\")) Module[\"TTY\"] = function () {\n  abort(\"'TTY' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"PIPEFS__postset\")) Module[\"PIPEFS__postset\"] = function () {\n  abort(\"'PIPEFS__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"PIPEFS__deps\")) Module[\"PIPEFS__deps\"] = function () {\n  abort(\"'PIPEFS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"PIPEFS\")) Module[\"PIPEFS\"] = function () {\n  abort(\"'PIPEFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"SOCKFS__postset\")) Module[\"SOCKFS__postset\"] = function () {\n  abort(\"'SOCKFS__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"SOCKFS__deps\")) Module[\"SOCKFS__deps\"] = function () {\n  abort(\"'SOCKFS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"SOCKFS\")) Module[\"SOCKFS\"] = function () {\n  abort(\"'SOCKFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"GL__postset\")) Module[\"GL__postset\"] = function () {\n  abort(\"'GL__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"GL__deps\")) Module[\"GL__deps\"] = function () {\n  abort(\"'GL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"GL\")) Module[\"GL\"] = function () {\n  abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet__deps\")) Module[\"emscriptenWebGLGet__deps\"] = function () {\n  abort(\"'emscriptenWebGLGet__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet\")) Module[\"emscriptenWebGLGet\"] = function () {\n  abort(\"'emscriptenWebGLGet' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData__deps\")) Module[\"emscriptenWebGLGetTexPixelData__deps\"] = function () {\n  abort(\"'emscriptenWebGLGetTexPixelData__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData\")) Module[\"emscriptenWebGLGetTexPixelData\"] = function () {\n  abort(\"'emscriptenWebGLGetTexPixelData' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform\")) Module[\"emscriptenWebGLGetUniform\"] = function () {\n  abort(\"'emscriptenWebGLGetUniform' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib\")) Module[\"emscriptenWebGLGetVertexAttrib\"] = function () {\n  abort(\"'emscriptenWebGLGetVertexAttrib' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"GL__postset__deps\")) Module[\"GL__postset__deps\"] = function () {\n  abort(\"'GL__postset__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform__deps\")) Module[\"emscriptenWebGLGetUniform__deps\"] = function () {\n  abort(\"'emscriptenWebGLGetUniform__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib__deps\")) Module[\"emscriptenWebGLGetVertexAttrib__deps\"] = function () {\n  abort(\"'emscriptenWebGLGetVertexAttrib__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"AL__deps\")) Module[\"AL__deps\"] = function () {\n  abort(\"'AL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"AL\")) Module[\"AL\"] = function () {\n  abort(\"'AL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"WebVR\")) Module[\"WebVR\"] = function () {\n  abort(\"'WebVR' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"WebVR__deps\")) Module[\"WebVR__deps\"] = function () {\n  abort(\"'WebVR__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"SDL__deps\")) Module[\"SDL__deps\"] = function () {\n  abort(\"'SDL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"SDL\")) Module[\"SDL\"] = function () {\n  abort(\"'SDL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"SDL_gfx\")) Module[\"SDL_gfx\"] = function () {\n  abort(\"'SDL_gfx' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"SDL_gfx__deps\")) Module[\"SDL_gfx__deps\"] = function () {\n  abort(\"'SDL_gfx__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"GLUT__deps\")) Module[\"GLUT__deps\"] = function () {\n  abort(\"'GLUT__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"GLUT\")) Module[\"GLUT\"] = function () {\n  abort(\"'GLUT' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"EGL__deps\")) Module[\"EGL__deps\"] = function () {\n  abort(\"'EGL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"EGL\")) Module[\"EGL\"] = function () {\n  abort(\"'EGL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"GLFW__deps\")) Module[\"GLFW__deps\"] = function () {\n  abort(\"'GLFW__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"GLFW\")) Module[\"GLFW\"] = function () {\n  abort(\"'GLFW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"GLEW__deps\")) Module[\"GLEW__deps\"] = function () {\n  abort(\"'GLEW__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"GLEW\")) Module[\"GLEW\"] = function () {\n  abort(\"'GLEW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"IDBStore\")) Module[\"IDBStore\"] = function () {\n  abort(\"'IDBStore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"IDBStore__deps\")) Module[\"IDBStore__deps\"] = function () {\n  abort(\"'IDBStore__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"runAndAbortIfError\")) Module[\"runAndAbortIfError\"] = function () {\n  abort(\"'runAndAbortIfError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"warnOnce\")) Module[\"warnOnce\"] = function () {\n  abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"stackSave\")) Module[\"stackSave\"] = function () {\n  abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"stackRestore\")) Module[\"stackRestore\"] = function () {\n  abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"stackAlloc\")) Module[\"stackAlloc\"] = function () {\n  abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"AsciiToString\")) Module[\"AsciiToString\"] = function () {\n  abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"stringToAscii\")) Module[\"stringToAscii\"] = function () {\n  abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"UTF16ToString\")) Module[\"UTF16ToString\"] = function () {\n  abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"stringToUTF16\")) Module[\"stringToUTF16\"] = function () {\n  abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"lengthBytesUTF16\")) Module[\"lengthBytesUTF16\"] = function () {\n  abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"UTF32ToString\")) Module[\"UTF32ToString\"] = function () {\n  abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"stringToUTF32\")) Module[\"stringToUTF32\"] = function () {\n  abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"lengthBytesUTF32\")) Module[\"lengthBytesUTF32\"] = function () {\n  abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"allocateUTF8\")) Module[\"allocateUTF8\"] = function () {\n  abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nif (!_Object$getOwnPropertyDescriptor(Module, \"allocateUTF8OnStack\")) Module[\"allocateUTF8OnStack\"] = function () {\n  abort(\"'allocateUTF8OnStack' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n};\nModule[\"writeStackCookie\"] = writeStackCookie;\nModule[\"checkStackCookie\"] = checkStackCookie;\nModule[\"abortStackOverflow\"] = abortStackOverflow;\nif (!_Object$getOwnPropertyDescriptor(Module, \"ALLOC_NORMAL\")) _Object$defineProperty(Module, \"ALLOC_NORMAL\", {\n  configurable: true,\n  get: function get() {\n    abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  }\n});\nif (!_Object$getOwnPropertyDescriptor(Module, \"ALLOC_STACK\")) _Object$defineProperty(Module, \"ALLOC_STACK\", {\n  configurable: true,\n  get: function get() {\n    abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  }\n});\nif (!_Object$getOwnPropertyDescriptor(Module, \"ALLOC_DYNAMIC\")) _Object$defineProperty(Module, \"ALLOC_DYNAMIC\", {\n  configurable: true,\n  get: function get() {\n    abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  }\n});\nif (!_Object$getOwnPropertyDescriptor(Module, \"ALLOC_NONE\")) _Object$defineProperty(Module, \"ALLOC_NONE\", {\n  configurable: true,\n  get: function get() {\n    abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  }\n});\nif (!_Object$getOwnPropertyDescriptor(Module, \"calledRun\")) _Object$defineProperty(Module, \"calledRun\", {\n  configurable: true,\n  get: function get() {\n    abort(\"'calledRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  }\n});\nvar calledRun;\n/**\n * @constructor\n * @this {ExitStatus}\n */\n\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\" + status + \")\";\n  this.status = status;\n}\n\nvar calledMain = false;\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n};\n\nfunction callMain(args) {\n  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])');\n  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');\n  var entryFunction = Module['_main'];\n  args = args || [];\n  var argc = args.length + 1;\n  var argv = stackAlloc((argc + 1) * 4);\n  HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);\n\n  for (var i = 1; i < argc; i++) {\n    HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);\n  }\n\n  HEAP32[(argv >> 2) + argc] = 0;\n\n  try {\n    Module['___set_stack_limit'](STACK_MAX);\n    var ret = entryFunction(argc, argv); // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as execution is asynchronously handed\n    // off to a pthread.\n    // if we're not running an evented main loop, it's time to exit\n\n    exit(ret,\n    /* implicit = */\n    true);\n  } catch (e) {\n    if (e instanceof ExitStatus) {\n      // exit() throws this once it's done to make sure execution\n      // has been stopped completely\n      return;\n    } else if (e == 'unwind') {\n      // running an evented main loop, don't immediately exit\n      noExitRuntime = true;\n      return;\n    } else {\n      var toLog = e;\n\n      if (e && typeof e === 'object' && e.stack) {\n        toLog = [e, e.stack];\n      }\n\n      err('exception thrown: ' + toLog);\n      quit_(1, e);\n    }\n  } finally {\n    calledMain = true;\n  }\n}\n/** @type {function(Array=)} */\n\n\nfunction run(args) {\n  args = args || arguments_;\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n  writeStackCookie();\n  preRun();\n  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    if (calledRun) return;\n    calledRun = true;\n    if (ABORT) return;\n    initRuntime();\n    preMain();\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n    if (shouldRunNow) callMain(args);\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function () {\n      setTimeout(function () {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else {\n    doRun();\n  }\n\n  checkStackCookie();\n}\n\nModule['run'] = run;\n\nfunction checkUnflushedContent() {\n  // Compiler settings do not allow exiting the runtime, so flushing\n  // the streams is not possible. but in ASSERTIONS mode we check\n  // if there was something to flush, and if so tell the user they\n  // should request that the runtime be exitable.\n  // Normally we would not even include flush() at all, but in ASSERTIONS\n  // builds we do so just for this check, and here we see if there is any\n  // content to flush, that is, we check if there would have been\n  // something a non-ASSERTIONS build would have not seen.\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n  // mode (which has its own special function for this; otherwise, all\n  // the code is inside libc)\n  var print = out;\n  var printErr = err;\n  var has = false;\n\n  out = err = function err(x) {\n    has = true;\n  };\n\n  try {\n    // it doesn't matter if it fails\n    var flush = flush_NO_FILESYSTEM;\n    if (flush) flush(0);\n  } catch (e) {}\n\n  out = print;\n  err = printErr;\n\n  if (has) {\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');\n    warnOnce('(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)');\n  }\n}\n\nfunction exit(status, implicit) {\n  checkUnflushedContent(); // if this is just main exit-ing implicitly, and the status is 0, then we\n  // don't need to do anything here and can just leave. if the status is\n  // non-zero, though, then we need to report it.\n  // (we may have warned about this earlier, if a situation justifies doing so)\n\n  if (implicit && noExitRuntime && status === 0) {\n    return;\n  }\n\n  if (noExitRuntime) {\n    // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n    if (!implicit) {\n      err('program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');\n    }\n  } else {\n    ABORT = true;\n    EXITSTATUS = status;\n    exitRuntime();\n    if (Module['onExit']) Module['onExit'](status);\n  }\n\n  quit_(status, new ExitStatus(status));\n}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n} // shouldRunNow refers to calling main(), not run().\n\n\nvar shouldRunNow = true;\nif (Module['noInitialRun']) shouldRunNow = false;\nnoExitRuntime = true;\nrun(); // {{MODULE_ADDITIONS}}","map":{"version":3,"sources":["/Users/shaobozhang/my_codes/my_next/wasm/a.out.js"],"names":["Module","moduleOverrides","key","hasOwnProperty","arguments_","thisProgram","quit_","status","toThrow","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","ENVIRONMENT_IS_NODE","ENVIRONMENT_IS_SHELL","importScripts","process","versions","node","Error","scriptDirectory","locateFile","path","read_","readAsync","readBinary","setWindowTitle","nodeFS","nodePath","require","dirname","__dirname","shell_read","filename","binary","ret","buffer","Uint8Array","assert","length","replace","slice","module","ex","ExitStatus","abort","read","f","data","readbuffer","scriptArgs","arguments","quit","print","console","log","warn","error","printErr","self","location","href","document","currentScript","src","indexOf","substr","lastIndexOf","url","xhr","XMLHttpRequest","open","send","responseText","responseType","response","onload","onerror","xhr_onload","title","out","bind","err","configurable","get","IDBFS","PROXYFS","WORKERFS","NODEFS","STACK_ALIGN","stackSave","stackRestore","stackAlloc","staticAlloc","size","dynamicAlloc","DYNAMICTOP_PTR","HEAP32","end","_emscripten_get_heap_size","alignMemory","factor","Math","ceil","getNativeTypeSize","type","bits","warnOnce","text","shown","convertJsFunctionToWasm","func","sig","WebAssembly","Function","typeNames","parameters","results","i","push","typeSection","sigRet","sigParam","typeCodes","concat","bytes","instance","Instance","wrappedFunc","exports","addFunctionWasm","table","wasmTable","grow","RangeError","set","TypeError","wrapped","removeFunctionWasm","index","addFunction","removeFunction","funcWrappers","getFuncWrapper","sigCache","dynCall_wrapper","dynCall","arg","Array","prototype","call","makeBigInt","low","high","unsigned","ptr","args","substring","apply","tempRet0","setTempRet0","value","getTempRet0","getCompilerSetting","name","Runtime","GLOBAL_BASE","wasmBinary","noExitRuntime","setValue","noSafe","charAt","HEAP8","HEAP16","tempI64","tempDouble","Math_abs","Math_min","Math_floor","Math_ceil","HEAPF32","HEAPF64","getValue","wasmMemory","Table","ABORT","EXITSTATUS","condition","getCFunc","ident","ccall","returnType","argTypes","opts","toC","str","undefined","len","stringToUTF8","arr","writeArrayToMemory","convertReturnValue","UTF8ToString","Boolean","cArgs","stack","converter","cwrap","ALLOC_NORMAL","ALLOC_STACK","ALLOC_DYNAMIC","ALLOC_NONE","allocate","slab","types","allocator","zeroinit","singleType","_malloc","max","stop","subarray","HEAPU8","typeSize","previousType","curr","getMemory","runtimeInitialized","UTF8Decoder","TextDecoder","UTF8ArrayToString","u8Array","idx","maxBytesToRead","endIdx","endPtr","decode","u0","String","fromCharCode","u1","u2","toString","ch","stringToUTF8Array","outU8Array","outIdx","maxBytesToWrite","startIdx","u","charCodeAt","outPtr","lengthBytesUTF8","AsciiToString","stringToAscii","writeAsciiToMemory","UTF16Decoder","UTF16ToString","codeUnit","stringToUTF16","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","stringToUTF32","trailSurrogate","lengthBytesUTF32","allocateUTF8","allocateUTF8OnStack","writeStringToMemory","string","dontAddNull","lastChar","Infinity","array","PAGE_SIZE","WASM_PAGE_SIZE","ASMJS_PAGE_SIZE","alignUp","x","multiple","HEAP","HEAPU16","HEAPU32","updateGlobalBufferAndViews","buf","Int8Array","Int16Array","Int32Array","Uint16Array","Uint32Array","Float32Array","Float64Array","STATIC_BASE","STACK_BASE","STACKTOP","STACK_MAX","DYNAMIC_BASE","TOTAL_STACK","INITIAL_TOTAL_MEMORY","Memory","byteLength","writeStackCookie","checkStackCookie","cookie1","cookie2","abortStackOverflow","allocSize","h16","h8","abortFnPtrError","callRuntimeCallbacks","callbacks","callback","shift","__ATPRERUN__","__ATINIT__","__ATMAIN__","__ATEXIT__","__ATPOSTRUN__","runtimeExited","preRun","addOnPreRun","initRuntime","preMain","exitRuntime","postRun","addOnPostRun","cb","unshift","addOnInit","addOnPreMain","addOnExit","unSign","ignore","abs","pow","reSign","half","imul","fround","clz32","trunc","Math_cos","cos","Math_sin","sin","Math_tan","tan","Math_acos","acos","Math_asin","asin","Math_atan","atan","Math_atan2","atan2","Math_exp","exp","Math_log","Math_sqrt","sqrt","floor","Math_pow","Math_imul","Math_fround","Math_round","round","min","Math_max","Math_clz32","Math_trunc","runDependencies","runDependencyWatcher","dependenciesFulfilled","runDependencyTracking","getUniqueRunDependency","id","orig","random","addRunDependency","setInterval","clearInterval","dep","removeRunDependency","what","output","stackTrace","RuntimeError","memoryInitializer","FS","init","createDataFile","createPreloadedFile","createLazyFile","mkdev","registerDevice","analyzePath","loadFilesFromDB","ErrnoError","dataURIPrefix","isDataURI","startsWith","wasmBinaryFile","getBinary","getBinaryPromise","fetch","credentials","then","resolve","reject","createWasm","info","asmLibraryArg","receiveInstance","trueModule","receiveInstantiatedSource","instantiateArrayBuffer","receiver","instantiate","reason","instantiateAsync","instantiateStreaming","result","e","ASM_CONSTS","___wasm_call_ctors","demangle","demangleAll","regex","y","jsStackTrace","js","___handle_stack_overflow","___lock","___unlock","_emscripten_get_sbrk_ptr","_emscripten_memcpy_big","dest","num","abortOnCannotGrowMemory","requestedSize","_emscripten_resize_heap","flush_NO_FILESYSTEM","_fflush","buffers","SYSCALLS","printChar","PATH","splitPath","splitPathRe","exec","normalizeArray","parts","allowAboveRoot","up","last","splice","normalize","isAbsolute","trailingSlash","split","filter","p","join","root","dir","basename","lastSlash","extname","paths","join2","l","r","stream","varargs","getStr","get64","getZero","_fd_write","fd","iov","iovcnt","pnum","j","errno","_memcpy","aligned_dest_end","block_aligned_dest_end","dest_end","_memset","aligned_end","block_aligned_end","value4","_setTempRet0","$i","ASSERTIONS","intArrayFromString","stringy","u8array","numBytesWritten","intArrayToString","chr","asmGlobalArg","asm","_main","___errno_location","_setThrew","_free","___set_stack_limit","__growWasmMemory","dynCall_ii","dynCall_iiii","dynCall_jiji","dynCall_iidiiii","dynCall_vii","calledRun","message","calledMain","runCaller","run","callMain","entryFunction","argc","argv","exit","toLog","doRun","shouldRunNow","setTimeout","checkUnflushedContent","has","flush","implicit","pop"],"mappings":"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","sourcesContent":["// Copyright 2010 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof Module !== 'undefined' ? Module : {};\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = {};\nvar key;\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\nvar arguments_ = [];\nvar thisProgram = './this.program';\nvar quit_ = function(status, toThrow) {\n  throw toThrow;\n};\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\nvar ENVIRONMENT_IS_WEB = false;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\nENVIRONMENT_IS_WEB = typeof window === 'object';\nENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\n// also a web environment.\nENVIRONMENT_IS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';\nENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\nif (Module['ENVIRONMENT']) {\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');\n}\n\n\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar read_,\n    readAsync,\n    readBinary,\n    setWindowTitle;\n\nvar nodeFS;\nvar nodePath;\n\nif (ENVIRONMENT_IS_NODE) {\n  if (ENVIRONMENT_IS_WORKER) {\n    scriptDirectory = require('path').dirname(scriptDirectory) + '/';\n  } else {\n    scriptDirectory = __dirname + '/';\n  }\n\n\n  read_ = function shell_read(filename, binary) {\n    if (!nodeFS) nodeFS = require('fs');\n    if (!nodePath) nodePath = require('path');\n    filename = nodePath['normalize'](filename);\n    return nodeFS['readFileSync'](filename, binary ? null : 'utf8');\n  };\n\n  readBinary = function readBinary(filename) {\n    var ret = read_(filename, true);\n    if (!ret.buffer) {\n      ret = new Uint8Array(ret);\n    }\n    assert(ret.buffer);\n    return ret;\n  };\n\n\n\n\n  if (process['argv'].length > 1) {\n    thisProgram = process['argv'][1].replace(/\\\\/g, '/');\n  }\n\n  arguments_ = process['argv'].slice(2);\n\n  if (typeof module !== 'undefined') {\n    module['exports'] = Module;\n  }\n\n  process['on']('uncaughtException', function(ex) {\n    // suppress ExitStatus exceptions from showing an error\n    if (!(ex instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n\n  process['on']('unhandledRejection', abort);\n\n  quit_ = function(status) {\n    process['exit'](status);\n  };\n\n  Module['inspect'] = function () { return '[Emscripten Module object]'; };\n\n\n\n} else\nif (ENVIRONMENT_IS_SHELL) {\n\n\n  if (typeof read != 'undefined') {\n    read_ = function shell_read(f) {\n      return read(f);\n    };\n  }\n\n  readBinary = function readBinary(f) {\n    var data;\n    if (typeof readbuffer === 'function') {\n      return new Uint8Array(readbuffer(f));\n    }\n    data = read(f, 'binary');\n    assert(typeof data === 'object');\n    return data;\n  };\n\n  if (typeof scriptArgs != 'undefined') {\n    arguments_ = scriptArgs;\n  } else if (typeof arguments != 'undefined') {\n    arguments_ = arguments;\n  }\n\n  if (typeof quit === 'function') {\n    quit_ = function(status) {\n      quit(status);\n    };\n  }\n\n  if (typeof print !== 'undefined') {\n    // Prefer to use print/printErr where they exist, as they usually work better.\n    if (typeof console === 'undefined') console = {};\n    console.log = print;\n    console.warn = console.error = typeof printErr !== 'undefined' ? printErr : print;\n  }\n\n\n} else\n\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n// ENVIRONMENT_IS_NODE.\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\n    scriptDirectory = self.location.href;\n  } else if (document.currentScript) { // web\n    scriptDirectory = document.currentScript.src;\n  }\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n  // otherwise, slice off the final part of the url to find the script directory.\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n  // and scriptDirectory will correctly be replaced with an empty string.\n  if (scriptDirectory.indexOf('blob:') !== 0) {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);\n  } else {\n    scriptDirectory = '';\n  }\n\n\n  // Differentiate the Web Worker from the Node Worker case, as reading must\n  // be done differently.\n  {\n\n\n  read_ = function shell_read(url) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.send(null);\n      return xhr.responseText;\n  };\n\n  if (ENVIRONMENT_IS_WORKER) {\n    readBinary = function readBinary(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.responseType = 'arraybuffer';\n        xhr.send(null);\n        return new Uint8Array(xhr.response);\n    };\n  }\n\n  readAsync = function readAsync(url, onload, onerror) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function xhr_onload() {\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n        onload(xhr.response);\n        return;\n      }\n      onerror();\n    };\n    xhr.onerror = onerror;\n    xhr.send(null);\n  };\n\n\n\n\n  }\n\n  setWindowTitle = function(title) { document.title = title };\n} else\n{\n  throw new Error('environment detection error');\n}\n\n\n// Set up the out() and err() hooks, which are how we can print to stdout or\n// stderr, respectively.\nvar out = Module['print'] || console.log.bind(console);\nvar err = Module['printErr'] || console.warn.bind(console);\n\n// Merge back in the overrides\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n}\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = null;\n\n// Emit code to handle expected values on the Module object. This applies Module.x\n// to the proper local x. This has two benefits: first, we only emit it if it is\n// expected to arrive, and second, by using a local everywhere else that can be\n// minified.\nif (Module['arguments']) arguments_ = Module['arguments'];if (!Object.getOwnPropertyDescriptor(Module, 'arguments')) Object.defineProperty(Module, 'arguments', { configurable: true, get: function() { abort('Module.arguments has been replaced with plain arguments_') } });\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];if (!Object.getOwnPropertyDescriptor(Module, 'thisProgram')) Object.defineProperty(Module, 'thisProgram', { configurable: true, get: function() { abort('Module.thisProgram has been replaced with plain thisProgram') } });\nif (Module['quit']) quit_ = Module['quit'];if (!Object.getOwnPropertyDescriptor(Module, 'quit')) Object.defineProperty(Module, 'quit', { configurable: true, get: function() { abort('Module.quit has been replaced with plain quit_') } });\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n// Assertions on removed incoming Module JS APIs.\nassert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['read'] === 'undefined', 'Module.read option was removed (modify read_ in JS)');\nassert(typeof Module['readAsync'] === 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\nassert(typeof Module['readBinary'] === 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\nassert(typeof Module['setWindowTitle'] === 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');\nif (!Object.getOwnPropertyDescriptor(Module, 'read')) Object.defineProperty(Module, 'read', { configurable: true, get: function() { abort('Module.read has been replaced with plain read_') } });\nif (!Object.getOwnPropertyDescriptor(Module, 'readAsync')) Object.defineProperty(Module, 'readAsync', { configurable: true, get: function() { abort('Module.readAsync has been replaced with plain readAsync') } });\nif (!Object.getOwnPropertyDescriptor(Module, 'readBinary')) Object.defineProperty(Module, 'readBinary', { configurable: true, get: function() { abort('Module.readBinary has been replaced with plain readBinary') } });\n// TODO: add when SDL2 is fixed if (!Object.getOwnPropertyDescriptor(Module, 'setWindowTitle')) Object.defineProperty(Module, 'setWindowTitle', { configurable: true, get: function() { abort('Module.setWindowTitle has been replaced with plain setWindowTitle') } });\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\n\n\n// TODO remove when SDL2 is fixed (also see above)\n\n\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// {{PREAMBLE_ADDITIONS}}\n\nvar STACK_ALIGN = 16;\n\n// stack management, and other functionality that is provided by the compiled code,\n// should not be used before it is ready\nstackSave = stackRestore = stackAlloc = function() {\n  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n};\n\nfunction staticAlloc(size) {\n  abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');\n}\n\nfunction dynamicAlloc(size) {\n  assert(DYNAMICTOP_PTR);\n  var ret = HEAP32[DYNAMICTOP_PTR>>2];\n  var end = (ret + size + 15) & -16;\n  if (end > _emscripten_get_heap_size()) {\n    abort('failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly');\n  }\n  HEAP32[DYNAMICTOP_PTR>>2] = end;\n  return ret;\n}\n\nfunction alignMemory(size, factor) {\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n  return Math.ceil(size / factor) * factor;\n}\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1': case 'i8': return 1;\n    case 'i16': return 2;\n    case 'i32': return 4;\n    case 'i64': return 8;\n    case 'float': return 4;\n    case 'double': return 8;\n    default: {\n      if (type[type.length-1] === '*') {\n        return 4; // A pointer\n      } else if (type[0] === 'i') {\n        var bits = parseInt(type.substr(1));\n        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\n        return bits / 8;\n      } else {\n        return 0;\n      }\n    }\n  }\n}\n\nfunction warnOnce(text) {\n  if (!warnOnce.shown) warnOnce.shown = {};\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    err(text);\n  }\n}\n\n\n\n\n\n\n// Wraps a JS function as a wasm function with a given signature.\nfunction convertJsFunctionToWasm(func, sig) {\n\n  // If the type reflection proposal is available, use the new\n  // \"WebAssembly.Function\" constructor.\n  // Otherwise, construct a minimal wasm module importing the JS function and\n  // re-exporting it.\n  if (typeof WebAssembly.Function === \"function\") {\n    var typeNames = {\n      'i': 'i32',\n      'j': 'i64',\n      'f': 'f32',\n      'd': 'f64'\n    };\n    var type = {\n      parameters: [],\n      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\n    };\n    for (var i = 1; i < sig.length; ++i) {\n      type.parameters.push(typeNames[sig[i]]);\n    }\n    return new WebAssembly.Function(type, func);\n  }\n\n  // The module is static, with the exception of the type section, which is\n  // generated based on the signature passed in.\n  var typeSection = [\n    0x01, // id: section,\n    0x00, // length: 0 (placeholder)\n    0x01, // count: 1\n    0x60, // form: func\n  ];\n  var sigRet = sig.slice(0, 1);\n  var sigParam = sig.slice(1);\n  var typeCodes = {\n    'i': 0x7f, // i32\n    'j': 0x7e, // i64\n    'f': 0x7d, // f32\n    'd': 0x7c, // f64\n  };\n\n  // Parameters, length + signatures\n  typeSection.push(sigParam.length);\n  for (var i = 0; i < sigParam.length; ++i) {\n    typeSection.push(typeCodes[sigParam[i]]);\n  }\n\n  // Return values, length + signatures\n  // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n  if (sigRet == 'v') {\n    typeSection.push(0x00);\n  } else {\n    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\n  }\n\n  // Write the overall length of the type section back into the section header\n  // (excepting the 2 bytes for the section id and length)\n  typeSection[1] = typeSection.length - 2;\n\n  // Rest of the module is static\n  var bytes = new Uint8Array([\n    0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\n    0x01, 0x00, 0x00, 0x00, // version: 1\n  ].concat(typeSection, [\n    0x02, 0x07, // import section\n      // (import \"e\" \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,\n    0x07, 0x05, // export section\n      // (export \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x66, 0x00, 0x00,\n  ]));\n\n   // We can compile this wasm module synchronously because it is very small.\n  // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n  var module = new WebAssembly.Module(bytes);\n  var instance = new WebAssembly.Instance(module, {\n    'e': {\n      'f': func\n    }\n  });\n  var wrappedFunc = instance.exports['f'];\n  return wrappedFunc;\n}\n\n// Add a wasm function to the table.\nfunction addFunctionWasm(func, sig) {\n  var table = wasmTable;\n  var ret = table.length;\n\n  // Grow the table\n  try {\n    table.grow(1);\n  } catch (err) {\n    if (!(err instanceof RangeError)) {\n      throw err;\n    }\n    throw 'Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.';\n  }\n\n  // Insert new element\n  try {\n    // Attempting to call this with JS function will cause of table.set() to fail\n    table.set(ret, func);\n  } catch (err) {\n    if (!(err instanceof TypeError)) {\n      throw err;\n    }\n    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');\n    var wrapped = convertJsFunctionToWasm(func, sig);\n    table.set(ret, wrapped);\n  }\n\n  return ret;\n}\n\nfunction removeFunctionWasm(index) {\n  // TODO(sbc): Look into implementing this to allow re-using of table slots\n}\n\n// 'sig' parameter is required for the llvm backend but only when func is not\n// already a WebAssembly function.\nfunction addFunction(func, sig) {\n  assert(typeof func !== 'undefined');\n\n  return addFunctionWasm(func, sig);\n}\n\nfunction removeFunction(index) {\n  removeFunctionWasm(index);\n}\n\n\n\nvar funcWrappers = {};\n\nfunction getFuncWrapper(func, sig) {\n  if (!func) return; // on null pointer, return undefined\n  assert(sig);\n  if (!funcWrappers[sig]) {\n    funcWrappers[sig] = {};\n  }\n  var sigCache = funcWrappers[sig];\n  if (!sigCache[func]) {\n    // optimize away arguments usage in common cases\n    if (sig.length === 1) {\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func);\n      };\n    } else if (sig.length === 2) {\n      sigCache[func] = function dynCall_wrapper(arg) {\n        return dynCall(sig, func, [arg]);\n      };\n    } else {\n      // general case\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func, Array.prototype.slice.call(arguments));\n      };\n    }\n  }\n  return sigCache[func];\n}\n\n\nfunction makeBigInt(low, high, unsigned) {\n  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));\n}\n\nfunction dynCall(sig, ptr, args) {\n  if (args && args.length) {\n    // j (64-bit integer) must be passed in as two numbers [low 32, high 32].\n    assert(args.length === sig.substring(1).replace(/j/g, '--').length);\n    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n  } else {\n    assert(sig.length == 1);\n    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].call(null, ptr);\n  }\n}\n\nvar tempRet0 = 0;\n\nvar setTempRet0 = function(value) {\n  tempRet0 = value;\n};\n\nvar getTempRet0 = function() {\n  return tempRet0;\n};\n\nfunction getCompilerSetting(name) {\n  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n}\n\nvar Runtime = {\n  // helpful errors\n  getTempRet0: function() { abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n  staticAlloc: function() { abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n  stackAlloc: function() { abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n};\n\n// The address globals begin at. Very low in memory, for code size and optimization opportunities.\n// Above 0 is static memory, starting with globals.\n// Then the stack.\n// Then 'dynamic' memory for sbrk.\nvar GLOBAL_BASE = 1024;\n\n\n\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n\nvar wasmBinary;if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];if (!Object.getOwnPropertyDescriptor(Module, 'wasmBinary')) Object.defineProperty(Module, 'wasmBinary', { configurable: true, get: function() { abort('Module.wasmBinary has been replaced with plain wasmBinary') } });\nvar noExitRuntime;if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];if (!Object.getOwnPropertyDescriptor(Module, 'noExitRuntime')) Object.defineProperty(Module, 'noExitRuntime', { configurable: true, get: function() { abort('Module.noExitRuntime has been replaced with plain noExitRuntime') } });\n\n\nif (typeof WebAssembly !== 'object') {\n  abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');\n}\n\n\n// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.\n// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)\n\n/** @type {function(number, number, string, boolean=)} */\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': HEAP8[((ptr)>>0)]=value; break;\n      case 'i8': HEAP8[((ptr)>>0)]=value; break;\n      case 'i16': HEAP16[((ptr)>>1)]=value; break;\n      case 'i32': HEAP32[((ptr)>>2)]=value; break;\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;\n      case 'float': HEAPF32[((ptr)>>2)]=value; break;\n      case 'double': HEAPF64[((ptr)>>3)]=value; break;\n      default: abort('invalid type for setValue: ' + type);\n    }\n}\n\n/** @type {function(number, string, boolean=)} */\nfunction getValue(ptr, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': return HEAP8[((ptr)>>0)];\n      case 'i8': return HEAP8[((ptr)>>0)];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': return HEAP32[((ptr)>>2)];\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      default: abort('invalid type for getValue: ' + type);\n    }\n  return null;\n}\n\n\n\n\n\n// Wasm globals\n\nvar wasmMemory;\n\n// In fastcomp asm.js, we don't need a wasm Table at all.\n// In the wasm backend, we polyfill the WebAssembly object,\n// so this creates a (non-native-wasm) table for us.\nvar wasmTable = new WebAssembly.Table({\n  'initial': 6,\n  'maximum': 6 + 0,\n  'element': 'anyfunc'\n});\n\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS = 0;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed: ' + text);\n  }\n}\n\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\nfunction getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n  return func;\n}\n\n// C calling interface.\nfunction ccall(ident, returnType, argTypes, args, opts) {\n  // For fast lookup of conversion functions\n  var toC = {\n    'string': function(str) {\n      var ret = 0;\n      if (str !== null && str !== undefined && str !== 0) { // null string\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n        var len = (str.length << 2) + 1;\n        ret = stackAlloc(len);\n        stringToUTF8(str, ret, len);\n      }\n      return ret;\n    },\n    'array': function(arr) {\n      var ret = stackAlloc(arr.length);\n      writeArrayToMemory(arr, ret);\n      return ret;\n    }\n  };\n\n  function convertReturnValue(ret) {\n    if (returnType === 'string') return UTF8ToString(ret);\n    if (returnType === 'boolean') return Boolean(ret);\n    return ret;\n  }\n\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  assert(returnType !== 'array', 'Return type should not be \"array\".');\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n  var ret = func.apply(null, cArgs);\n\n  ret = convertReturnValue(ret);\n  if (stack !== 0) stackRestore(stack);\n  return ret;\n}\n\nfunction cwrap(ident, returnType, argTypes, opts) {\n  return function() {\n    return ccall(ident, returnType, argTypes, arguments, opts);\n  }\n}\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\nvar ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk\nvar ALLOC_NONE = 3; // Do not allocate\n\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\n//        affect this!)\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\n//         or a single type which is used for the entire block. This only matters if there\n//         is initial data - if @slab is a number, then this does not matter at all and is\n//         ignored.\n// @allocator: How to allocate memory, see ALLOC_*\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n  if (typeof slab === 'number') {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n\n  var singleType = typeof types === 'string' ? types : null;\n\n  var ret;\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [_malloc,\n    stackAlloc,\n    dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n\n  if (zeroinit) {\n    var stop;\n    ptr = ret;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[((ptr)>>2)]=0;\n    }\n    stop = ret + size;\n    while (ptr < stop) {\n      HEAP8[((ptr++)>>0)]=0;\n    }\n    return ret;\n  }\n\n  if (singleType === 'i8') {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n    return ret;\n  }\n\n  var i = 0, type, typeSize, previousType;\n  while (i < size) {\n    var curr = slab[i];\n\n    type = singleType || types[i];\n    if (type === 0) {\n      i++;\n      continue;\n    }\n    assert(type, 'Must know what type to store in allocate!');\n\n    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n    setValue(ret+i, curr, type);\n\n    // no need to look up size unless type changes, so cache it\n    if (previousType !== type) {\n      typeSize = getNativeTypeSize(type);\n      previousType = type;\n    }\n    i += typeSize;\n  }\n\n  return ret;\n}\n\n// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\nfunction getMemory(size) {\n  if (!runtimeInitialized) return dynamicAlloc(size);\n  return _malloc(size);\n}\n\n\n// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n\n/**\n * @param {number} idx\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\n  while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n  } else {\n    var str = '';\n    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\n    while (idx < endPtr) {\n      // For UTF8 byte structure, see:\n      // http://en.wikipedia.org/wiki/UTF-8#Description\n      // https://www.ietf.org/rfc/rfc2279.txt\n      // https://tools.ietf.org/html/rfc3629\n      var u0 = u8Array[idx++];\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n      var u1 = u8Array[idx++] & 63;\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n      var u2 = u8Array[idx++] & 63;\n      if ((u0 & 0xF0) == 0xE0) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (u8Array[idx++] & 63);\n      }\n\n      if (u0 < 0x10000) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 0x10000;\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n      }\n    }\n  }\n  return str;\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\n// copy of that string as a Javascript String object.\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\n//                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\n//                 style or the other.\n/**\n * @param {number} ptr\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ToString(ptr, maxBytesToRead) {\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n}\n\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n//                    This count should include the null terminator,\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) {\n      var u1 = str.charCodeAt(++i);\n      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\n    }\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      outU8Array[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      outU8Array[outIdx++] = 0xC0 | (u >> 6);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      outU8Array[outIdx++] = 0xE0 | (u >> 12);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');\n      outU8Array[outIdx++] = 0xF0 | (u >> 18);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  outU8Array[outIdx] = 0;\n  return outIdx - startIdx;\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) ++len;\n    else if (u <= 0x7FF) len += 2;\n    else if (u <= 0xFFFF) len += 3;\n    else len += 4;\n  }\n  return len;\n}\n\n\n\n// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.\n\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction AsciiToString(ptr) {\n  var str = '';\n  while (1) {\n    var ch = HEAPU8[((ptr++)>>0)];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\nfunction stringToAscii(str, outPtr) {\n  return writeAsciiToMemory(str, outPtr, false);\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\nfunction UTF16ToString(ptr) {\n  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n  var endPtr = ptr;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  var idx = endPtr >> 1;\n  while (HEAP16[idx]) ++idx;\n  endPtr = idx << 1;\n\n  if (endPtr - ptr > 32 && UTF16Decoder) {\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n  } else {\n    var i = 0;\n\n    var str = '';\n    while (1) {\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\n      if (codeUnit == 0) return str;\n      ++i;\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n      str += String.fromCharCode(codeUnit);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2; // Null terminator.\n  var startPtr = outPtr;\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    HEAP16[((outPtr)>>1)]=codeUnit;\n    outPtr += 2;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP16[((outPtr)>>1)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF16(str) {\n  return str.length*2;\n}\n\nfunction UTF32ToString(ptr) {\n  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n  var i = 0;\n\n  var str = '';\n  while (1) {\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\n    if (utf32 == 0)\n      return str;\n    ++i;\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    if (utf32 >= 0x10000) {\n      var ch = utf32 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    } else {\n      str += String.fromCharCode(utf32);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 4) return 0;\n  var startPtr = outPtr;\n  var endPtr = startPtr + maxBytesToWrite - 4;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n      var trailSurrogate = str.charCodeAt(++i);\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n    }\n    HEAP32[((outPtr)>>2)]=codeUnit;\n    outPtr += 4;\n    if (outPtr + 4 > endPtr) break;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP32[((outPtr)>>2)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF32(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i);\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n    len += 4;\n  }\n\n  return len;\n}\n\n// Allocate heap space for a JS string, and write it there.\n// It is the responsibility of the caller to free() that memory.\nfunction allocateUTF8(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = _malloc(size);\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Allocate stack space for a JS string, and write it there.\nfunction allocateUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Deprecated: This function should not be called because it is unsafe and does not provide\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\n// to be secure from out of bounds writes.\n/** @deprecated */\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\n  if (dontAddNull) {\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\n    // character that existed at the location where the null will be placed, and restore\n    // that after the write (below).\n    end = buffer + lengthBytesUTF8(string);\n    lastChar = HEAP8[end];\n  }\n  stringToUTF8(string, buffer, Infinity);\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n}\n\nfunction writeArrayToMemory(array, buffer) {\n  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')\n  HEAP8.set(array, buffer);\n}\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);\n    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);\n  }\n  // Null-terminate the pointer to the HEAP.\n  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;\n}\n\n\n\n// Memory management\n\nvar PAGE_SIZE = 16384;\nvar WASM_PAGE_SIZE = 65536;\nvar ASMJS_PAGE_SIZE = 16777216;\n\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - (x % multiple);\n  }\n  return x;\n}\n\nvar HEAP,\n/** @type {ArrayBuffer} */\n  buffer,\n/** @type {Int8Array} */\n  HEAP8,\n/** @type {Uint8Array} */\n  HEAPU8,\n/** @type {Int16Array} */\n  HEAP16,\n/** @type {Uint16Array} */\n  HEAPU16,\n/** @type {Int32Array} */\n  HEAP32,\n/** @type {Uint32Array} */\n  HEAPU32,\n/** @type {Float32Array} */\n  HEAPF32,\n/** @type {Float64Array} */\n  HEAPF64;\n\nfunction updateGlobalBufferAndViews(buf) {\n  buffer = buf;\n  Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buf);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buf);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\n}\n\nvar STATIC_BASE = 1024,\n    STACK_BASE = 5246640,\n    STACKTOP = STACK_BASE,\n    STACK_MAX = 3760,\n    DYNAMIC_BASE = 5246640,\n    DYNAMICTOP_PTR = 3600;\n\nassert(STACK_BASE % 16 === 0, 'stack must start aligned');\nassert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');\n\n\n\nvar TOTAL_STACK = 5242880;\nif (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')\n\nvar INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;if (!Object.getOwnPropertyDescriptor(Module, 'TOTAL_MEMORY')) Object.defineProperty(Module, 'TOTAL_MEMORY', { configurable: true, get: function() { abort('Module.TOTAL_MEMORY has been replaced with plain INITIAL_TOTAL_MEMORY') } });\n\nassert(INITIAL_TOTAL_MEMORY >= TOTAL_STACK, 'TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');\n\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\nassert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,\n       'JS engine does not provide full typed array support');\n\n\n\n\n\n\n// In standalone mode, the wasm creates the memory, and the user can't provide it.\n// In non-standalone/normal mode, we create the memory here.\n\n// Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm\n// memory is created in the wasm, not in JS.)\n\n  if (Module['wasmMemory']) {\n    wasmMemory = Module['wasmMemory'];\n  } else\n  {\n    wasmMemory = new WebAssembly.Memory({\n      'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE\n      ,\n      'maximum': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE\n    });\n  }\n\n\nif (wasmMemory) {\n  buffer = wasmMemory.buffer;\n}\n\n// If the user provides an incorrect length, just use that length instead rather than providing the user to\n// specifically provide the memory length with Module['TOTAL_MEMORY'].\nINITIAL_TOTAL_MEMORY = buffer.byteLength;\nassert(INITIAL_TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\nupdateGlobalBufferAndViews(buffer);\n\nHEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;\n\n\n\n\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\nfunction writeStackCookie() {\n  assert((STACK_MAX & 3) == 0);\n  // The stack grows downwards\n  HEAPU32[(STACK_MAX >> 2)+1] = 0x2135467;\n  HEAPU32[(STACK_MAX >> 2)+2] = 0x89BACDFE;\n  // Also test the global address 0 for integrity.\n  // We don't do this with ASan because ASan does its own checks for this.\n  HEAP32[0] = 0x63736d65; /* 'emsc' */\n}\n\nfunction checkStackCookie() {\n  var cookie1 = HEAPU32[(STACK_MAX >> 2)+1];\n  var cookie2 = HEAPU32[(STACK_MAX >> 2)+2];\n  if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {\n    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' ' + cookie1.toString(16));\n  }\n  // Also test the global address 0 for integrity.\n  // We don't do this with ASan because ASan does its own checks for this.\n  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n}\n\nfunction abortStackOverflow(allocSize) {\n  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');\n}\n\n\n\n\n// Endianness check (note: assumes compiler arch was little-endian)\n(function() {\n  var h16 = new Int16Array(1);\n  var h8 = new Int8Array(h16.buffer);\n  h16[0] = 0x6373;\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n})();\n\nfunction abortFnPtrError(ptr, sig) {\n\tabort(\"Invalid function pointer \" + ptr + \" called with signature '\" + sig + \"'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). Build with ASSERTIONS=2 for more info.\");\n}\n\n\n\nfunction callRuntimeCallbacks(callbacks) {\n  while(callbacks.length > 0) {\n    var callback = callbacks.shift();\n    if (typeof callback == 'function') {\n      callback();\n      continue;\n    }\n    var func = callback.func;\n    if (typeof func === 'number') {\n      if (callback.arg === undefined) {\n        Module['dynCall_v'](func);\n      } else {\n        Module['dynCall_vi'](func, callback.arg);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\n\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATMAIN__    = []; // functions called when main() is to be run\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\n\nfunction preRun() {\n\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n  checkStackCookie();\n  assert(!runtimeInitialized);\n  runtimeInitialized = true;\n  \n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  checkStackCookie();\n  \n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n  checkStackCookie();\n  runtimeExited = true;\n}\n\nfunction postRun() {\n  checkStackCookie();\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnPreMain(cb) {\n  __ATMAIN__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\nfunction unSign(value, bits, ignore) {\n  if (value >= 0) {\n    return value;\n  }\n  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n                    : Math.pow(2, bits)         + value;\n}\nfunction reSign(value, bits, ignore) {\n  if (value <= 0) {\n    return value;\n  }\n  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32\n                        : Math.pow(2, bits-1);\n  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that\n                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n                                                       // TODO: In i64 mode 1, resign the two parts separately and safely\n    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n  }\n  return value;\n}\n\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\nassert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n\nvar Math_abs = Math.abs;\nvar Math_cos = Math.cos;\nvar Math_sin = Math.sin;\nvar Math_tan = Math.tan;\nvar Math_acos = Math.acos;\nvar Math_asin = Math.asin;\nvar Math_atan = Math.atan;\nvar Math_atan2 = Math.atan2;\nvar Math_exp = Math.exp;\nvar Math_log = Math.log;\nvar Math_sqrt = Math.sqrt;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_pow = Math.pow;\nvar Math_imul = Math.imul;\nvar Math_fround = Math.fround;\nvar Math_round = Math.round;\nvar Math_min = Math.min;\nvar Math_max = Math.max;\nvar Math_clz32 = Math.clz32;\nvar Math_trunc = Math.trunc;\n\n\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(function() {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n        var shown = false;\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            err('still waiting on run dependencies:');\n          }\n          err('dependency: ' + dep);\n        }\n        if (shown) {\n          err('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    err('warning: run dependency added without ID');\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    err('warning: run dependency removed without ID');\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\nModule[\"preloadedImages\"] = {}; // maps url to image data\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\n\n\nfunction abort(what) {\n  if (Module['onAbort']) {\n    Module['onAbort'](what);\n  }\n\n  what += '';\n  out(what);\n  err(what);\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  var output = 'abort(' + what + ') at ' + stackTrace();\n  what = output;\n\n  // Throw a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  throw new WebAssembly.RuntimeError(what);\n}\n\n\nvar memoryInitializer = null;\n\n\n// show errors on likely calls to FS when it was not included\nvar FS = {\n  error: function() {\n    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n  },\n  init: function() { FS.error() },\n  createDataFile: function() { FS.error() },\n  createPreloadedFile: function() { FS.error() },\n  createLazyFile: function() { FS.error() },\n  open: function() { FS.error() },\n  mkdev: function() { FS.error() },\n  registerDevice: function() { FS.error() },\n  analyzePath: function() { FS.error() },\n  loadFilesFromDB: function() { FS.error() },\n\n  ErrnoError: function ErrnoError() { FS.error() },\n};\nModule['FS_createDataFile'] = FS.createDataFile;\nModule['FS_createPreloadedFile'] = FS.createPreloadedFile;\n\n\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n// Indicates whether filename is a base64 data URI.\nfunction isDataURI(filename) {\n  return String.prototype.startsWith ?\n      filename.startsWith(dataURIPrefix) :\n      filename.indexOf(dataURIPrefix) === 0;\n}\n\n\n\n\nvar wasmBinaryFile = 'a.out.wasm';\nif (!isDataURI(wasmBinaryFile)) {\n  wasmBinaryFile = locateFile(wasmBinaryFile);\n}\n\nfunction getBinary() {\n  try {\n    if (wasmBinary) {\n      return new Uint8Array(wasmBinary);\n    }\n\n    if (readBinary) {\n      return readBinary(wasmBinaryFile);\n    } else {\n      throw \"both async and sync fetching of the wasm failed\";\n    }\n  }\n  catch (err) {\n    abort(err);\n  }\n}\n\nfunction getBinaryPromise() {\n  // if we don't have the binary yet, and have the Fetch api, use that\n  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n    return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\n      if (!response['ok']) {\n        throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n      }\n      return response['arrayBuffer']();\n    }).catch(function () {\n      return getBinary();\n    });\n  }\n  // Otherwise, getBinary should be able to get it synchronously\n  return new Promise(function(resolve, reject) {\n    resolve(getBinary());\n  });\n}\n\n\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nfunction createWasm() {\n  // prepare imports\n  var info = {\n    'env': asmLibraryArg,\n    'wasi_snapshot_preview1': asmLibraryArg\n  };\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  /** @param {WebAssembly.Module=} module*/\n  function receiveInstance(instance, module) {\n    var exports = instance.exports;\n    Module['asm'] = exports;\n    removeRunDependency('wasm-instantiate');\n  }\n   // we can't run yet (except in a pthread, where we have a custom sync instantiator)\n  addRunDependency('wasm-instantiate');\n\n\n  // Async compilation can be confusing when an error on the page overwrites Module\n  // (for example, if the order of elements is wrong, and the one defining Module is\n  // later), so we save Module and check it later.\n  var trueModule = Module;\n  function receiveInstantiatedSource(output) {\n    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n    trueModule = null;\n      // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n      // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\n    receiveInstance(output['instance']);\n  }\n\n\n  function instantiateArrayBuffer(receiver) {\n    return getBinaryPromise().then(function(binary) {\n      return WebAssembly.instantiate(binary, info);\n    }).then(receiver, function(reason) {\n      err('failed to asynchronously prepare wasm: ' + reason);\n      abort(reason);\n    });\n  }\n\n  // Prefer streaming instantiation if available.\n  function instantiateAsync() {\n    if (!wasmBinary &&\n        typeof WebAssembly.instantiateStreaming === 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        typeof fetch === 'function') {\n      fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {\n        var result = WebAssembly.instantiateStreaming(response, info);\n        return result.then(receiveInstantiatedSource, function(reason) {\n            // We expect the most common failure cause to be a bad MIME type for the binary,\n            // in which case falling back to ArrayBuffer instantiation should work.\n            err('wasm streaming compile failed: ' + reason);\n            err('falling back to ArrayBuffer instantiation');\n            instantiateArrayBuffer(receiveInstantiatedSource);\n          });\n      });\n    } else {\n      return instantiateArrayBuffer(receiveInstantiatedSource);\n    }\n  }\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n  // to any other async startup actions they are performing.\n  if (Module['instantiateWasm']) {\n    try {\n      var exports = Module['instantiateWasm'](info, receiveInstance);\n      return exports;\n    } catch(e) {\n      err('Module.instantiateWasm callback failed with error: ' + e);\n      return false;\n    }\n  }\n\n  instantiateAsync();\n  return {}; // no exports yet; we'll fill them in later\n}\n\n\n// Globals used by JS i64 conversions\nvar tempDouble;\nvar tempI64;\n\n// === Body ===\n\nvar ASM_CONSTS = {\n  \n};\n\n\n\n\n// STATICTOP = STATIC_BASE + 2736;\n/* global initializers */  __ATINIT__.push({ func: function() { ___wasm_call_ctors() } });\n\n\n\n\n/* no memory initializer */\n// {{PRE_LIBRARY}}\n\n\n  function demangle(func) {\n      warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\n      return func;\n    }\n\n  function demangleAll(text) {\n      var regex =\n        /\\b_Z[\\w\\d_]+/g;\n      return text.replace(regex,\n        function(x) {\n          var y = demangle(x);\n          return x === y ? x : (y + ' [' + x + ']');\n        });\n    }\n\n  function jsStackTrace() {\n      var err = new Error();\n      if (!err.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n        // so try that as a special-case.\n        try {\n          throw new Error();\n        } catch(e) {\n          err = e;\n        }\n        if (!err.stack) {\n          return '(no stack trace available)';\n        }\n      }\n      return err.stack.toString();\n    }\n\n  function stackTrace() {\n      var js = jsStackTrace();\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n      return demangleAll(js);\n    }\n\n  function ___handle_stack_overflow() {\n      abort('stack overflow')\n    }\n\n  function ___lock() {}\n\n  function ___unlock() {}\n\n  function _emscripten_get_heap_size() {\n      return HEAPU8.length;\n    }\n\n  function _emscripten_get_sbrk_ptr() {\n      return 3600;\n    }\n\n  function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n    }\n\n  \n  function abortOnCannotGrowMemory(requestedSize) {\n      abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n    }function _emscripten_resize_heap(requestedSize) {\n      abortOnCannotGrowMemory(requestedSize);\n    }\n\n  \n  function flush_NO_FILESYSTEM() {\n      // flush anything remaining in the buffers during shutdown\n      if (typeof _fflush !== 'undefined') _fflush(0);\n      var buffers = SYSCALLS.buffers;\n      if (buffers[1].length) SYSCALLS.printChar(1, 10);\n      if (buffers[2].length) SYSCALLS.printChar(2, 10);\n    }\n  \n  \n  var PATH={splitPath:function(filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },normalizeArray:function(parts, allowAboveRoot) {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        // if the path is allowed to go above the root, restore leading ..s\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },normalize:function(path) {\n        var isAbsolute = path.charAt(0) === '/',\n            trailingSlash = path.substr(-1) === '/';\n        // Normalize the path\n        path = PATH.normalizeArray(path.split('/').filter(function(p) {\n          return !!p;\n        }), !isAbsolute).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },dirname:function(path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },basename:function(path) {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash+1);\n      },extname:function(path) {\n        return PATH.splitPath(path)[3];\n      },join:function() {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join('/'));\n      },join2:function(l, r) {\n        return PATH.normalize(l + '/' + r);\n      }};var SYSCALLS={buffers:[null,[],[]],printChar:function(stream, curr) {\n        var buffer = SYSCALLS.buffers[stream];\n        assert(buffer);\n        if (curr === 0 || curr === 10) {\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n          buffer.length = 0;\n        } else {\n          buffer.push(curr);\n        }\n      },varargs:0,get:function(varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\n        return ret;\n      },getStr:function() {\n        var ret = UTF8ToString(SYSCALLS.get());\n        return ret;\n      },get64:function() {\n        var low = SYSCALLS.get(), high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);\n        else assert(high === -1);\n        return low;\n      },getZero:function() {\n        assert(SYSCALLS.get() === 0);\n      }};function _fd_write(fd, iov, iovcnt, pnum) {try {\n  \n      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n      var num = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAP32[(((iov)+(i*8))>>2)];\n        var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\n        for (var j = 0; j < len; j++) {\n          SYSCALLS.printChar(fd, HEAPU8[ptr+j]);\n        }\n        num += len;\n      }\n      HEAP32[((pnum)>>2)]=num\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n  }\n\n  \n  function _memcpy(dest, src, num) {\n      dest = dest|0; src = src|0; num = num|0;\n      var ret = 0;\n      var aligned_dest_end = 0;\n      var block_aligned_dest_end = 0;\n      var dest_end = 0;\n      // Test against a benchmarked cutoff limit for when HEAPU8.set() becomes faster to use.\n      if ((num|0) >= 8192) {\n        _emscripten_memcpy_big(dest|0, src|0, num|0)|0;\n        return dest|0;\n      }\n  \n      ret = dest|0;\n      dest_end = (dest + num)|0;\n      if ((dest&3) == (src&3)) {\n        // The initial unaligned < 4-byte front.\n        while (dest & 3) {\n          if ((num|0) == 0) return ret|0;\n          HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);\n          dest = (dest+1)|0;\n          src = (src+1)|0;\n          num = (num-1)|0;\n        }\n        aligned_dest_end = (dest_end & -4)|0;\n        block_aligned_dest_end = (aligned_dest_end - 64)|0;\n        while ((dest|0) <= (block_aligned_dest_end|0) ) {\n          HEAP32[((dest)>>2)]=((HEAP32[((src)>>2)])|0);\n          HEAP32[(((dest)+(4))>>2)]=((HEAP32[(((src)+(4))>>2)])|0);\n          HEAP32[(((dest)+(8))>>2)]=((HEAP32[(((src)+(8))>>2)])|0);\n          HEAP32[(((dest)+(12))>>2)]=((HEAP32[(((src)+(12))>>2)])|0);\n          HEAP32[(((dest)+(16))>>2)]=((HEAP32[(((src)+(16))>>2)])|0);\n          HEAP32[(((dest)+(20))>>2)]=((HEAP32[(((src)+(20))>>2)])|0);\n          HEAP32[(((dest)+(24))>>2)]=((HEAP32[(((src)+(24))>>2)])|0);\n          HEAP32[(((dest)+(28))>>2)]=((HEAP32[(((src)+(28))>>2)])|0);\n          HEAP32[(((dest)+(32))>>2)]=((HEAP32[(((src)+(32))>>2)])|0);\n          HEAP32[(((dest)+(36))>>2)]=((HEAP32[(((src)+(36))>>2)])|0);\n          HEAP32[(((dest)+(40))>>2)]=((HEAP32[(((src)+(40))>>2)])|0);\n          HEAP32[(((dest)+(44))>>2)]=((HEAP32[(((src)+(44))>>2)])|0);\n          HEAP32[(((dest)+(48))>>2)]=((HEAP32[(((src)+(48))>>2)])|0);\n          HEAP32[(((dest)+(52))>>2)]=((HEAP32[(((src)+(52))>>2)])|0);\n          HEAP32[(((dest)+(56))>>2)]=((HEAP32[(((src)+(56))>>2)])|0);\n          HEAP32[(((dest)+(60))>>2)]=((HEAP32[(((src)+(60))>>2)])|0);\n          dest = (dest+64)|0;\n          src = (src+64)|0;\n        }\n        while ((dest|0) < (aligned_dest_end|0) ) {\n          HEAP32[((dest)>>2)]=((HEAP32[((src)>>2)])|0);\n          dest = (dest+4)|0;\n          src = (src+4)|0;\n        }\n      } else {\n        // In the unaligned copy case, unroll a bit as well.\n        aligned_dest_end = (dest_end - 4)|0;\n        while ((dest|0) < (aligned_dest_end|0) ) {\n          HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);\n          HEAP8[(((dest)+(1))>>0)]=((HEAP8[(((src)+(1))>>0)])|0);\n          HEAP8[(((dest)+(2))>>0)]=((HEAP8[(((src)+(2))>>0)])|0);\n          HEAP8[(((dest)+(3))>>0)]=((HEAP8[(((src)+(3))>>0)])|0);\n          dest = (dest+4)|0;\n          src = (src+4)|0;\n        }\n      }\n      // The remaining unaligned < 4 byte tail.\n      while ((dest|0) < (dest_end|0)) {\n        HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);\n        dest = (dest+1)|0;\n        src = (src+1)|0;\n      }\n      return ret|0;\n    }\n\n  function _memset(ptr, value, num) {\n      ptr = ptr|0; value = value|0; num = num|0;\n      var end = 0, aligned_end = 0, block_aligned_end = 0, value4 = 0;\n      end = (ptr + num)|0;\n  \n      value = value & 0xff;\n      if ((num|0) >= 67 /* 64 bytes for an unrolled loop + 3 bytes for unaligned head*/) {\n        while ((ptr&3) != 0) {\n          HEAP8[((ptr)>>0)]=value;\n          ptr = (ptr+1)|0;\n        }\n  \n        aligned_end = (end & -4)|0;\n        value4 = value | (value << 8) | (value << 16) | (value << 24);\n  \n        block_aligned_end = (aligned_end - 64)|0;\n  \n        while((ptr|0) <= (block_aligned_end|0)) {\n          HEAP32[((ptr)>>2)]=value4;\n          HEAP32[(((ptr)+(4))>>2)]=value4;\n          HEAP32[(((ptr)+(8))>>2)]=value4;\n          HEAP32[(((ptr)+(12))>>2)]=value4;\n          HEAP32[(((ptr)+(16))>>2)]=value4;\n          HEAP32[(((ptr)+(20))>>2)]=value4;\n          HEAP32[(((ptr)+(24))>>2)]=value4;\n          HEAP32[(((ptr)+(28))>>2)]=value4;\n          HEAP32[(((ptr)+(32))>>2)]=value4;\n          HEAP32[(((ptr)+(36))>>2)]=value4;\n          HEAP32[(((ptr)+(40))>>2)]=value4;\n          HEAP32[(((ptr)+(44))>>2)]=value4;\n          HEAP32[(((ptr)+(48))>>2)]=value4;\n          HEAP32[(((ptr)+(52))>>2)]=value4;\n          HEAP32[(((ptr)+(56))>>2)]=value4;\n          HEAP32[(((ptr)+(60))>>2)]=value4;\n          ptr = (ptr + 64)|0;\n        }\n  \n        while ((ptr|0) < (aligned_end|0) ) {\n          HEAP32[((ptr)>>2)]=value4;\n          ptr = (ptr+4)|0;\n        }\n      }\n      // The remaining bytes.\n      while ((ptr|0) < (end|0)) {\n        HEAP8[((ptr)>>0)]=value;\n        ptr = (ptr+1)|0;\n      }\n      return (end-num)|0;\n    }\n\n  function _setTempRet0($i) {\n      setTempRet0(($i) | 0);\n    }\nvar ASSERTIONS = true;\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n/** @type {function(string, boolean=, number=)} */\nfunction intArrayFromString(stringy, dontAddNull, length) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\n\nfunction intArrayToString(array) {\n  var ret = [];\n  for (var i = 0; i < array.length; i++) {\n    var chr = array[i];\n    if (chr > 0xFF) {\n      if (ASSERTIONS) {\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n      }\n      chr &= 0xFF;\n    }\n    ret.push(String.fromCharCode(chr));\n  }\n  return ret.join('');\n}\n\n\n// ASM_LIBRARY EXTERN PRIMITIVES: Int8Array,Int32Array\n\nvar asmGlobalArg = {};\nvar asmLibraryArg = { \"__handle_stack_overflow\": ___handle_stack_overflow, \"__lock\": ___lock, \"__unlock\": ___unlock, \"emscripten_get_sbrk_ptr\": _emscripten_get_sbrk_ptr, \"emscripten_memcpy_big\": _emscripten_memcpy_big, \"emscripten_resize_heap\": _emscripten_resize_heap, \"fd_write\": _fd_write, \"memory\": wasmMemory, \"setTempRet0\": _setTempRet0, \"table\": wasmTable };\nvar asm = createWasm();\nModule[\"asm\"] = asm;\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__wasm_call_ctors\"].apply(null, arguments)\n};\n\nvar _main = Module[\"_main\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"main\"].apply(null, arguments)\n};\n\nvar ___errno_location = Module[\"___errno_location\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__errno_location\"].apply(null, arguments)\n};\n\nvar _fflush = Module[\"_fflush\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"fflush\"].apply(null, arguments)\n};\n\nvar _setThrew = Module[\"_setThrew\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"setThrew\"].apply(null, arguments)\n};\n\nvar _malloc = Module[\"_malloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"malloc\"].apply(null, arguments)\n};\n\nvar _free = Module[\"_free\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"free\"].apply(null, arguments)\n};\n\nvar ___set_stack_limit = Module[\"___set_stack_limit\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__set_stack_limit\"].apply(null, arguments)\n};\n\nvar stackSave = Module[\"stackSave\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackSave\"].apply(null, arguments)\n};\n\nvar stackAlloc = Module[\"stackAlloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments)\n};\n\nvar stackRestore = Module[\"stackRestore\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackRestore\"].apply(null, arguments)\n};\n\nvar __growWasmMemory = Module[\"__growWasmMemory\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__growWasmMemory\"].apply(null, arguments)\n};\n\nvar dynCall_ii = Module[\"dynCall_ii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments)\n};\n\nvar dynCall_iiii = Module[\"dynCall_iiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments)\n};\n\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_jiji\"].apply(null, arguments)\n};\n\nvar dynCall_iidiiii = Module[\"dynCall_iidiiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_iidiiii\"].apply(null, arguments)\n};\n\nvar dynCall_vii = Module[\"dynCall_vii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_vii\"].apply(null, arguments)\n};\n\n\n\n\n// === Auto-generated postamble setup entry stuff ===\n\nModule['asm'] = asm;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"intArrayFromString\")) Module[\"intArrayFromString\"] = function() { abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"intArrayToString\")) Module[\"intArrayToString\"] = function() { abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"ccall\")) Module[\"ccall\"] = function() { abort(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"cwrap\")) Module[\"cwrap\"] = function() { abort(\"'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"setValue\")) Module[\"setValue\"] = function() { abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getValue\")) Module[\"getValue\"] = function() { abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"allocate\")) Module[\"allocate\"] = function() { abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getMemory\")) Module[\"getMemory\"] = function() { abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF8ArrayToString\")) Module[\"UTF8ArrayToString\"] = function() { abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF8ToString\")) Module[\"UTF8ToString\"] = function() { abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8Array\")) Module[\"stringToUTF8Array\"] = function() { abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8\")) Module[\"stringToUTF8\"] = function() { abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF8\")) Module[\"lengthBytesUTF8\"] = function() { abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function() { abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPreRun\")) Module[\"addOnPreRun\"] = function() { abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnInit\")) Module[\"addOnInit\"] = function() { abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPreMain\")) Module[\"addOnPreMain\"] = function() { abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnExit\")) Module[\"addOnExit\"] = function() { abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPostRun\")) Module[\"addOnPostRun\"] = function() { abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeStringToMemory\")) Module[\"writeStringToMemory\"] = function() { abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeArrayToMemory\")) Module[\"writeArrayToMemory\"] = function() { abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeAsciiToMemory\")) Module[\"writeAsciiToMemory\"] = function() { abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addRunDependency\")) Module[\"addRunDependency\"] = function() { abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"removeRunDependency\")) Module[\"removeRunDependency\"] = function() { abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createFolder\")) Module[\"FS_createFolder\"] = function() { abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createPath\")) Module[\"FS_createPath\"] = function() { abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createDataFile\")) Module[\"FS_createDataFile\"] = function() { abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createPreloadedFile\")) Module[\"FS_createPreloadedFile\"] = function() { abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createLazyFile\")) Module[\"FS_createLazyFile\"] = function() { abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createLink\")) Module[\"FS_createLink\"] = function() { abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createDevice\")) Module[\"FS_createDevice\"] = function() { abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_unlink\")) Module[\"FS_unlink\"] = function() { abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"dynamicAlloc\")) Module[\"dynamicAlloc\"] = function() { abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"loadDynamicLibrary\")) Module[\"loadDynamicLibrary\"] = function() { abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"loadWebAssemblyModule\")) Module[\"loadWebAssemblyModule\"] = function() { abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getLEB\")) Module[\"getLEB\"] = function() { abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getFunctionTables\")) Module[\"getFunctionTables\"] = function() { abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"alignFunctionTables\")) Module[\"alignFunctionTables\"] = function() { abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"registerFunctions\")) Module[\"registerFunctions\"] = function() { abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addFunction\")) Module[\"addFunction\"] = function() { abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"removeFunction\")) Module[\"removeFunction\"] = function() { abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = function() { abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"prettyPrint\")) Module[\"prettyPrint\"] = function() { abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"makeBigInt\")) Module[\"makeBigInt\"] = function() { abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = function() { abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getCompilerSetting\")) Module[\"getCompilerSetting\"] = function() { abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"print\")) Module[\"print\"] = function() { abort(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"printErr\")) Module[\"printErr\"] = function() { abort(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getTempRet0\")) Module[\"getTempRet0\"] = function() { abort(\"'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"setTempRet0\")) Module[\"setTempRet0\"] = function() { abort(\"'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"callMain\")) Module[\"callMain\"] = function() { abort(\"'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"abort\")) Module[\"abort\"] = function() { abort(\"'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PROCINFO\")) Module[\"PROCINFO\"] = function() { abort(\"'PROCINFO' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToNewUTF8\")) Module[\"stringToNewUTF8\"] = function() { abort(\"'stringToNewUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"abortOnCannotGrowMemory\")) Module[\"abortOnCannotGrowMemory\"] = function() { abort(\"'abortOnCannotGrowMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscripten_realloc_buffer\")) Module[\"emscripten_realloc_buffer\"] = function() { abort(\"'emscripten_realloc_buffer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"ENV\")) Module[\"ENV\"] = function() { abort(\"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"setjmpId\")) Module[\"setjmpId\"] = function() { abort(\"'setjmpId' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_CODES\")) Module[\"ERRNO_CODES\"] = function() { abort(\"'ERRNO_CODES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_MESSAGES\")) Module[\"ERRNO_MESSAGES\"] = function() { abort(\"'ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"DNS__deps\")) Module[\"DNS__deps\"] = function() { abort(\"'DNS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"DNS\")) Module[\"DNS\"] = function() { abort(\"'DNS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GAI_ERRNO_MESSAGES\")) Module[\"GAI_ERRNO_MESSAGES\"] = function() { abort(\"'GAI_ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Protocols\")) Module[\"Protocols\"] = function() { abort(\"'Protocols' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Sockets__deps\")) Module[\"Sockets__deps\"] = function() { abort(\"'Sockets__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Sockets\")) Module[\"Sockets\"] = function() { abort(\"'Sockets' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UNWIND_CACHE\")) Module[\"UNWIND_CACHE\"] = function() { abort(\"'UNWIND_CACHE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"readAsmConstArgs\")) Module[\"readAsmConstArgs\"] = function() { abort(\"'readAsmConstArgs' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PATH\")) Module[\"PATH\"] = function() { abort(\"'PATH' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PATH_FS__deps\")) Module[\"PATH_FS__deps\"] = function() { abort(\"'PATH_FS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PATH_FS\")) Module[\"PATH_FS\"] = function() { abort(\"'PATH_FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SYSCALLS__deps\")) Module[\"SYSCALLS__deps\"] = function() { abort(\"'SYSCALLS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SYSCALLS\")) Module[\"SYSCALLS\"] = function() { abort(\"'SYSCALLS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"flush_NO_FILESYSTEM\")) Module[\"flush_NO_FILESYSTEM\"] = function() { abort(\"'flush_NO_FILESYSTEM' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"JSEvents\")) Module[\"JSEvents\"] = function() { abort(\"'JSEvents' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"demangle__deps\")) Module[\"demangle__deps\"] = function() { abort(\"'demangle__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"demangle\")) Module[\"demangle\"] = function() { abort(\"'demangle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"demangleAll\")) Module[\"demangleAll\"] = function() { abort(\"'demangleAll' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"jsStackTrace\")) Module[\"jsStackTrace\"] = function() { abort(\"'jsStackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function() { abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64__deps\")) Module[\"writeI53ToI64__deps\"] = function() { abort(\"'writeI53ToI64__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64\")) Module[\"writeI53ToI64\"] = function() { abort(\"'writeI53ToI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Clamped\")) Module[\"writeI53ToI64Clamped\"] = function() { abort(\"'writeI53ToI64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Signaling\")) Module[\"writeI53ToI64Signaling\"] = function() { abort(\"'writeI53ToI64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Clamped\")) Module[\"writeI53ToU64Clamped\"] = function() { abort(\"'writeI53ToU64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Signaling\")) Module[\"writeI53ToU64Signaling\"] = function() { abort(\"'writeI53ToU64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"readI53FromI64\")) Module[\"readI53FromI64\"] = function() { abort(\"'readI53FromI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"readI53FromU64\")) Module[\"readI53FromU64\"] = function() { abort(\"'readI53FromU64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"convertI32PairToI53\")) Module[\"convertI32PairToI53\"] = function() { abort(\"'convertI32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"convertU32PairToI53\")) Module[\"convertU32PairToI53\"] = function() { abort(\"'convertU32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Browser__deps\")) Module[\"Browser__deps\"] = function() { abort(\"'Browser__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Browser__postset\")) Module[\"Browser__postset\"] = function() { abort(\"'Browser__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Browser\")) Module[\"Browser\"] = function() { abort(\"'Browser' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Browser__postset__deps\")) Module[\"Browser__postset__deps\"] = function() { abort(\"'Browser__postset__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS__deps\")) Module[\"FS__deps\"] = function() { abort(\"'FS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS__postset\")) Module[\"FS__postset\"] = function() { abort(\"'FS__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS\")) Module[\"FS\"] = function() { abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"MEMFS__deps\")) Module[\"MEMFS__deps\"] = function() { abort(\"'MEMFS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"MEMFS\")) Module[\"MEMFS\"] = function() { abort(\"'MEMFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"TTY__deps\")) Module[\"TTY__deps\"] = function() { abort(\"'TTY__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"TTY__postset\")) Module[\"TTY__postset\"] = function() { abort(\"'TTY__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"TTY\")) Module[\"TTY\"] = function() { abort(\"'TTY' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PIPEFS__postset\")) Module[\"PIPEFS__postset\"] = function() { abort(\"'PIPEFS__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PIPEFS__deps\")) Module[\"PIPEFS__deps\"] = function() { abort(\"'PIPEFS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PIPEFS\")) Module[\"PIPEFS\"] = function() { abort(\"'PIPEFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SOCKFS__postset\")) Module[\"SOCKFS__postset\"] = function() { abort(\"'SOCKFS__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SOCKFS__deps\")) Module[\"SOCKFS__deps\"] = function() { abort(\"'SOCKFS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SOCKFS\")) Module[\"SOCKFS\"] = function() { abort(\"'SOCKFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GL__postset\")) Module[\"GL__postset\"] = function() { abort(\"'GL__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GL__deps\")) Module[\"GL__deps\"] = function() { abort(\"'GL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GL\")) Module[\"GL\"] = function() { abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet__deps\")) Module[\"emscriptenWebGLGet__deps\"] = function() { abort(\"'emscriptenWebGLGet__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet\")) Module[\"emscriptenWebGLGet\"] = function() { abort(\"'emscriptenWebGLGet' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData__deps\")) Module[\"emscriptenWebGLGetTexPixelData__deps\"] = function() { abort(\"'emscriptenWebGLGetTexPixelData__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData\")) Module[\"emscriptenWebGLGetTexPixelData\"] = function() { abort(\"'emscriptenWebGLGetTexPixelData' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform\")) Module[\"emscriptenWebGLGetUniform\"] = function() { abort(\"'emscriptenWebGLGetUniform' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib\")) Module[\"emscriptenWebGLGetVertexAttrib\"] = function() { abort(\"'emscriptenWebGLGetVertexAttrib' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GL__postset__deps\")) Module[\"GL__postset__deps\"] = function() { abort(\"'GL__postset__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform__deps\")) Module[\"emscriptenWebGLGetUniform__deps\"] = function() { abort(\"'emscriptenWebGLGetUniform__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib__deps\")) Module[\"emscriptenWebGLGetVertexAttrib__deps\"] = function() { abort(\"'emscriptenWebGLGetVertexAttrib__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"AL__deps\")) Module[\"AL__deps\"] = function() { abort(\"'AL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"AL\")) Module[\"AL\"] = function() { abort(\"'AL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"WebVR\")) Module[\"WebVR\"] = function() { abort(\"'WebVR' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"WebVR__deps\")) Module[\"WebVR__deps\"] = function() { abort(\"'WebVR__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL__deps\")) Module[\"SDL__deps\"] = function() { abort(\"'SDL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL\")) Module[\"SDL\"] = function() { abort(\"'SDL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_gfx\")) Module[\"SDL_gfx\"] = function() { abort(\"'SDL_gfx' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_gfx__deps\")) Module[\"SDL_gfx__deps\"] = function() { abort(\"'SDL_gfx__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GLUT__deps\")) Module[\"GLUT__deps\"] = function() { abort(\"'GLUT__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GLUT\")) Module[\"GLUT\"] = function() { abort(\"'GLUT' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"EGL__deps\")) Module[\"EGL__deps\"] = function() { abort(\"'EGL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"EGL\")) Module[\"EGL\"] = function() { abort(\"'EGL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GLFW__deps\")) Module[\"GLFW__deps\"] = function() { abort(\"'GLFW__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GLFW\")) Module[\"GLFW\"] = function() { abort(\"'GLFW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GLEW__deps\")) Module[\"GLEW__deps\"] = function() { abort(\"'GLEW__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GLEW\")) Module[\"GLEW\"] = function() { abort(\"'GLEW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"IDBStore\")) Module[\"IDBStore\"] = function() { abort(\"'IDBStore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"IDBStore__deps\")) Module[\"IDBStore__deps\"] = function() { abort(\"'IDBStore__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"runAndAbortIfError\")) Module[\"runAndAbortIfError\"] = function() { abort(\"'runAndAbortIfError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"warnOnce\")) Module[\"warnOnce\"] = function() { abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackSave\")) Module[\"stackSave\"] = function() { abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackRestore\")) Module[\"stackRestore\"] = function() { abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackAlloc\")) Module[\"stackAlloc\"] = function() { abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"AsciiToString\")) Module[\"AsciiToString\"] = function() { abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToAscii\")) Module[\"stringToAscii\"] = function() { abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF16ToString\")) Module[\"UTF16ToString\"] = function() { abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF16\")) Module[\"stringToUTF16\"] = function() { abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF16\")) Module[\"lengthBytesUTF16\"] = function() { abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF32ToString\")) Module[\"UTF32ToString\"] = function() { abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF32\")) Module[\"stringToUTF32\"] = function() { abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF32\")) Module[\"lengthBytesUTF32\"] = function() { abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8\")) Module[\"allocateUTF8\"] = function() { abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8OnStack\")) Module[\"allocateUTF8OnStack\"] = function() { abort(\"'allocateUTF8OnStack' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nModule[\"writeStackCookie\"] = writeStackCookie;\nModule[\"checkStackCookie\"] = checkStackCookie;\nModule[\"abortStackOverflow\"] = abortStackOverflow;if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NORMAL\")) Object.defineProperty(Module, \"ALLOC_NORMAL\", { configurable: true, get: function() { abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_STACK\")) Object.defineProperty(Module, \"ALLOC_STACK\", { configurable: true, get: function() { abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_DYNAMIC\")) Object.defineProperty(Module, \"ALLOC_DYNAMIC\", { configurable: true, get: function() { abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NONE\")) Object.defineProperty(Module, \"ALLOC_NONE\", { configurable: true, get: function() { abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Object.getOwnPropertyDescriptor(Module, \"calledRun\")) Object.defineProperty(Module, \"calledRun\", { configurable: true, get: function() { abort(\"'calledRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") } });\n\n\n\nvar calledRun;\n\n\n/**\n * @constructor\n * @this {ExitStatus}\n */\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\" + status + \")\";\n  this.status = status;\n}\n\nvar calledMain = false;\n\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n};\n\nfunction callMain(args) {\n  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])');\n  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');\n\n  var entryFunction = Module['_main'];\n\n\n  args = args || [];\n\n  var argc = args.length+1;\n  var argv = stackAlloc((argc + 1) * 4);\n  HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);\n  for (var i = 1; i < argc; i++) {\n    HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);\n  }\n  HEAP32[(argv >> 2) + argc] = 0;\n\n\n  try {\n\n    Module['___set_stack_limit'](STACK_MAX);\n\n    var ret = entryFunction(argc, argv);\n\n\n    // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as execution is asynchronously handed\n    // off to a pthread.\n    // if we're not running an evented main loop, it's time to exit\n      exit(ret, /* implicit = */ true);\n  }\n  catch(e) {\n    if (e instanceof ExitStatus) {\n      // exit() throws this once it's done to make sure execution\n      // has been stopped completely\n      return;\n    } else if (e == 'unwind') {\n      // running an evented main loop, don't immediately exit\n      noExitRuntime = true;\n      return;\n    } else {\n      var toLog = e;\n      if (e && typeof e === 'object' && e.stack) {\n        toLog = [e, e.stack];\n      }\n      err('exception thrown: ' + toLog);\n      quit_(1, e);\n    }\n  } finally {\n    calledMain = true;\n  }\n}\n\n\n\n\n/** @type {function(Array=)} */\nfunction run(args) {\n  args = args || arguments_;\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n  writeStackCookie();\n\n  preRun();\n\n  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    if (calledRun) return;\n    calledRun = true;\n\n    if (ABORT) return;\n\n    initRuntime();\n\n    preMain();\n\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n\n    if (shouldRunNow) callMain(args);\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else\n  {\n    doRun();\n  }\n  checkStackCookie();\n}\nModule['run'] = run;\n\nfunction checkUnflushedContent() {\n  // Compiler settings do not allow exiting the runtime, so flushing\n  // the streams is not possible. but in ASSERTIONS mode we check\n  // if there was something to flush, and if so tell the user they\n  // should request that the runtime be exitable.\n  // Normally we would not even include flush() at all, but in ASSERTIONS\n  // builds we do so just for this check, and here we see if there is any\n  // content to flush, that is, we check if there would have been\n  // something a non-ASSERTIONS build would have not seen.\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n  // mode (which has its own special function for this; otherwise, all\n  // the code is inside libc)\n  var print = out;\n  var printErr = err;\n  var has = false;\n  out = err = function(x) {\n    has = true;\n  }\n  try { // it doesn't matter if it fails\n    var flush = flush_NO_FILESYSTEM;\n    if (flush) flush(0);\n  } catch(e) {}\n  out = print;\n  err = printErr;\n  if (has) {\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');\n    warnOnce('(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)');\n  }\n}\n\nfunction exit(status, implicit) {\n  checkUnflushedContent();\n\n  // if this is just main exit-ing implicitly, and the status is 0, then we\n  // don't need to do anything here and can just leave. if the status is\n  // non-zero, though, then we need to report it.\n  // (we may have warned about this earlier, if a situation justifies doing so)\n  if (implicit && noExitRuntime && status === 0) {\n    return;\n  }\n\n  if (noExitRuntime) {\n    // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n    if (!implicit) {\n      err('program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');\n    }\n  } else {\n\n    ABORT = true;\n    EXITSTATUS = status;\n\n    exitRuntime();\n\n    if (Module['onExit']) Module['onExit'](status);\n  }\n\n  quit_(status, new ExitStatus(status));\n}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\n// shouldRunNow refers to calling main(), not run().\nvar shouldRunNow = true;\n\nif (Module['noInitialRun']) shouldRunNow = false;\n\n\n  noExitRuntime = true;\n\nrun();\n\n\n\n\n\n// {{MODULE_ADDITIONS}}\n\n\n\n"]},"metadata":{},"sourceType":"script"}