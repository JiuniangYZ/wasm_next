{"ast":null,"code":"var _Promise = require(\"@babel/runtime-corejs2/core-js/promise\");\n\nvar _parseInt = require(\"@babel/runtime-corejs2/core-js/parse-int\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n\nvar Module = function () {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n\n  return function (Module) {\n    Module = Module || {}; // Copyright 2010 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n    // The Module object: Our interface to the outside world. We import\n    // and export values on it. There are various ways Module can be used:\n    // 1. Not defined. We create it here\n    // 2. A function parameter, function(Module) { ..generated code.. }\n    // 3. pre-run appended it, var Module = {}; ..generated code..\n    // 4. External script tag defines var Module.\n    // We need to check if Module already exists (e.g. case 3 above).\n    // Substitution will be replaced with actual code on later stage of the build,\n    // this way Closure Compiler will not mangle it (e.g. case 4. above).\n    // Note that if you want to run closure, and also to use Module\n    // after the generated code, you will need to define   var Module = {};\n    // before the code. Then that object will be used in the code, and you\n    // can continue to use Module afterwards as well.\n\n    var Module = typeof Module !== 'undefined' ? Module : {}; // --pre-jses are emitted after the Module integration code, so that they can\n    // refer to Module (if they choose; they can also define Module)\n    // {{PRE_JSES}}\n    // Sometimes an existing Module object exists with properties\n    // meant to overwrite the default module functionality. Here\n    // we collect those properties and reapply _after_ we configure\n    // the current environment's defaults to avoid having to be so\n    // defensive during initialization.\n\n    var moduleOverrides = {};\n    var key;\n\n    for (key in Module) {\n      if (Module.hasOwnProperty(key)) {\n        moduleOverrides[key] = Module[key];\n      }\n    }\n\n    var arguments_ = [];\n    var thisProgram = './this.program';\n\n    var quit_ = function quit_(status, toThrow) {\n      throw toThrow;\n    }; // Determine the runtime environment we are in. You can customize this by\n    // setting the ENVIRONMENT setting at compile time (see settings.js).\n\n\n    var ENVIRONMENT_IS_WEB = true;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n\n    if (Module['ENVIRONMENT']) {\n      throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');\n    } // `/` should be present at the end if `scriptDirectory` is not empty\n\n\n    var scriptDirectory = '';\n\n    function locateFile(path) {\n      if (Module['locateFile']) {\n        return Module['locateFile'](path, scriptDirectory);\n      }\n\n      return scriptDirectory + path;\n    } // Hooks that are implemented differently in different runtime environments.\n\n\n    var read_, readAsync, readBinary, setWindowTitle; // Note that this includes Node.js workers when relevant (pthreads is enabled).\n    // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n    // ENVIRONMENT_IS_NODE.\n\n    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        // Check worker, not web, since window could be polyfilled\n        scriptDirectory = self.location.href;\n      } else if (document.currentScript) {\n        // web\n        scriptDirectory = document.currentScript.src;\n      } // When MODULARIZE (and not _INSTANCE), this JS may be executed later, after document.currentScript\n      // is gone, so we saved it, and we use it here instead of any other info.\n\n\n      if (_scriptDir) {\n        scriptDirectory = _scriptDir;\n      } // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n      // otherwise, slice off the final part of the url to find the script directory.\n      // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n      // and scriptDirectory will correctly be replaced with an empty string.\n\n\n      if (scriptDirectory.indexOf('blob:') !== 0) {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/') + 1);\n      } else {\n        scriptDirectory = '';\n      }\n\n      if (!(true || typeof importScripts === 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)'); // Differentiate the Web Worker from the Node Worker case, as reading must\n      // be done differently.\n\n      {\n        read_ = function shell_read(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, false);\n          xhr.send(null);\n          return xhr.responseText;\n        };\n\n        if (ENVIRONMENT_IS_WORKER) {\n          readBinary = function readBinary(url) {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', url, false);\n            xhr.responseType = 'arraybuffer';\n            xhr.send(null);\n            return new Uint8Array(xhr.response);\n          };\n        }\n\n        readAsync = function readAsync(url, onload, onerror) {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, true);\n          xhr.responseType = 'arraybuffer';\n\n          xhr.onload = function xhr_onload() {\n            if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n              // file URLs can return 0\n              onload(xhr.response);\n              return;\n            }\n\n            onerror();\n          };\n\n          xhr.onerror = onerror;\n          xhr.send(null);\n        };\n      }\n\n      setWindowTitle = function setWindowTitle(title) {\n        document.title = title;\n      };\n    } else {\n      throw new Error('environment detection error');\n    } // Set up the out() and err() hooks, which are how we can print to stdout or\n    // stderr, respectively.\n\n\n    var out = Module['print'] || console.log.bind(console);\n    var err = Module['printErr'] || console.warn.bind(console); // Merge back in the overrides\n\n    for (key in moduleOverrides) {\n      if (moduleOverrides.hasOwnProperty(key)) {\n        Module[key] = moduleOverrides[key];\n      }\n    } // Free the object hierarchy contained in the overrides, this lets the GC\n    // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n\n\n    moduleOverrides = null; // Emit code to handle expected values on the Module object. This applies Module.x\n    // to the proper local x. This has two benefits: first, we only emit it if it is\n    // expected to arrive, and second, by using a local everywhere else that can be\n    // minified.\n\n    if (Module['arguments']) arguments_ = Module['arguments'];\n    if (!_Object$getOwnPropertyDescriptor(Module, 'arguments')) _Object$defineProperty(Module, 'arguments', {\n      configurable: true,\n      get: function get() {\n        abort('Module.arguments has been replaced with plain arguments_');\n      }\n    });\n    if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n    if (!_Object$getOwnPropertyDescriptor(Module, 'thisProgram')) _Object$defineProperty(Module, 'thisProgram', {\n      configurable: true,\n      get: function get() {\n        abort('Module.thisProgram has been replaced with plain thisProgram');\n      }\n    });\n    if (Module['quit']) quit_ = Module['quit'];\n    if (!_Object$getOwnPropertyDescriptor(Module, 'quit')) _Object$defineProperty(Module, 'quit', {\n      configurable: true,\n      get: function get() {\n        abort('Module.quit has been replaced with plain quit_');\n      }\n    }); // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n    // Assertions on removed incoming Module JS APIs.\n\n    assert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\n    assert(typeof Module['read'] === 'undefined', 'Module.read option was removed (modify read_ in JS)');\n    assert(typeof Module['readAsync'] === 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\n    assert(typeof Module['readBinary'] === 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\n    assert(typeof Module['setWindowTitle'] === 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');\n    if (!_Object$getOwnPropertyDescriptor(Module, 'read')) _Object$defineProperty(Module, 'read', {\n      configurable: true,\n      get: function get() {\n        abort('Module.read has been replaced with plain read_');\n      }\n    });\n    if (!_Object$getOwnPropertyDescriptor(Module, 'readAsync')) _Object$defineProperty(Module, 'readAsync', {\n      configurable: true,\n      get: function get() {\n        abort('Module.readAsync has been replaced with plain readAsync');\n      }\n    });\n    if (!_Object$getOwnPropertyDescriptor(Module, 'readBinary')) _Object$defineProperty(Module, 'readBinary', {\n      configurable: true,\n      get: function get() {\n        abort('Module.readBinary has been replaced with plain readBinary');\n      }\n    }); // TODO: add when SDL2 is fixed if (!Object.getOwnPropertyDescriptor(Module, 'setWindowTitle')) Object.defineProperty(Module, 'setWindowTitle', { configurable: true, get: function() { abort('Module.setWindowTitle has been replaced with plain setWindowTitle') } });\n\n    var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\n    var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\n    var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\n    var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js'; // TODO remove when SDL2 is fixed (also see above)\n    // Copyright 2017 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n    // {{PREAMBLE_ADDITIONS}}\n\n    var STACK_ALIGN = 16; // stack management, and other functionality that is provided by the compiled code,\n    // should not be used before it is ready\n\n    stackSave = stackRestore = stackAlloc = function stackAlloc() {\n      abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n    };\n\n    function staticAlloc(size) {\n      abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');\n    }\n\n    function dynamicAlloc(size) {\n      assert(DYNAMICTOP_PTR);\n      var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n      var end = ret + size + 15 & -16;\n\n      if (end > _emscripten_get_heap_size()) {\n        abort('failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly');\n      }\n\n      HEAP32[DYNAMICTOP_PTR >> 2] = end;\n      return ret;\n    }\n\n    function alignMemory(size, factor) {\n      if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n\n      return Math.ceil(size / factor) * factor;\n    }\n\n    function getNativeTypeSize(type) {\n      switch (type) {\n        case 'i1':\n        case 'i8':\n          return 1;\n\n        case 'i16':\n          return 2;\n\n        case 'i32':\n          return 4;\n\n        case 'i64':\n          return 8;\n\n        case 'float':\n          return 4;\n\n        case 'double':\n          return 8;\n\n        default:\n          {\n            if (type[type.length - 1] === '*') {\n              return 4; // A pointer\n            } else if (type[0] === 'i') {\n              var bits = _parseInt(type.substr(1));\n\n              assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\n              return bits / 8;\n            } else {\n              return 0;\n            }\n          }\n      }\n    }\n\n    function warnOnce(text) {\n      if (!warnOnce.shown) warnOnce.shown = {};\n\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        err(text);\n      }\n    } // Wraps a JS function as a wasm function with a given signature.\n\n\n    function convertJsFunctionToWasm(func, sig) {\n      // If the type reflection proposal is available, use the new\n      // \"WebAssembly.Function\" constructor.\n      // Otherwise, construct a minimal wasm module importing the JS function and\n      // re-exporting it.\n      if (typeof WebAssembly.Function === \"function\") {\n        var typeNames = {\n          'i': 'i32',\n          'j': 'i64',\n          'f': 'f32',\n          'd': 'f64'\n        };\n        var type = {\n          parameters: [],\n          results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\n        };\n\n        for (var i = 1; i < sig.length; ++i) {\n          type.parameters.push(typeNames[sig[i]]);\n        }\n\n        return new WebAssembly.Function(type, func);\n      } // The module is static, with the exception of the type section, which is\n      // generated based on the signature passed in.\n\n\n      var typeSection = [0x01, // id: section,\n      0x00, // length: 0 (placeholder)\n      0x01, // count: 1\n      0x60 // form: func\n      ];\n      var sigRet = sig.slice(0, 1);\n      var sigParam = sig.slice(1);\n      var typeCodes = {\n        'i': 0x7f,\n        // i32\n        'j': 0x7e,\n        // i64\n        'f': 0x7d,\n        // f32\n        'd': 0x7c // f64\n\n      }; // Parameters, length + signatures\n\n      typeSection.push(sigParam.length);\n\n      for (var i = 0; i < sigParam.length; ++i) {\n        typeSection.push(typeCodes[sigParam[i]]);\n      } // Return values, length + signatures\n      // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n\n\n      if (sigRet == 'v') {\n        typeSection.push(0x00);\n      } else {\n        typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\n      } // Write the overall length of the type section back into the section header\n      // (excepting the 2 bytes for the section id and length)\n\n\n      typeSection[1] = typeSection.length - 2; // Rest of the module is static\n\n      var bytes = new Uint8Array([0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\n      0x01, 0x00, 0x00, 0x00 // version: 1\n      ].concat(typeSection, [0x02, 0x07, // import section\n      // (import \"e\" \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00, 0x07, 0x05, // export section\n      // (export \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x66, 0x00, 0x00])); // We can compile this wasm module synchronously because it is very small.\n      // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n\n      var module = new WebAssembly.Module(bytes);\n      var instance = new WebAssembly.Instance(module, {\n        'e': {\n          'f': func\n        }\n      });\n      var wrappedFunc = instance.exports['f'];\n      return wrappedFunc;\n    } // Add a wasm function to the table.\n\n\n    function addFunctionWasm(func, sig) {\n      var table = wasmTable;\n      var ret = table.length; // Grow the table\n\n      try {\n        table.grow(1);\n      } catch (err) {\n        if (!(err instanceof RangeError)) {\n          throw err;\n        }\n\n        throw 'Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.';\n      } // Insert new element\n\n\n      try {\n        // Attempting to call this with JS function will cause of table.set() to fail\n        table.set(ret, func);\n      } catch (err) {\n        if (!(err instanceof TypeError)) {\n          throw err;\n        }\n\n        assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');\n        var wrapped = convertJsFunctionToWasm(func, sig);\n        table.set(ret, wrapped);\n      }\n\n      return ret;\n    }\n\n    function removeFunctionWasm(index) {} // TODO(sbc): Look into implementing this to allow re-using of table slots\n    // 'sig' parameter is required for the llvm backend but only when func is not\n    // already a WebAssembly function.\n\n\n    function addFunction(func, sig) {\n      assert(typeof func !== 'undefined');\n      return addFunctionWasm(func, sig);\n    }\n\n    function removeFunction(index) {\n      removeFunctionWasm(index);\n    }\n\n    var funcWrappers = {};\n\n    function getFuncWrapper(func, sig) {\n      if (!func) return; // on null pointer, return undefined\n\n      assert(sig);\n\n      if (!funcWrappers[sig]) {\n        funcWrappers[sig] = {};\n      }\n\n      var sigCache = funcWrappers[sig];\n\n      if (!sigCache[func]) {\n        // optimize away arguments usage in common cases\n        if (sig.length === 1) {\n          sigCache[func] = function dynCall_wrapper() {\n            return dynCall(sig, func);\n          };\n        } else if (sig.length === 2) {\n          sigCache[func] = function dynCall_wrapper(arg) {\n            return dynCall(sig, func, [arg]);\n          };\n        } else {\n          // general case\n          sigCache[func] = function dynCall_wrapper() {\n            return dynCall(sig, func, Array.prototype.slice.call(arguments));\n          };\n        }\n      }\n\n      return sigCache[func];\n    }\n\n    function makeBigInt(low, high, unsigned) {\n      return unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296.0 : +(low >>> 0) + +(high | 0) * 4294967296.0;\n    }\n\n    function dynCall(sig, ptr, args) {\n      if (args && args.length) {\n        // j (64-bit integer) must be passed in as two numbers [low 32, high 32].\n        assert(args.length === sig.substring(1).replace(/j/g, '--').length);\n        assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n        return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n      } else {\n        assert(sig.length == 1);\n        assert('dynCall_' + sig in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n        return Module['dynCall_' + sig].call(null, ptr);\n      }\n    }\n\n    var tempRet0 = 0;\n\n    var setTempRet0 = function setTempRet0(value) {\n      tempRet0 = value;\n    };\n\n    var getTempRet0 = function getTempRet0() {\n      return tempRet0;\n    };\n\n    function getCompilerSetting(name) {\n      throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n    }\n\n    var Runtime = {\n      // helpful errors\n      getTempRet0: function getTempRet0() {\n        abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      },\n      staticAlloc: function staticAlloc() {\n        abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      },\n      stackAlloc: function stackAlloc() {\n        abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n      }\n    }; // The address globals begin at. Very low in memory, for code size and optimization opportunities.\n    // Above 0 is static memory, starting with globals.\n    // Then the stack.\n    // Then 'dynamic' memory for sbrk.\n\n    var GLOBAL_BASE = 1024; // === Preamble library stuff ===\n    // Documentation for the public APIs defined in this file must be updated in:\n    //    site/source/docs/api_reference/preamble.js.rst\n    // A prebuilt local version of the documentation is available at:\n    //    site/build/text/docs/api_reference/preamble.js.txt\n    // You can also build docs locally as HTML or other formats in site/\n    // An online HTML version (which may be of a different version of Emscripten)\n    //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n    var wasmBinary;\n    if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\n    if (!_Object$getOwnPropertyDescriptor(Module, 'wasmBinary')) _Object$defineProperty(Module, 'wasmBinary', {\n      configurable: true,\n      get: function get() {\n        abort('Module.wasmBinary has been replaced with plain wasmBinary');\n      }\n    });\n    var noExitRuntime;\n    if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];\n    if (!_Object$getOwnPropertyDescriptor(Module, 'noExitRuntime')) _Object$defineProperty(Module, 'noExitRuntime', {\n      configurable: true,\n      get: function get() {\n        abort('Module.noExitRuntime has been replaced with plain noExitRuntime');\n      }\n    });\n\n    if (typeof WebAssembly !== 'object') {\n      abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');\n    } // In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.\n    // In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)\n\n    /** @type {function(number, number, string, boolean=)} */\n\n\n    function setValue(ptr, value, type, noSafe) {\n      type = type || 'i8';\n      if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n      switch (type) {\n        case 'i1':\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case 'i8':\n          HEAP8[ptr >> 0] = value;\n          break;\n\n        case 'i16':\n          HEAP16[ptr >> 1] = value;\n          break;\n\n        case 'i32':\n          HEAP32[ptr >> 2] = value;\n          break;\n\n        case 'i64':\n          tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? (Math_min(+Math_floor(tempDouble / 4294967296.0), 4294967295.0) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n          break;\n\n        case 'float':\n          HEAPF32[ptr >> 2] = value;\n          break;\n\n        case 'double':\n          HEAPF64[ptr >> 3] = value;\n          break;\n\n        default:\n          abort('invalid type for setValue: ' + type);\n      }\n    }\n    /** @type {function(number, string, boolean=)} */\n\n\n    function getValue(ptr, type, noSafe) {\n      type = type || 'i8';\n      if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n      switch (type) {\n        case 'i1':\n          return HEAP8[ptr >> 0];\n\n        case 'i8':\n          return HEAP8[ptr >> 0];\n\n        case 'i16':\n          return HEAP16[ptr >> 1];\n\n        case 'i32':\n          return HEAP32[ptr >> 2];\n\n        case 'i64':\n          return HEAP32[ptr >> 2];\n\n        case 'float':\n          return HEAPF32[ptr >> 2];\n\n        case 'double':\n          return HEAPF64[ptr >> 3];\n\n        default:\n          abort('invalid type for getValue: ' + type);\n      }\n\n      return null;\n    } // Wasm globals\n\n\n    var wasmMemory; // In fastcomp asm.js, we don't need a wasm Table at all.\n    // In the wasm backend, we polyfill the WebAssembly object,\n    // so this creates a (non-native-wasm) table for us.\n\n    var wasmTable = new WebAssembly.Table({\n      'initial': 6,\n      'maximum': 6 + 0,\n      'element': 'anyfunc'\n    }); //========================================\n    // Runtime essentials\n    //========================================\n    // whether we are quitting the application. no code should run after this.\n    // set in exit() and abort()\n\n    var ABORT = false; // set by exit() and abort().  Passed to 'onExit' handler.\n    // NOTE: This is also used as the process return code code in shell environments\n    // but only when noExitRuntime is false.\n\n    var EXITSTATUS = 0;\n    /** @type {function(*, string=)} */\n\n    function assert(condition, text) {\n      if (!condition) {\n        abort('Assertion failed: ' + text);\n      }\n    } // Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\n\n\n    function getCFunc(ident) {\n      var func = Module['_' + ident]; // closure exported function\n\n      assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n      return func;\n    } // C calling interface.\n\n\n    function ccall(ident, returnType, argTypes, args, opts) {\n      // For fast lookup of conversion functions\n      var toC = {\n        'string': function string(str) {\n          var ret = 0;\n\n          if (str !== null && str !== undefined && str !== 0) {\n            // null string\n            // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n            var len = (str.length << 2) + 1;\n            ret = stackAlloc(len);\n            stringToUTF8(str, ret, len);\n          }\n\n          return ret;\n        },\n        'array': function array(arr) {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        }\n      };\n\n      function convertReturnValue(ret) {\n        if (returnType === 'string') return UTF8ToString(ret);\n        if (returnType === 'boolean') return Boolean(ret);\n        return ret;\n      }\n\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      assert(returnType !== 'array', 'Return type should not be \"array\".');\n\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n\n      var ret = func.apply(null, cArgs);\n      ret = convertReturnValue(ret);\n      if (stack !== 0) stackRestore(stack);\n      return ret;\n    }\n\n    function cwrap(ident, returnType, argTypes, opts) {\n      return function () {\n        return ccall(ident, returnType, argTypes, arguments, opts);\n      };\n    }\n\n    var ALLOC_NORMAL = 0; // Tries to use _malloc()\n\n    var ALLOC_STACK = 1; // Lives for the duration of the current function call\n\n    var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk\n\n    var ALLOC_NONE = 3; // Do not allocate\n    // allocate(): This is for internal use. You can use it yourself as well, but the interface\n    //             is a little tricky (see docs right below). The reason is that it is optimized\n    //             for multiple syntaxes to save space in generated code. So you should\n    //             normally not use allocate(), and instead allocate memory using _malloc(),\n    //             initialize it with setValue(), and so forth.\n    // @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n    //        in *bytes* (note that this is sometimes confusing: the next parameter does not\n    //        affect this!)\n    // @types: Either an array of types, one for each byte (or 0 if no type at that position),\n    //         or a single type which is used for the entire block. This only matters if there\n    //         is initial data - if @slab is a number, then this does not matter at all and is\n    //         ignored.\n    // @allocator: How to allocate memory, see ALLOC_*\n\n    /** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\n\n    function allocate(slab, types, allocator, ptr) {\n      var zeroinit, size;\n\n      if (typeof slab === 'number') {\n        zeroinit = true;\n        size = slab;\n      } else {\n        zeroinit = false;\n        size = slab.length;\n      }\n\n      var singleType = typeof types === 'string' ? types : null;\n      var ret;\n\n      if (allocator == ALLOC_NONE) {\n        ret = ptr;\n      } else {\n        ret = [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n      }\n\n      if (zeroinit) {\n        var stop;\n        ptr = ret;\n        assert((ret & 3) == 0);\n        stop = ret + (size & ~3);\n\n        for (; ptr < stop; ptr += 4) {\n          HEAP32[ptr >> 2] = 0;\n        }\n\n        stop = ret + size;\n\n        while (ptr < stop) {\n          HEAP8[ptr++ >> 0] = 0;\n        }\n\n        return ret;\n      }\n\n      if (singleType === 'i8') {\n        if (slab.subarray || slab.slice) {\n          HEAPU8.set(\n          /** @type {!Uint8Array} */\n          slab, ret);\n        } else {\n          HEAPU8.set(new Uint8Array(slab), ret);\n        }\n\n        return ret;\n      }\n\n      var i = 0,\n          type,\n          typeSize,\n          previousType;\n\n      while (i < size) {\n        var curr = slab[i];\n        type = singleType || types[i];\n\n        if (type === 0) {\n          i++;\n          continue;\n        }\n\n        assert(type, 'Must know what type to store in allocate!');\n        if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n        setValue(ret + i, curr, type); // no need to look up size unless type changes, so cache it\n\n        if (previousType !== type) {\n          typeSize = getNativeTypeSize(type);\n          previousType = type;\n        }\n\n        i += typeSize;\n      }\n\n      return ret;\n    } // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\n\n\n    function getMemory(size) {\n      if (!runtimeInitialized) return dynamicAlloc(size);\n      return _malloc(size);\n    } // runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.\n    // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n    // a copy of that string as a Javascript String object.\n\n\n    var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n    /**\n     * @param {number} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n\n    function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\n\n      while (u8Array[endPtr] && !(endPtr >= endIdx)) {\n        ++endPtr;\n      }\n\n      if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n      } else {\n        var str = ''; // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\n\n        while (idx < endPtr) {\n          // For UTF8 byte structure, see:\n          // http://en.wikipedia.org/wiki/UTF-8#Description\n          // https://www.ietf.org/rfc/rfc2279.txt\n          // https://tools.ietf.org/html/rfc3629\n          var u0 = u8Array[idx++];\n\n          if (!(u0 & 0x80)) {\n            str += String.fromCharCode(u0);\n            continue;\n          }\n\n          var u1 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xE0) == 0xC0) {\n            str += String.fromCharCode((u0 & 31) << 6 | u1);\n            continue;\n          }\n\n          var u2 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xF0) == 0xE0) {\n            u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n          } else {\n            if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;\n          }\n\n          if (u0 < 0x10000) {\n            str += String.fromCharCode(u0);\n          } else {\n            var ch = u0 - 0x10000;\n            str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n          }\n        }\n      }\n\n      return str;\n    } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\n    // copy of that string as a Javascript String object.\n    // maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\n    //                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\n    //                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\n    //                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\n    //                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\n    //                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\n    //                 throw JS JIT optimizations off, so it is worth to consider consistently using one\n    //                 style or the other.\n\n    /**\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n\n\n    function UTF8ToString(ptr, maxBytesToRead) {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n    } // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n    // encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n    //   outIdx: The starting offset in the array to begin the copying.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n    //                    This count should include the null terminator,\n    //                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n      if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n        return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (u >= 0xD800 && u <= 0xDFFF) {\n          var u1 = str.charCodeAt(++i);\n          u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;\n        }\n\n        if (u <= 0x7F) {\n          if (outIdx >= endIdx) break;\n          outU8Array[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n          if (outIdx + 1 >= endIdx) break;\n          outU8Array[outIdx++] = 0xC0 | u >> 6;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else if (u <= 0xFFFF) {\n          if (outIdx + 2 >= endIdx) break;\n          outU8Array[outIdx++] = 0xE0 | u >> 12;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');\n          outU8Array[outIdx++] = 0xF0 | u >> 18;\n          outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n          outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n          outU8Array[outIdx++] = 0x80 | u & 63;\n        }\n      } // Null-terminate the pointer to the buffer.\n\n\n      outU8Array[outIdx] = 0;\n      return outIdx - startIdx;\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF8(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\n        if (u <= 0x7F) ++len;else if (u <= 0x7FF) len += 2;else if (u <= 0xFFFF) len += 3;else len += 4;\n      }\n\n      return len;\n    } // runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.\n    // Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n    // a copy of that string as a Javascript String object.\n\n\n    function AsciiToString(ptr) {\n      var str = '';\n\n      while (1) {\n        var ch = HEAPU8[ptr++ >> 0];\n        if (!ch) return str;\n        str += String.fromCharCode(ch);\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\n\n    function stringToAscii(str, outPtr) {\n      return writeAsciiToMemory(str, outPtr, false);\n    } // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n    // a copy of that string as a Javascript String object.\n\n\n    var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\n    function UTF16ToString(ptr) {\n      assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n      var endPtr = ptr; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n      // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n      var idx = endPtr >> 1;\n\n      while (HEAP16[idx]) {\n        ++idx;\n      }\n\n      endPtr = idx << 1;\n\n      if (endPtr - ptr > 32 && UTF16Decoder) {\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n      } else {\n        var i = 0;\n        var str = '';\n\n        while (1) {\n          var codeUnit = HEAP16[ptr + i * 2 >> 1];\n          if (codeUnit == 0) return str;\n          ++i; // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n\n          str += String.fromCharCode(codeUnit);\n        }\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n    //                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF16(str, outPtr, maxBytesToWrite) {\n      assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n      }\n\n      if (maxBytesToWrite < 2) return 0;\n      maxBytesToWrite -= 2; // Null terminator.\n\n      var startPtr = outPtr;\n      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n\n      for (var i = 0; i < numCharsToWrite; ++i) {\n        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n        HEAP16[outPtr >> 1] = codeUnit;\n        outPtr += 2;\n      } // Null-terminate the pointer to the HEAP.\n\n\n      HEAP16[outPtr >> 1] = 0;\n      return outPtr - startPtr;\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF16(str) {\n      return str.length * 2;\n    }\n\n    function UTF32ToString(ptr) {\n      assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n      var i = 0;\n      var str = '';\n\n      while (1) {\n        var utf32 = HEAP32[ptr + i * 4 >> 2];\n        if (utf32 == 0) return str;\n        ++i; // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n\n        if (utf32 >= 0x10000) {\n          var ch = utf32 - 0x10000;\n          str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n        } else {\n          str += String.fromCharCode(utf32);\n        }\n      }\n    } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n    // null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n    // Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n    // Parameters:\n    //   str: the Javascript string to copy.\n    //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n    //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n    //                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n    //                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n    // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n    function stringToUTF32(str, outPtr, maxBytesToWrite) {\n      assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n      if (maxBytesToWrite === undefined) {\n        maxBytesToWrite = 0x7FFFFFFF;\n      }\n\n      if (maxBytesToWrite < 4) return 0;\n      var startPtr = outPtr;\n      var endPtr = startPtr + maxBytesToWrite - 4;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n          var trailSurrogate = str.charCodeAt(++i);\n          codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;\n        }\n\n        HEAP32[outPtr >> 2] = codeUnit;\n        outPtr += 4;\n        if (outPtr + 4 > endPtr) break;\n      } // Null-terminate the pointer to the HEAP.\n\n\n      HEAP32[outPtr >> 2] = 0;\n      return outPtr - startPtr;\n    } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n    function lengthBytesUTF32(str) {\n      var len = 0;\n\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var codeUnit = str.charCodeAt(i);\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n\n        len += 4;\n      }\n\n      return len;\n    } // Allocate heap space for a JS string, and write it there.\n    // It is the responsibility of the caller to free() that memory.\n\n\n    function allocateUTF8(str) {\n      var size = lengthBytesUTF8(str) + 1;\n\n      var ret = _malloc(size);\n\n      if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n      return ret;\n    } // Allocate stack space for a JS string, and write it there.\n\n\n    function allocateUTF8OnStack(str) {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8Array(str, HEAP8, ret, size);\n      return ret;\n    } // Deprecated: This function should not be called because it is unsafe and does not provide\n    // a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n    // function stringToUTF8Array() instead, which takes in a maximum length that can be used\n    // to be secure from out of bounds writes.\n\n    /** @deprecated */\n\n\n    function writeStringToMemory(string, buffer, dontAddNull) {\n      warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n      var\n      /** @type {number} */\n      lastChar,\n      /** @type {number} */\n      end;\n\n      if (dontAddNull) {\n        // stringToUTF8Array always appends null. If we don't want to do that, remember the\n        // character that existed at the location where the null will be placed, and restore\n        // that after the write (below).\n        end = buffer + lengthBytesUTF8(string);\n        lastChar = HEAP8[end];\n      }\n\n      stringToUTF8(string, buffer, Infinity);\n      if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n    }\n\n    function writeArrayToMemory(array, buffer) {\n      assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');\n      HEAP8.set(array, buffer);\n    }\n\n    function writeAsciiToMemory(str, buffer, dontAddNull) {\n      for (var i = 0; i < str.length; ++i) {\n        assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);\n        HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n      } // Null-terminate the pointer to the HEAP.\n\n\n      if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n    } // Memory management\n\n\n    var PAGE_SIZE = 16384;\n    var WASM_PAGE_SIZE = 65536;\n    var ASMJS_PAGE_SIZE = 16777216;\n\n    function alignUp(x, multiple) {\n      if (x % multiple > 0) {\n        x += multiple - x % multiple;\n      }\n\n      return x;\n    }\n\n    var HEAP,\n    /** @type {ArrayBuffer} */\n    buffer,\n    /** @type {Int8Array} */\n    HEAP8,\n    /** @type {Uint8Array} */\n    HEAPU8,\n    /** @type {Int16Array} */\n    HEAP16,\n    /** @type {Uint16Array} */\n    HEAPU16,\n    /** @type {Int32Array} */\n    HEAP32,\n    /** @type {Uint32Array} */\n    HEAPU32,\n    /** @type {Float32Array} */\n    HEAPF32,\n    /** @type {Float64Array} */\n    HEAPF64;\n\n    function updateGlobalBufferAndViews(buf) {\n      buffer = buf;\n      Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n      Module['HEAP16'] = HEAP16 = new Int16Array(buf);\n      Module['HEAP32'] = HEAP32 = new Int32Array(buf);\n      Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n      Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\n      Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n      Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\n      Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\n    }\n\n    var STATIC_BASE = 1024,\n        STACK_BASE = 5246640,\n        STACKTOP = STACK_BASE,\n        STACK_MAX = 3760,\n        DYNAMIC_BASE = 5246640,\n        DYNAMICTOP_PTR = 3600;\n    assert(STACK_BASE % 16 === 0, 'stack must start aligned');\n    assert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');\n    var TOTAL_STACK = 5242880;\n    if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime');\n    var INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;\n    if (!_Object$getOwnPropertyDescriptor(Module, 'TOTAL_MEMORY')) _Object$defineProperty(Module, 'TOTAL_MEMORY', {\n      configurable: true,\n      get: function get() {\n        abort('Module.TOTAL_MEMORY has been replaced with plain INITIAL_TOTAL_MEMORY');\n      }\n    });\n    assert(INITIAL_TOTAL_MEMORY >= TOTAL_STACK, 'TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'); // check for full engine support (use string 'subarray' to avoid closure compiler confusion)\n\n    assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, 'JS engine does not provide full typed array support'); // In standalone mode, the wasm creates the memory, and the user can't provide it.\n    // In non-standalone/normal mode, we create the memory here.\n    // Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm\n    // memory is created in the wasm, not in JS.)\n\n    if (Module['wasmMemory']) {\n      wasmMemory = Module['wasmMemory'];\n    } else {\n      wasmMemory = new WebAssembly.Memory({\n        'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE,\n        'maximum': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE\n      });\n    }\n\n    if (wasmMemory) {\n      buffer = wasmMemory.buffer;\n    } // If the user provides an incorrect length, just use that length instead rather than providing the user to\n    // specifically provide the memory length with Module['TOTAL_MEMORY'].\n\n\n    INITIAL_TOTAL_MEMORY = buffer.byteLength;\n    assert(INITIAL_TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\n    updateGlobalBufferAndViews(buffer);\n    HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE; // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n\n    function writeStackCookie() {\n      assert((STACK_MAX & 3) == 0); // The stack grows downwards\n\n      HEAPU32[(STACK_MAX >> 2) + 1] = 0x2135467;\n      HEAPU32[(STACK_MAX >> 2) + 2] = 0x89BACDFE; // Also test the global address 0 for integrity.\n      // We don't do this with ASan because ASan does its own checks for this.\n\n      HEAP32[0] = 0x63736d65;\n      /* 'emsc' */\n    }\n\n    function checkStackCookie() {\n      var cookie1 = HEAPU32[(STACK_MAX >> 2) + 1];\n      var cookie2 = HEAPU32[(STACK_MAX >> 2) + 2];\n\n      if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {\n        abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' ' + cookie1.toString(16));\n      } // Also test the global address 0 for integrity.\n      // We don't do this with ASan because ASan does its own checks for this.\n\n\n      if (HEAP32[0] !== 0x63736d65\n      /* 'emsc' */\n      ) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n    }\n\n    function abortStackOverflow(allocSize) {\n      abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');\n    } // Endianness check (note: assumes compiler arch was little-endian)\n\n\n    (function () {\n      var h16 = new Int16Array(1);\n      var h8 = new Int8Array(h16.buffer);\n      h16[0] = 0x6373;\n      if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n    })();\n\n    function abortFnPtrError(ptr, sig) {\n      abort(\"Invalid function pointer \" + ptr + \" called with signature '\" + sig + \"'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). Build with ASSERTIONS=2 for more info.\");\n    }\n\n    function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        var callback = callbacks.shift();\n\n        if (typeof callback == 'function') {\n          callback();\n          continue;\n        }\n\n        var func = callback.func;\n\n        if (typeof func === 'number') {\n          if (callback.arg === undefined) {\n            Module['dynCall_v'](func);\n          } else {\n            Module['dynCall_vi'](func, callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n\n    var __ATPRERUN__ = []; // functions called before the runtime is initialized\n\n    var __ATINIT__ = []; // functions called during startup\n\n    var __ATMAIN__ = []; // functions called when main() is to be run\n\n    var __ATEXIT__ = []; // functions called during shutdown\n\n    var __ATPOSTRUN__ = []; // functions called after the main() is called\n\n    var runtimeInitialized = false;\n    var runtimeExited = false;\n\n    function preRun() {\n      if (Module['preRun']) {\n        if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n\n        while (Module['preRun'].length) {\n          addOnPreRun(Module['preRun'].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n\n    function initRuntime() {\n      checkStackCookie();\n      assert(!runtimeInitialized);\n      runtimeInitialized = true;\n      callRuntimeCallbacks(__ATINIT__);\n    }\n\n    function preMain() {\n      checkStackCookie();\n      callRuntimeCallbacks(__ATMAIN__);\n    }\n\n    function exitRuntime() {\n      checkStackCookie();\n      runtimeExited = true;\n    }\n\n    function postRun() {\n      checkStackCookie();\n\n      if (Module['postRun']) {\n        if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n\n        while (Module['postRun'].length) {\n          addOnPostRun(Module['postRun'].shift());\n        }\n      }\n\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n\n    function addOnPreMain(cb) {\n      __ATMAIN__.unshift(cb);\n    }\n\n    function addOnExit(cb) {}\n\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    function unSign(value, bits, ignore) {\n      if (value >= 0) {\n        return value;\n      }\n\n      return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n      : Math.pow(2, bits) + value;\n    }\n\n    function reSign(value, bits, ignore) {\n      if (value <= 0) {\n        return value;\n      }\n\n      var half = bits <= 32 ? Math.abs(1 << bits - 1) // abs is needed if bits == 32\n      : Math.pow(2, bits - 1);\n\n      if (value >= half && (bits <= 32 || value > half)) {\n        // for huge values, we can hit the precision limit and always get true here. so don't do that\n        // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n        // TODO: In i64 mode 1, resign the two parts separately and safely\n        value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n      }\n\n      return value;\n    } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\n\n    assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n    var Math_abs = Math.abs;\n    var Math_cos = Math.cos;\n    var Math_sin = Math.sin;\n    var Math_tan = Math.tan;\n    var Math_acos = Math.acos;\n    var Math_asin = Math.asin;\n    var Math_atan = Math.atan;\n    var Math_atan2 = Math.atan2;\n    var Math_exp = Math.exp;\n    var Math_log = Math.log;\n    var Math_sqrt = Math.sqrt;\n    var Math_ceil = Math.ceil;\n    var Math_floor = Math.floor;\n    var Math_pow = Math.pow;\n    var Math_imul = Math.imul;\n    var Math_fround = Math.fround;\n    var Math_round = Math.round;\n    var Math_min = Math.min;\n    var Math_max = Math.max;\n    var Math_clz32 = Math.clz32;\n    var Math_trunc = Math.trunc; // A counter of dependencies for calling run(). If we need to\n    // do asynchronous work before running, increment this and\n    // decrement it. Incrementing must happen in a place like\n    // Module.preRun (used by emcc to add file preloading).\n    // Note that you can add dependencies in preRun, even though\n    // it happens right before run - run will be postponed until\n    // the dependencies are met.\n\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\n    var runDependencyTracking = {};\n\n    function getUniqueRunDependency(id) {\n      var orig = id;\n\n      while (1) {\n        if (!runDependencyTracking[id]) return id;\n        id = orig + Math.random();\n      }\n\n      return id;\n    }\n\n    function addRunDependency(id) {\n      runDependencies++;\n\n      if (Module['monitorRunDependencies']) {\n        Module['monitorRunDependencies'](runDependencies);\n      }\n\n      if (id) {\n        assert(!runDependencyTracking[id]);\n        runDependencyTracking[id] = 1;\n\n        if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n          // Check for missing dependencies every few seconds\n          runDependencyWatcher = setInterval(function () {\n            if (ABORT) {\n              clearInterval(runDependencyWatcher);\n              runDependencyWatcher = null;\n              return;\n            }\n\n            var shown = false;\n\n            for (var dep in runDependencyTracking) {\n              if (!shown) {\n                shown = true;\n                err('still waiting on run dependencies:');\n              }\n\n              err('dependency: ' + dep);\n            }\n\n            if (shown) {\n              err('(end of list)');\n            }\n          }, 10000);\n        }\n      } else {\n        err('warning: run dependency added without ID');\n      }\n    }\n\n    function removeRunDependency(id) {\n      runDependencies--;\n\n      if (Module['monitorRunDependencies']) {\n        Module['monitorRunDependencies'](runDependencies);\n      }\n\n      if (id) {\n        assert(runDependencyTracking[id]);\n        delete runDependencyTracking[id];\n      } else {\n        err('warning: run dependency removed without ID');\n      }\n\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback(); // can add another dependenciesFulfilled\n        }\n      }\n    }\n\n    Module[\"preloadedImages\"] = {}; // maps url to image data\n\n    Module[\"preloadedAudios\"] = {}; // maps url to audio data\n\n    function abort(what) {\n      if (Module['onAbort']) {\n        Module['onAbort'](what);\n      }\n\n      what += '';\n      out(what);\n      err(what);\n      ABORT = true;\n      EXITSTATUS = 1;\n      var output = 'abort(' + what + ') at ' + stackTrace();\n      what = output; // Throw a wasm runtime error, because a JS error might be seen as a foreign\n      // exception, which means we'd run destructors on it. We need the error to\n      // simply make the program stop.\n\n      throw new WebAssembly.RuntimeError(what);\n    }\n\n    var memoryInitializer = null; // show errors on likely calls to FS when it was not included\n\n    var FS = {\n      error: function error() {\n        abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n      },\n      init: function init() {\n        FS.error();\n      },\n      createDataFile: function createDataFile() {\n        FS.error();\n      },\n      createPreloadedFile: function createPreloadedFile() {\n        FS.error();\n      },\n      createLazyFile: function createLazyFile() {\n        FS.error();\n      },\n      open: function open() {\n        FS.error();\n      },\n      mkdev: function mkdev() {\n        FS.error();\n      },\n      registerDevice: function registerDevice() {\n        FS.error();\n      },\n      analyzePath: function analyzePath() {\n        FS.error();\n      },\n      loadFilesFromDB: function loadFilesFromDB() {\n        FS.error();\n      },\n      ErrnoError: function ErrnoError() {\n        FS.error();\n      }\n    };\n    Module['FS_createDataFile'] = FS.createDataFile;\n    Module['FS_createPreloadedFile'] = FS.createPreloadedFile; // Copyright 2017 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n    // Prefix of data URIs emitted by SINGLE_FILE and related options.\n\n    var dataURIPrefix = 'data:application/octet-stream;base64,'; // Indicates whether filename is a base64 data URI.\n\n    function isDataURI(filename) {\n      return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n    }\n\n    var wasmBinaryFile = 'hello.wasm';\n\n    if (!isDataURI(wasmBinaryFile)) {\n      wasmBinaryFile = locateFile(wasmBinaryFile);\n    }\n\n    function getBinary() {\n      try {\n        if (wasmBinary) {\n          return new Uint8Array(wasmBinary);\n        }\n\n        if (readBinary) {\n          return readBinary(wasmBinaryFile);\n        } else {\n          throw \"both async and sync fetching of the wasm failed\";\n        }\n      } catch (err) {\n        abort(err);\n      }\n    }\n\n    function getBinaryPromise() {\n      // if we don't have the binary yet, and have the Fetch api, use that\n      // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n      if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n        return fetch(wasmBinaryFile, {\n          credentials: 'same-origin'\n        }).then(function (response) {\n          if (!response['ok']) {\n            throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n          }\n\n          return response['arrayBuffer']();\n        })[\"catch\"](function () {\n          return getBinary();\n        });\n      } // Otherwise, getBinary should be able to get it synchronously\n\n\n      return new _Promise(function (resolve, reject) {\n        resolve(getBinary());\n      });\n    } // Create the wasm instance.\n    // Receives the wasm imports, returns the exports.\n\n\n    function createWasm() {\n      // prepare imports\n      var info = {\n        'env': asmLibraryArg,\n        'wasi_snapshot_preview1': asmLibraryArg\n      }; // Load the wasm module and create an instance of using native support in the JS engine.\n      // handle a generated wasm instance, receiving its exports and\n      // performing other necessary setup\n\n      /** @param {WebAssembly.Module=} module*/\n\n      function receiveInstance(instance, module) {\n        var exports = instance.exports;\n        Module['asm'] = exports;\n        removeRunDependency('wasm-instantiate');\n      } // we can't run yet (except in a pthread, where we have a custom sync instantiator)\n\n\n      addRunDependency('wasm-instantiate'); // Async compilation can be confusing when an error on the page overwrites Module\n      // (for example, if the order of elements is wrong, and the one defining Module is\n      // later), so we save Module and check it later.\n\n      var trueModule = Module;\n\n      function receiveInstantiatedSource(output) {\n        // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n        // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n        assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n        trueModule = null; // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n        // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\n\n        receiveInstance(output['instance']);\n      }\n\n      function instantiateArrayBuffer(receiver) {\n        return getBinaryPromise().then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        }).then(receiver, function (reason) {\n          err('failed to asynchronously prepare wasm: ' + reason);\n          abort(reason);\n        });\n      } // Prefer streaming instantiation if available.\n\n\n      function instantiateAsync() {\n        if (!wasmBinary && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') {\n          fetch(wasmBinaryFile, {\n            credentials: 'same-origin'\n          }).then(function (response) {\n            var result = WebAssembly.instantiateStreaming(response, info);\n            return result.then(receiveInstantiatedSource, function (reason) {\n              // We expect the most common failure cause to be a bad MIME type for the binary,\n              // in which case falling back to ArrayBuffer instantiation should work.\n              err('wasm streaming compile failed: ' + reason);\n              err('falling back to ArrayBuffer instantiation');\n              instantiateArrayBuffer(receiveInstantiatedSource);\n            });\n          });\n        } else {\n          return instantiateArrayBuffer(receiveInstantiatedSource);\n        }\n      } // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n      // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n      // to any other async startup actions they are performing.\n\n\n      if (Module['instantiateWasm']) {\n        try {\n          var exports = Module['instantiateWasm'](info, receiveInstance);\n          return exports;\n        } catch (e) {\n          err('Module.instantiateWasm callback failed with error: ' + e);\n          return false;\n        }\n      }\n\n      instantiateAsync();\n      return {}; // no exports yet; we'll fill them in later\n    } // Globals used by JS i64 conversions\n\n\n    var tempDouble;\n    var tempI64; // === Body ===\n\n    var ASM_CONSTS = {}; // STATICTOP = STATIC_BASE + 2736;\n\n    /* global initializers */\n\n    __ATINIT__.push({\n      func: function func() {\n        ___wasm_call_ctors();\n      }\n    });\n    /* no memory initializer */\n    // {{PRE_LIBRARY}}\n\n\n    function demangle(func) {\n      warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\n      return func;\n    }\n\n    function demangleAll(text) {\n      var regex = /\\b_Z[\\w\\d_]+/g;\n      return text.replace(regex, function (x) {\n        var y = demangle(x);\n        return x === y ? x : y + ' [' + x + ']';\n      });\n    }\n\n    function jsStackTrace() {\n      var err = new Error();\n\n      if (!err.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n        // so try that as a special-case.\n        try {\n          throw new Error();\n        } catch (e) {\n          err = e;\n        }\n\n        if (!err.stack) {\n          return '(no stack trace available)';\n        }\n      }\n\n      return err.stack.toString();\n    }\n\n    function stackTrace() {\n      var js = jsStackTrace();\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n      return demangleAll(js);\n    }\n\n    function ___handle_stack_overflow() {\n      abort('stack overflow');\n    }\n\n    function ___lock() {}\n\n    function ___unlock() {}\n\n    function _emscripten_get_heap_size() {\n      return HEAPU8.length;\n    }\n\n    function _emscripten_get_sbrk_ptr() {\n      return 3600;\n    }\n\n    function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n    }\n\n    function abortOnCannotGrowMemory(requestedSize) {\n      abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n    }\n\n    function _emscripten_resize_heap(requestedSize) {\n      abortOnCannotGrowMemory(requestedSize);\n    }\n\n    function flush_NO_FILESYSTEM() {\n      // flush anything remaining in the buffers during shutdown\n      if (typeof _fflush !== 'undefined') _fflush(0);\n      var buffers = SYSCALLS.buffers;\n      if (buffers[1].length) SYSCALLS.printChar(1, 10);\n      if (buffers[2].length) SYSCALLS.printChar(2, 10);\n    }\n\n    var PATH = {\n      splitPath: function splitPath(filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: function normalizeArray(parts, allowAboveRoot) {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        } // if the path is allowed to go above the root, restore leading ..s\n\n\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n\n        return parts;\n      },\n      normalize: function normalize(path) {\n        var isAbsolute = path.charAt(0) === '/',\n            trailingSlash = path.substr(-1) === '/'; // Normalize the path\n\n        path = PATH.normalizeArray(path.split('/').filter(function (p) {\n          return !!p;\n        }), !isAbsolute).join('/');\n\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n\n        if (path && trailingSlash) {\n          path += '/';\n        }\n\n        return (isAbsolute ? '/' : '') + path;\n      },\n      dirname: function dirname(path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n\n        return root + dir;\n      },\n      basename: function basename(path) {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      extname: function extname(path) {\n        return PATH.splitPath(path)[3];\n      },\n      join: function join() {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join('/'));\n      },\n      join2: function join2(l, r) {\n        return PATH.normalize(l + '/' + r);\n      }\n    };\n    var SYSCALLS = {\n      buffers: [null, [], []],\n      printChar: function printChar(stream, curr) {\n        var buffer = SYSCALLS.buffers[stream];\n        assert(buffer);\n\n        if (curr === 0 || curr === 10) {\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n          buffer.length = 0;\n        } else {\n          buffer.push(curr);\n        }\n      },\n      varargs: 0,\n      get: function get(varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n        return ret;\n      },\n      getStr: function getStr() {\n        var ret = UTF8ToString(SYSCALLS.get());\n        return ret;\n      },\n      get64: function get64() {\n        var low = SYSCALLS.get(),\n            high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);else assert(high === -1);\n        return low;\n      },\n      getZero: function getZero() {\n        assert(SYSCALLS.get() === 0);\n      }\n    };\n\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n        var num = 0;\n\n        for (var i = 0; i < iovcnt; i++) {\n          var ptr = HEAP32[iov + i * 8 >> 2];\n          var len = HEAP32[iov + (i * 8 + 4) >> 2];\n\n          for (var j = 0; j < len; j++) {\n            SYSCALLS.printChar(fd, HEAPU8[ptr + j]);\n          }\n\n          num += len;\n        }\n\n        HEAP32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n        return e.errno;\n      }\n    }\n\n    function _memcpy(dest, src, num) {\n      dest = dest | 0;\n      src = src | 0;\n      num = num | 0;\n      var ret = 0;\n      var aligned_dest_end = 0;\n      var block_aligned_dest_end = 0;\n      var dest_end = 0; // Test against a benchmarked cutoff limit for when HEAPU8.set() becomes faster to use.\n\n      if ((num | 0) >= 8192) {\n        _emscripten_memcpy_big(dest | 0, src | 0, num | 0) | 0;\n        return dest | 0;\n      }\n\n      ret = dest | 0;\n      dest_end = dest + num | 0;\n\n      if ((dest & 3) == (src & 3)) {\n        // The initial unaligned < 4-byte front.\n        while (dest & 3) {\n          if ((num | 0) == 0) return ret | 0;\n          HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n          dest = dest + 1 | 0;\n          src = src + 1 | 0;\n          num = num - 1 | 0;\n        }\n\n        aligned_dest_end = dest_end & -4 | 0;\n        block_aligned_dest_end = aligned_dest_end - 64 | 0;\n\n        while ((dest | 0) <= (block_aligned_dest_end | 0)) {\n          HEAP32[dest >> 2] = HEAP32[src >> 2] | 0;\n          HEAP32[dest + 4 >> 2] = HEAP32[src + 4 >> 2] | 0;\n          HEAP32[dest + 8 >> 2] = HEAP32[src + 8 >> 2] | 0;\n          HEAP32[dest + 12 >> 2] = HEAP32[src + 12 >> 2] | 0;\n          HEAP32[dest + 16 >> 2] = HEAP32[src + 16 >> 2] | 0;\n          HEAP32[dest + 20 >> 2] = HEAP32[src + 20 >> 2] | 0;\n          HEAP32[dest + 24 >> 2] = HEAP32[src + 24 >> 2] | 0;\n          HEAP32[dest + 28 >> 2] = HEAP32[src + 28 >> 2] | 0;\n          HEAP32[dest + 32 >> 2] = HEAP32[src + 32 >> 2] | 0;\n          HEAP32[dest + 36 >> 2] = HEAP32[src + 36 >> 2] | 0;\n          HEAP32[dest + 40 >> 2] = HEAP32[src + 40 >> 2] | 0;\n          HEAP32[dest + 44 >> 2] = HEAP32[src + 44 >> 2] | 0;\n          HEAP32[dest + 48 >> 2] = HEAP32[src + 48 >> 2] | 0;\n          HEAP32[dest + 52 >> 2] = HEAP32[src + 52 >> 2] | 0;\n          HEAP32[dest + 56 >> 2] = HEAP32[src + 56 >> 2] | 0;\n          HEAP32[dest + 60 >> 2] = HEAP32[src + 60 >> 2] | 0;\n          dest = dest + 64 | 0;\n          src = src + 64 | 0;\n        }\n\n        while ((dest | 0) < (aligned_dest_end | 0)) {\n          HEAP32[dest >> 2] = HEAP32[src >> 2] | 0;\n          dest = dest + 4 | 0;\n          src = src + 4 | 0;\n        }\n      } else {\n        // In the unaligned copy case, unroll a bit as well.\n        aligned_dest_end = dest_end - 4 | 0;\n\n        while ((dest | 0) < (aligned_dest_end | 0)) {\n          HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n          HEAP8[dest + 1 >> 0] = HEAP8[src + 1 >> 0] | 0;\n          HEAP8[dest + 2 >> 0] = HEAP8[src + 2 >> 0] | 0;\n          HEAP8[dest + 3 >> 0] = HEAP8[src + 3 >> 0] | 0;\n          dest = dest + 4 | 0;\n          src = src + 4 | 0;\n        }\n      } // The remaining unaligned < 4 byte tail.\n\n\n      while ((dest | 0) < (dest_end | 0)) {\n        HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;\n        dest = dest + 1 | 0;\n        src = src + 1 | 0;\n      }\n\n      return ret | 0;\n    }\n\n    function _memset(ptr, value, num) {\n      ptr = ptr | 0;\n      value = value | 0;\n      num = num | 0;\n      var end = 0,\n          aligned_end = 0,\n          block_aligned_end = 0,\n          value4 = 0;\n      end = ptr + num | 0;\n      value = value & 0xff;\n\n      if ((num | 0) >= 67\n      /* 64 bytes for an unrolled loop + 3 bytes for unaligned head*/\n      ) {\n          while ((ptr & 3) != 0) {\n            HEAP8[ptr >> 0] = value;\n            ptr = ptr + 1 | 0;\n          }\n\n          aligned_end = end & -4 | 0;\n          value4 = value | value << 8 | value << 16 | value << 24;\n          block_aligned_end = aligned_end - 64 | 0;\n\n          while ((ptr | 0) <= (block_aligned_end | 0)) {\n            HEAP32[ptr >> 2] = value4;\n            HEAP32[ptr + 4 >> 2] = value4;\n            HEAP32[ptr + 8 >> 2] = value4;\n            HEAP32[ptr + 12 >> 2] = value4;\n            HEAP32[ptr + 16 >> 2] = value4;\n            HEAP32[ptr + 20 >> 2] = value4;\n            HEAP32[ptr + 24 >> 2] = value4;\n            HEAP32[ptr + 28 >> 2] = value4;\n            HEAP32[ptr + 32 >> 2] = value4;\n            HEAP32[ptr + 36 >> 2] = value4;\n            HEAP32[ptr + 40 >> 2] = value4;\n            HEAP32[ptr + 44 >> 2] = value4;\n            HEAP32[ptr + 48 >> 2] = value4;\n            HEAP32[ptr + 52 >> 2] = value4;\n            HEAP32[ptr + 56 >> 2] = value4;\n            HEAP32[ptr + 60 >> 2] = value4;\n            ptr = ptr + 64 | 0;\n          }\n\n          while ((ptr | 0) < (aligned_end | 0)) {\n            HEAP32[ptr >> 2] = value4;\n            ptr = ptr + 4 | 0;\n          }\n        } // The remaining bytes.\n\n\n      while ((ptr | 0) < (end | 0)) {\n        HEAP8[ptr >> 0] = value;\n        ptr = ptr + 1 | 0;\n      }\n\n      return end - num | 0;\n    }\n\n    function _setTempRet0($i) {\n      setTempRet0($i | 0);\n    }\n\n    var ASSERTIONS = true; // Copyright 2017 The Emscripten Authors.  All rights reserved.\n    // Emscripten is available under two separate licenses, the MIT license and the\n    // University of Illinois/NCSA Open Source License.  Both these licenses can be\n    // found in the LICENSE file.\n\n    /** @type {function(string, boolean=, number=)} */\n\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n\n    function intArrayToString(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        var chr = array[i];\n\n        if (chr > 0xFF) {\n          if (ASSERTIONS) {\n            assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n          }\n\n          chr &= 0xFF;\n        }\n\n        ret.push(String.fromCharCode(chr));\n      }\n\n      return ret.join('');\n    } // ASM_LIBRARY EXTERN PRIMITIVES: Int8Array,Int32Array\n\n\n    var asmGlobalArg = {};\n    var asmLibraryArg = {\n      \"__handle_stack_overflow\": ___handle_stack_overflow,\n      \"__lock\": ___lock,\n      \"__unlock\": ___unlock,\n      \"emscripten_get_sbrk_ptr\": _emscripten_get_sbrk_ptr,\n      \"emscripten_memcpy_big\": _emscripten_memcpy_big,\n      \"emscripten_resize_heap\": _emscripten_resize_heap,\n      \"fd_write\": _fd_write,\n      \"memory\": wasmMemory,\n      \"setTempRet0\": _setTempRet0,\n      \"table\": wasmTable\n    };\n    var asm = createWasm();\n    Module[\"asm\"] = asm;\n\n    var ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"__wasm_call_ctors\"].apply(null, arguments);\n    };\n\n    var _main = Module[\"_main\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"main\"].apply(null, arguments);\n    };\n\n    var ___errno_location = Module[\"___errno_location\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"__errno_location\"].apply(null, arguments);\n    };\n\n    var _fflush = Module[\"_fflush\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"fflush\"].apply(null, arguments);\n    };\n\n    var _setThrew = Module[\"_setThrew\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"setThrew\"].apply(null, arguments);\n    };\n\n    var _malloc = Module[\"_malloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"malloc\"].apply(null, arguments);\n    };\n\n    var _free = Module[\"_free\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"free\"].apply(null, arguments);\n    };\n\n    var ___set_stack_limit = Module[\"___set_stack_limit\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"__set_stack_limit\"].apply(null, arguments);\n    };\n\n    var stackSave = Module[\"stackSave\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackSave\"].apply(null, arguments);\n    };\n\n    var stackAlloc = Module[\"stackAlloc\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments);\n    };\n\n    var stackRestore = Module[\"stackRestore\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"stackRestore\"].apply(null, arguments);\n    };\n\n    var __growWasmMemory = Module[\"__growWasmMemory\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"__growWasmMemory\"].apply(null, arguments);\n    };\n\n    var dynCall_ii = Module[\"dynCall_ii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments);\n    };\n\n    var dynCall_iiii = Module[\"dynCall_iiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments);\n    };\n\n    var dynCall_jiji = Module[\"dynCall_jiji\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_jiji\"].apply(null, arguments);\n    };\n\n    var dynCall_iidiiii = Module[\"dynCall_iidiiii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_iidiiii\"].apply(null, arguments);\n    };\n\n    var dynCall_vii = Module[\"dynCall_vii\"] = function () {\n      assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n      assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n      return Module[\"asm\"][\"dynCall_vii\"].apply(null, arguments);\n    }; // === Auto-generated postamble setup entry stuff ===\n\n\n    Module['asm'] = asm;\n    if (!_Object$getOwnPropertyDescriptor(Module, \"intArrayFromString\")) Module[\"intArrayFromString\"] = function () {\n      abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"intArrayToString\")) Module[\"intArrayToString\"] = function () {\n      abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"ccall\")) Module[\"ccall\"] = function () {\n      abort(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"cwrap\")) Module[\"cwrap\"] = function () {\n      abort(\"'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"setValue\")) Module[\"setValue\"] = function () {\n      abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"getValue\")) Module[\"getValue\"] = function () {\n      abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"allocate\")) Module[\"allocate\"] = function () {\n      abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"getMemory\")) Module[\"getMemory\"] = function () {\n      abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"UTF8ArrayToString\")) Module[\"UTF8ArrayToString\"] = function () {\n      abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"UTF8ToString\")) Module[\"UTF8ToString\"] = function () {\n      abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"stringToUTF8Array\")) Module[\"stringToUTF8Array\"] = function () {\n      abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"stringToUTF8\")) Module[\"stringToUTF8\"] = function () {\n      abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"lengthBytesUTF8\")) Module[\"lengthBytesUTF8\"] = function () {\n      abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function () {\n      abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"addOnPreRun\")) Module[\"addOnPreRun\"] = function () {\n      abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"addOnInit\")) Module[\"addOnInit\"] = function () {\n      abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"addOnPreMain\")) Module[\"addOnPreMain\"] = function () {\n      abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"addOnExit\")) Module[\"addOnExit\"] = function () {\n      abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"addOnPostRun\")) Module[\"addOnPostRun\"] = function () {\n      abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"writeStringToMemory\")) Module[\"writeStringToMemory\"] = function () {\n      abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"writeArrayToMemory\")) Module[\"writeArrayToMemory\"] = function () {\n      abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"writeAsciiToMemory\")) Module[\"writeAsciiToMemory\"] = function () {\n      abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"addRunDependency\")) Module[\"addRunDependency\"] = function () {\n      abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"removeRunDependency\")) Module[\"removeRunDependency\"] = function () {\n      abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"FS_createFolder\")) Module[\"FS_createFolder\"] = function () {\n      abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"FS_createPath\")) Module[\"FS_createPath\"] = function () {\n      abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"FS_createDataFile\")) Module[\"FS_createDataFile\"] = function () {\n      abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"FS_createPreloadedFile\")) Module[\"FS_createPreloadedFile\"] = function () {\n      abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"FS_createLazyFile\")) Module[\"FS_createLazyFile\"] = function () {\n      abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"FS_createLink\")) Module[\"FS_createLink\"] = function () {\n      abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"FS_createDevice\")) Module[\"FS_createDevice\"] = function () {\n      abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"FS_unlink\")) Module[\"FS_unlink\"] = function () {\n      abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"dynamicAlloc\")) Module[\"dynamicAlloc\"] = function () {\n      abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"loadDynamicLibrary\")) Module[\"loadDynamicLibrary\"] = function () {\n      abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"loadWebAssemblyModule\")) Module[\"loadWebAssemblyModule\"] = function () {\n      abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"getLEB\")) Module[\"getLEB\"] = function () {\n      abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"getFunctionTables\")) Module[\"getFunctionTables\"] = function () {\n      abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"alignFunctionTables\")) Module[\"alignFunctionTables\"] = function () {\n      abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"registerFunctions\")) Module[\"registerFunctions\"] = function () {\n      abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"addFunction\")) Module[\"addFunction\"] = function () {\n      abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"removeFunction\")) Module[\"removeFunction\"] = function () {\n      abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = function () {\n      abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"prettyPrint\")) Module[\"prettyPrint\"] = function () {\n      abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"makeBigInt\")) Module[\"makeBigInt\"] = function () {\n      abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = function () {\n      abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"getCompilerSetting\")) Module[\"getCompilerSetting\"] = function () {\n      abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"print\")) Module[\"print\"] = function () {\n      abort(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"printErr\")) Module[\"printErr\"] = function () {\n      abort(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"getTempRet0\")) Module[\"getTempRet0\"] = function () {\n      abort(\"'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"setTempRet0\")) Module[\"setTempRet0\"] = function () {\n      abort(\"'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"callMain\")) Module[\"callMain\"] = function () {\n      abort(\"'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"abort\")) Module[\"abort\"] = function () {\n      abort(\"'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"PROCINFO\")) Module[\"PROCINFO\"] = function () {\n      abort(\"'PROCINFO' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"stringToNewUTF8\")) Module[\"stringToNewUTF8\"] = function () {\n      abort(\"'stringToNewUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"abortOnCannotGrowMemory\")) Module[\"abortOnCannotGrowMemory\"] = function () {\n      abort(\"'abortOnCannotGrowMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"emscripten_realloc_buffer\")) Module[\"emscripten_realloc_buffer\"] = function () {\n      abort(\"'emscripten_realloc_buffer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"ENV\")) Module[\"ENV\"] = function () {\n      abort(\"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"setjmpId\")) Module[\"setjmpId\"] = function () {\n      abort(\"'setjmpId' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"ERRNO_CODES\")) Module[\"ERRNO_CODES\"] = function () {\n      abort(\"'ERRNO_CODES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"ERRNO_MESSAGES\")) Module[\"ERRNO_MESSAGES\"] = function () {\n      abort(\"'ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"DNS__deps\")) Module[\"DNS__deps\"] = function () {\n      abort(\"'DNS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"DNS\")) Module[\"DNS\"] = function () {\n      abort(\"'DNS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"GAI_ERRNO_MESSAGES\")) Module[\"GAI_ERRNO_MESSAGES\"] = function () {\n      abort(\"'GAI_ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"Protocols\")) Module[\"Protocols\"] = function () {\n      abort(\"'Protocols' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"Sockets__deps\")) Module[\"Sockets__deps\"] = function () {\n      abort(\"'Sockets__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"Sockets\")) Module[\"Sockets\"] = function () {\n      abort(\"'Sockets' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"UNWIND_CACHE\")) Module[\"UNWIND_CACHE\"] = function () {\n      abort(\"'UNWIND_CACHE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"readAsmConstArgs\")) Module[\"readAsmConstArgs\"] = function () {\n      abort(\"'readAsmConstArgs' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"PATH\")) Module[\"PATH\"] = function () {\n      abort(\"'PATH' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"PATH_FS__deps\")) Module[\"PATH_FS__deps\"] = function () {\n      abort(\"'PATH_FS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"PATH_FS\")) Module[\"PATH_FS\"] = function () {\n      abort(\"'PATH_FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"SYSCALLS__deps\")) Module[\"SYSCALLS__deps\"] = function () {\n      abort(\"'SYSCALLS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"SYSCALLS\")) Module[\"SYSCALLS\"] = function () {\n      abort(\"'SYSCALLS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"flush_NO_FILESYSTEM\")) Module[\"flush_NO_FILESYSTEM\"] = function () {\n      abort(\"'flush_NO_FILESYSTEM' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"JSEvents\")) Module[\"JSEvents\"] = function () {\n      abort(\"'JSEvents' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"demangle__deps\")) Module[\"demangle__deps\"] = function () {\n      abort(\"'demangle__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"demangle\")) Module[\"demangle\"] = function () {\n      abort(\"'demangle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"demangleAll\")) Module[\"demangleAll\"] = function () {\n      abort(\"'demangleAll' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"jsStackTrace\")) Module[\"jsStackTrace\"] = function () {\n      abort(\"'jsStackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function () {\n      abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"writeI53ToI64__deps\")) Module[\"writeI53ToI64__deps\"] = function () {\n      abort(\"'writeI53ToI64__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"writeI53ToI64\")) Module[\"writeI53ToI64\"] = function () {\n      abort(\"'writeI53ToI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"writeI53ToI64Clamped\")) Module[\"writeI53ToI64Clamped\"] = function () {\n      abort(\"'writeI53ToI64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"writeI53ToI64Signaling\")) Module[\"writeI53ToI64Signaling\"] = function () {\n      abort(\"'writeI53ToI64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"writeI53ToU64Clamped\")) Module[\"writeI53ToU64Clamped\"] = function () {\n      abort(\"'writeI53ToU64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"writeI53ToU64Signaling\")) Module[\"writeI53ToU64Signaling\"] = function () {\n      abort(\"'writeI53ToU64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"readI53FromI64\")) Module[\"readI53FromI64\"] = function () {\n      abort(\"'readI53FromI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"readI53FromU64\")) Module[\"readI53FromU64\"] = function () {\n      abort(\"'readI53FromU64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"convertI32PairToI53\")) Module[\"convertI32PairToI53\"] = function () {\n      abort(\"'convertI32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"convertU32PairToI53\")) Module[\"convertU32PairToI53\"] = function () {\n      abort(\"'convertU32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"Browser__deps\")) Module[\"Browser__deps\"] = function () {\n      abort(\"'Browser__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"Browser__postset\")) Module[\"Browser__postset\"] = function () {\n      abort(\"'Browser__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"Browser\")) Module[\"Browser\"] = function () {\n      abort(\"'Browser' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"Browser__postset__deps\")) Module[\"Browser__postset__deps\"] = function () {\n      abort(\"'Browser__postset__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"FS__deps\")) Module[\"FS__deps\"] = function () {\n      abort(\"'FS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"FS__postset\")) Module[\"FS__postset\"] = function () {\n      abort(\"'FS__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"FS\")) Module[\"FS\"] = function () {\n      abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"MEMFS__deps\")) Module[\"MEMFS__deps\"] = function () {\n      abort(\"'MEMFS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"MEMFS\")) Module[\"MEMFS\"] = function () {\n      abort(\"'MEMFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"TTY__deps\")) Module[\"TTY__deps\"] = function () {\n      abort(\"'TTY__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"TTY__postset\")) Module[\"TTY__postset\"] = function () {\n      abort(\"'TTY__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"TTY\")) Module[\"TTY\"] = function () {\n      abort(\"'TTY' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"PIPEFS__postset\")) Module[\"PIPEFS__postset\"] = function () {\n      abort(\"'PIPEFS__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"PIPEFS__deps\")) Module[\"PIPEFS__deps\"] = function () {\n      abort(\"'PIPEFS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"PIPEFS\")) Module[\"PIPEFS\"] = function () {\n      abort(\"'PIPEFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"SOCKFS__postset\")) Module[\"SOCKFS__postset\"] = function () {\n      abort(\"'SOCKFS__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"SOCKFS__deps\")) Module[\"SOCKFS__deps\"] = function () {\n      abort(\"'SOCKFS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"SOCKFS\")) Module[\"SOCKFS\"] = function () {\n      abort(\"'SOCKFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"GL__postset\")) Module[\"GL__postset\"] = function () {\n      abort(\"'GL__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"GL__deps\")) Module[\"GL__deps\"] = function () {\n      abort(\"'GL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"GL\")) Module[\"GL\"] = function () {\n      abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet__deps\")) Module[\"emscriptenWebGLGet__deps\"] = function () {\n      abort(\"'emscriptenWebGLGet__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet\")) Module[\"emscriptenWebGLGet\"] = function () {\n      abort(\"'emscriptenWebGLGet' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData__deps\")) Module[\"emscriptenWebGLGetTexPixelData__deps\"] = function () {\n      abort(\"'emscriptenWebGLGetTexPixelData__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData\")) Module[\"emscriptenWebGLGetTexPixelData\"] = function () {\n      abort(\"'emscriptenWebGLGetTexPixelData' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform\")) Module[\"emscriptenWebGLGetUniform\"] = function () {\n      abort(\"'emscriptenWebGLGetUniform' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib\")) Module[\"emscriptenWebGLGetVertexAttrib\"] = function () {\n      abort(\"'emscriptenWebGLGetVertexAttrib' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"GL__postset__deps\")) Module[\"GL__postset__deps\"] = function () {\n      abort(\"'GL__postset__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform__deps\")) Module[\"emscriptenWebGLGetUniform__deps\"] = function () {\n      abort(\"'emscriptenWebGLGetUniform__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib__deps\")) Module[\"emscriptenWebGLGetVertexAttrib__deps\"] = function () {\n      abort(\"'emscriptenWebGLGetVertexAttrib__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"AL__deps\")) Module[\"AL__deps\"] = function () {\n      abort(\"'AL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"AL\")) Module[\"AL\"] = function () {\n      abort(\"'AL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"WebVR\")) Module[\"WebVR\"] = function () {\n      abort(\"'WebVR' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"WebVR__deps\")) Module[\"WebVR__deps\"] = function () {\n      abort(\"'WebVR__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"SDL__deps\")) Module[\"SDL__deps\"] = function () {\n      abort(\"'SDL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"SDL\")) Module[\"SDL\"] = function () {\n      abort(\"'SDL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"SDL_gfx\")) Module[\"SDL_gfx\"] = function () {\n      abort(\"'SDL_gfx' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"SDL_gfx__deps\")) Module[\"SDL_gfx__deps\"] = function () {\n      abort(\"'SDL_gfx__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"GLUT__deps\")) Module[\"GLUT__deps\"] = function () {\n      abort(\"'GLUT__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"GLUT\")) Module[\"GLUT\"] = function () {\n      abort(\"'GLUT' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"EGL__deps\")) Module[\"EGL__deps\"] = function () {\n      abort(\"'EGL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"EGL\")) Module[\"EGL\"] = function () {\n      abort(\"'EGL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"GLFW__deps\")) Module[\"GLFW__deps\"] = function () {\n      abort(\"'GLFW__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"GLFW\")) Module[\"GLFW\"] = function () {\n      abort(\"'GLFW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"GLEW__deps\")) Module[\"GLEW__deps\"] = function () {\n      abort(\"'GLEW__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"GLEW\")) Module[\"GLEW\"] = function () {\n      abort(\"'GLEW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"IDBStore\")) Module[\"IDBStore\"] = function () {\n      abort(\"'IDBStore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"IDBStore__deps\")) Module[\"IDBStore__deps\"] = function () {\n      abort(\"'IDBStore__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"runAndAbortIfError\")) Module[\"runAndAbortIfError\"] = function () {\n      abort(\"'runAndAbortIfError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"warnOnce\")) Module[\"warnOnce\"] = function () {\n      abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"stackSave\")) Module[\"stackSave\"] = function () {\n      abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"stackRestore\")) Module[\"stackRestore\"] = function () {\n      abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"stackAlloc\")) Module[\"stackAlloc\"] = function () {\n      abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"AsciiToString\")) Module[\"AsciiToString\"] = function () {\n      abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"stringToAscii\")) Module[\"stringToAscii\"] = function () {\n      abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"UTF16ToString\")) Module[\"UTF16ToString\"] = function () {\n      abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"stringToUTF16\")) Module[\"stringToUTF16\"] = function () {\n      abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"lengthBytesUTF16\")) Module[\"lengthBytesUTF16\"] = function () {\n      abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"UTF32ToString\")) Module[\"UTF32ToString\"] = function () {\n      abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"stringToUTF32\")) Module[\"stringToUTF32\"] = function () {\n      abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"lengthBytesUTF32\")) Module[\"lengthBytesUTF32\"] = function () {\n      abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"allocateUTF8\")) Module[\"allocateUTF8\"] = function () {\n      abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    if (!_Object$getOwnPropertyDescriptor(Module, \"allocateUTF8OnStack\")) Module[\"allocateUTF8OnStack\"] = function () {\n      abort(\"'allocateUTF8OnStack' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    };\n    Module[\"writeStackCookie\"] = writeStackCookie;\n    Module[\"checkStackCookie\"] = checkStackCookie;\n    Module[\"abortStackOverflow\"] = abortStackOverflow;\n    if (!_Object$getOwnPropertyDescriptor(Module, \"ALLOC_NORMAL\")) _Object$defineProperty(Module, \"ALLOC_NORMAL\", {\n      configurable: true,\n      get: function get() {\n        abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!_Object$getOwnPropertyDescriptor(Module, \"ALLOC_STACK\")) _Object$defineProperty(Module, \"ALLOC_STACK\", {\n      configurable: true,\n      get: function get() {\n        abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!_Object$getOwnPropertyDescriptor(Module, \"ALLOC_DYNAMIC\")) _Object$defineProperty(Module, \"ALLOC_DYNAMIC\", {\n      configurable: true,\n      get: function get() {\n        abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!_Object$getOwnPropertyDescriptor(Module, \"ALLOC_NONE\")) _Object$defineProperty(Module, \"ALLOC_NONE\", {\n      configurable: true,\n      get: function get() {\n        abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n      }\n    });\n    if (!_Object$getOwnPropertyDescriptor(Module, \"calledRun\")) _Object$defineProperty(Module, \"calledRun\", {\n      configurable: true,\n      get: function get() {\n        abort(\"'calledRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n      }\n    });\n    var calledRun; // Modularize mode returns a function, which can be called to\n    // create instances. The instances provide a then() method,\n    // must like a Promise, that receives a callback. The callback\n    // is called when the module is ready to run, with the module\n    // as a parameter. (Like a Promise, it also returns the module\n    // so you can use the output of .then(..)).\n\n    Module['then'] = function (func) {\n      // We may already be ready to run code at this time. if\n      // so, just queue a call to the callback.\n      if (calledRun) {\n        func(Module);\n      } else {\n        // we are not ready to call then() yet. we must call it\n        // at the same time we would call onRuntimeInitialized.\n        var old = Module['onRuntimeInitialized'];\n\n        Module['onRuntimeInitialized'] = function () {\n          if (old) old();\n          func(Module);\n        };\n      }\n\n      return Module;\n    };\n    /**\n     * @constructor\n     * @this {ExitStatus}\n     */\n\n\n    function ExitStatus(status) {\n      this.name = \"ExitStatus\";\n      this.message = \"Program terminated with exit(\" + status + \")\";\n      this.status = status;\n    }\n\n    var calledMain = false;\n\n    dependenciesFulfilled = function runCaller() {\n      // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n    };\n\n    function callMain(args) {\n      assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])');\n      assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');\n      var entryFunction = Module['_main'];\n      args = args || [];\n      var argc = args.length + 1;\n      var argv = stackAlloc((argc + 1) * 4);\n      HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);\n\n      for (var i = 1; i < argc; i++) {\n        HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);\n      }\n\n      HEAP32[(argv >> 2) + argc] = 0;\n\n      try {\n        Module['___set_stack_limit'](STACK_MAX);\n        var ret = entryFunction(argc, argv); // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as execution is asynchronously handed\n        // off to a pthread.\n        // if we're not running an evented main loop, it's time to exit\n\n        exit(ret,\n        /* implicit = */\n        true);\n      } catch (e) {\n        if (e instanceof ExitStatus) {\n          // exit() throws this once it's done to make sure execution\n          // has been stopped completely\n          return;\n        } else if (e == 'unwind') {\n          // running an evented main loop, don't immediately exit\n          noExitRuntime = true;\n          return;\n        } else {\n          var toLog = e;\n\n          if (e && typeof e === 'object' && e.stack) {\n            toLog = [e, e.stack];\n          }\n\n          err('exception thrown: ' + toLog);\n          quit_(1, e);\n        }\n      } finally {\n        calledMain = true;\n      }\n    }\n    /** @type {function(Array=)} */\n\n\n    function run(args) {\n      args = args || arguments_;\n\n      if (runDependencies > 0) {\n        return;\n      }\n\n      writeStackCookie();\n      preRun();\n      if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n      function doRun() {\n        // run may have just been called through dependencies being fulfilled just in this very frame,\n        // or while the async setStatus time below was happening\n        if (calledRun) return;\n        calledRun = true;\n        if (ABORT) return;\n        initRuntime();\n        preMain();\n        if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n        if (shouldRunNow) callMain(args);\n        postRun();\n      }\n\n      if (Module['setStatus']) {\n        Module['setStatus']('Running...');\n        setTimeout(function () {\n          setTimeout(function () {\n            Module['setStatus']('');\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n\n      checkStackCookie();\n    }\n\n    Module['run'] = run;\n\n    function checkUnflushedContent() {\n      // Compiler settings do not allow exiting the runtime, so flushing\n      // the streams is not possible. but in ASSERTIONS mode we check\n      // if there was something to flush, and if so tell the user they\n      // should request that the runtime be exitable.\n      // Normally we would not even include flush() at all, but in ASSERTIONS\n      // builds we do so just for this check, and here we see if there is any\n      // content to flush, that is, we check if there would have been\n      // something a non-ASSERTIONS build would have not seen.\n      // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n      // mode (which has its own special function for this; otherwise, all\n      // the code is inside libc)\n      var print = out;\n      var printErr = err;\n      var has = false;\n\n      out = err = function err(x) {\n        has = true;\n      };\n\n      try {\n        // it doesn't matter if it fails\n        var flush = flush_NO_FILESYSTEM;\n        if (flush) flush(0);\n      } catch (e) {}\n\n      out = print;\n      err = printErr;\n\n      if (has) {\n        warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');\n        warnOnce('(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)');\n      }\n    }\n\n    function exit(status, implicit) {\n      checkUnflushedContent(); // if this is just main exit-ing implicitly, and the status is 0, then we\n      // don't need to do anything here and can just leave. if the status is\n      // non-zero, though, then we need to report it.\n      // (we may have warned about this earlier, if a situation justifies doing so)\n\n      if (implicit && noExitRuntime && status === 0) {\n        return;\n      }\n\n      if (noExitRuntime) {\n        // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n        if (!implicit) {\n          err('program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');\n        }\n      } else {\n        ABORT = true;\n        EXITSTATUS = status;\n        exitRuntime();\n        if (Module['onExit']) Module['onExit'](status);\n      }\n\n      quit_(status, new ExitStatus(status));\n    }\n\n    if (Module['preInit']) {\n      if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n\n      while (Module['preInit'].length > 0) {\n        Module['preInit'].pop()();\n      }\n    } // shouldRunNow refers to calling main(), not run().\n\n\n    var shouldRunNow = true;\n    if (Module['noInitialRun']) shouldRunNow = false;\n    noExitRuntime = true;\n    run(); // {{MODULE_ADDITIONS}}\n\n    return Module;\n  };\n}();\n\nif (typeof exports === 'object' && typeof module === 'object') module.exports = Module;else if (typeof define === 'function' && define['amd']) define([], function () {\n  return Module;\n});else if (typeof exports === 'object') exports[\"Module\"] = Module;","map":{"version":3,"sources":["/Users/shaobozhang/my_codes/my_next/public/hello.js"],"names":["Module","_scriptDir","document","currentScript","src","undefined","moduleOverrides","key","hasOwnProperty","arguments_","thisProgram","quit_","status","toThrow","ENVIRONMENT_IS_WEB","ENVIRONMENT_IS_WORKER","ENVIRONMENT_IS_NODE","ENVIRONMENT_IS_SHELL","Error","scriptDirectory","locateFile","path","read_","readAsync","readBinary","setWindowTitle","self","location","href","indexOf","substr","lastIndexOf","importScripts","shell_read","url","xhr","XMLHttpRequest","open","send","responseText","responseType","Uint8Array","response","onload","onerror","xhr_onload","title","out","console","log","bind","err","warn","configurable","get","abort","assert","IDBFS","PROXYFS","WORKERFS","NODEFS","STACK_ALIGN","stackSave","stackRestore","stackAlloc","staticAlloc","size","dynamicAlloc","DYNAMICTOP_PTR","ret","HEAP32","end","_emscripten_get_heap_size","alignMemory","factor","Math","ceil","getNativeTypeSize","type","length","bits","warnOnce","text","shown","convertJsFunctionToWasm","func","sig","WebAssembly","Function","typeNames","parameters","results","i","push","typeSection","sigRet","slice","sigParam","typeCodes","concat","bytes","module","instance","Instance","wrappedFunc","exports","addFunctionWasm","table","wasmTable","grow","RangeError","set","TypeError","wrapped","removeFunctionWasm","index","addFunction","removeFunction","funcWrappers","getFuncWrapper","sigCache","dynCall_wrapper","dynCall","arg","Array","prototype","call","arguments","makeBigInt","low","high","unsigned","ptr","args","substring","replace","apply","tempRet0","setTempRet0","value","getTempRet0","getCompilerSetting","name","Runtime","GLOBAL_BASE","wasmBinary","noExitRuntime","setValue","noSafe","charAt","HEAP8","HEAP16","tempI64","tempDouble","Math_abs","Math_min","Math_floor","Math_ceil","HEAPF32","HEAPF64","getValue","wasmMemory","Table","ABORT","EXITSTATUS","condition","getCFunc","ident","ccall","returnType","argTypes","opts","toC","str","len","stringToUTF8","arr","writeArrayToMemory","convertReturnValue","UTF8ToString","Boolean","cArgs","stack","converter","cwrap","ALLOC_NORMAL","ALLOC_STACK","ALLOC_DYNAMIC","ALLOC_NONE","allocate","slab","types","allocator","zeroinit","singleType","_malloc","max","stop","subarray","HEAPU8","typeSize","previousType","curr","getMemory","runtimeInitialized","UTF8Decoder","TextDecoder","UTF8ArrayToString","u8Array","idx","maxBytesToRead","endIdx","endPtr","decode","u0","String","fromCharCode","u1","u2","toString","ch","stringToUTF8Array","outU8Array","outIdx","maxBytesToWrite","startIdx","u","charCodeAt","outPtr","lengthBytesUTF8","AsciiToString","stringToAscii","writeAsciiToMemory","UTF16Decoder","UTF16ToString","codeUnit","stringToUTF16","startPtr","numCharsToWrite","lengthBytesUTF16","UTF32ToString","utf32","stringToUTF32","trailSurrogate","lengthBytesUTF32","allocateUTF8","allocateUTF8OnStack","writeStringToMemory","string","buffer","dontAddNull","lastChar","Infinity","array","PAGE_SIZE","WASM_PAGE_SIZE","ASMJS_PAGE_SIZE","alignUp","x","multiple","HEAP","HEAPU16","HEAPU32","updateGlobalBufferAndViews","buf","Int8Array","Int16Array","Int32Array","Uint16Array","Uint32Array","Float32Array","Float64Array","STATIC_BASE","STACK_BASE","STACKTOP","STACK_MAX","DYNAMIC_BASE","TOTAL_STACK","INITIAL_TOTAL_MEMORY","Memory","byteLength","writeStackCookie","checkStackCookie","cookie1","cookie2","abortStackOverflow","allocSize","h16","h8","abortFnPtrError","callRuntimeCallbacks","callbacks","callback","shift","__ATPRERUN__","__ATINIT__","__ATMAIN__","__ATEXIT__","__ATPOSTRUN__","runtimeExited","preRun","addOnPreRun","initRuntime","preMain","exitRuntime","postRun","addOnPostRun","cb","unshift","addOnInit","addOnPreMain","addOnExit","unSign","ignore","abs","pow","reSign","half","imul","fround","clz32","trunc","Math_cos","cos","Math_sin","sin","Math_tan","tan","Math_acos","acos","Math_asin","asin","Math_atan","atan","Math_atan2","atan2","Math_exp","exp","Math_log","Math_sqrt","sqrt","floor","Math_pow","Math_imul","Math_fround","Math_round","round","min","Math_max","Math_clz32","Math_trunc","runDependencies","runDependencyWatcher","dependenciesFulfilled","runDependencyTracking","getUniqueRunDependency","id","orig","random","addRunDependency","setInterval","clearInterval","dep","removeRunDependency","what","output","stackTrace","RuntimeError","memoryInitializer","FS","error","init","createDataFile","createPreloadedFile","createLazyFile","mkdev","registerDevice","analyzePath","loadFilesFromDB","ErrnoError","dataURIPrefix","isDataURI","filename","startsWith","wasmBinaryFile","getBinary","getBinaryPromise","fetch","credentials","then","resolve","reject","createWasm","info","asmLibraryArg","receiveInstance","trueModule","receiveInstantiatedSource","instantiateArrayBuffer","receiver","binary","instantiate","reason","instantiateAsync","instantiateStreaming","result","e","ASM_CONSTS","___wasm_call_ctors","demangle","demangleAll","regex","y","jsStackTrace","js","___handle_stack_overflow","___lock","___unlock","_emscripten_get_sbrk_ptr","_emscripten_memcpy_big","dest","num","abortOnCannotGrowMemory","requestedSize","_emscripten_resize_heap","flush_NO_FILESYSTEM","_fflush","buffers","SYSCALLS","printChar","PATH","splitPath","splitPathRe","exec","normalizeArray","parts","allowAboveRoot","up","last","splice","normalize","isAbsolute","trailingSlash","split","filter","p","join","dirname","root","dir","basename","lastSlash","extname","paths","join2","l","r","stream","varargs","getStr","get64","getZero","_fd_write","fd","iov","iovcnt","pnum","j","errno","_memcpy","aligned_dest_end","block_aligned_dest_end","dest_end","_memset","aligned_end","block_aligned_end","value4","_setTempRet0","$i","ASSERTIONS","intArrayFromString","stringy","u8array","numBytesWritten","intArrayToString","chr","asmGlobalArg","asm","_main","___errno_location","_setThrew","_free","___set_stack_limit","__growWasmMemory","dynCall_ii","dynCall_iiii","dynCall_jiji","dynCall_iidiiii","dynCall_vii","calledRun","old","ExitStatus","message","calledMain","runCaller","run","callMain","entryFunction","argc","argv","exit","toLog","doRun","shouldRunNow","setTimeout","checkUnflushedContent","print","printErr","has","flush","implicit","pop","define"],"mappings":";;;;;;;;AACA,IAAIA,MAAM,GAAI,YAAW;AACvB,MAAIC,UAAU,GAAG,OAAOC,QAAP,KAAoB,WAApB,IAAmCA,QAAQ,CAACC,aAA5C,GAA4DD,QAAQ,CAACC,aAAT,CAAuBC,GAAnF,GAAyFC,SAA1G;;AAEA,SACF,UAASL,MAAT,EAAiB;AACfA,IAAAA,MAAM,GAAGA,MAAM,IAAI,EAAnB,CADe,CAGjB;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAIA,MAAM,GAAG,OAAOA,MAAP,KAAkB,WAAlB,GAAgCA,MAAhC,GAAyC,EAAtD,CArBiB,CAuBjB;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA,QAAIM,eAAe,GAAG,EAAtB;AACA,QAAIC,GAAJ;;AACA,SAAKA,GAAL,IAAYP,MAAZ,EAAoB;AAClB,UAAIA,MAAM,CAACQ,cAAP,CAAsBD,GAAtB,CAAJ,EAAgC;AAC9BD,QAAAA,eAAe,CAACC,GAAD,CAAf,GAAuBP,MAAM,CAACO,GAAD,CAA7B;AACD;AACF;;AAED,QAAIE,UAAU,GAAG,EAAjB;AACA,QAAIC,WAAW,GAAG,gBAAlB;;AACA,QAAIC,KAAK,GAAG,eAASC,MAAT,EAAiBC,OAAjB,EAA0B;AACpC,YAAMA,OAAN;AACD,KAFD,CA1CiB,CA8CjB;AACA;;;AAEA,QAAIC,kBAAkB,GAAG,IAAzB;AACA,QAAIC,qBAAqB,GAAG,KAA5B;AACA,QAAIC,mBAAmB,GAAG,KAA1B;AACA,QAAIC,oBAAoB,GAAG,KAA3B;;AAEA,QAAIjB,MAAM,CAAC,aAAD,CAAV,EAA2B;AACzB,YAAM,IAAIkB,KAAJ,CAAU,oKAAV,CAAN;AACD,KAxDgB,CA4DjB;;;AACA,QAAIC,eAAe,GAAG,EAAtB;;AACA,aAASC,UAAT,CAAoBC,IAApB,EAA0B;AACxB,UAAIrB,MAAM,CAAC,YAAD,CAAV,EAA0B;AACxB,eAAOA,MAAM,CAAC,YAAD,CAAN,CAAqBqB,IAArB,EAA2BF,eAA3B,CAAP;AACD;;AACD,aAAOA,eAAe,GAAGE,IAAzB;AACD,KAnEgB,CAqEjB;;;AACA,QAAIC,KAAJ,EACIC,SADJ,EAEIC,UAFJ,EAGIC,cAHJ,CAtEiB,CA4EjB;AACA;AACA;;AACA,QAAIX,kBAAkB,IAAIC,qBAA1B,EAAiD;AAC/C,UAAIA,qBAAJ,EAA2B;AAAE;AAC3BI,QAAAA,eAAe,GAAGO,IAAI,CAACC,QAAL,CAAcC,IAAhC;AACD,OAFD,MAEO,IAAI1B,QAAQ,CAACC,aAAb,EAA4B;AAAE;AACnCgB,QAAAA,eAAe,GAAGjB,QAAQ,CAACC,aAAT,CAAuBC,GAAzC;AACD,OAL8C,CAM/C;AACA;;;AACA,UAAIH,UAAJ,EAAgB;AACdkB,QAAAA,eAAe,GAAGlB,UAAlB;AACD,OAV8C,CAW/C;AACA;AACA;AACA;;;AACA,UAAIkB,eAAe,CAACU,OAAhB,CAAwB,OAAxB,MAAqC,CAAzC,EAA4C;AAC1CV,QAAAA,eAAe,GAAGA,eAAe,CAACW,MAAhB,CAAuB,CAAvB,EAA0BX,eAAe,CAACY,WAAhB,CAA4B,GAA5B,IAAiC,CAA3D,CAAlB;AACD,OAFD,MAEO;AACLZ,QAAAA,eAAe,GAAG,EAAlB;AACD;;AAED,UAAI,EAAE,QAA8B,OAAOa,aAAP,KAAyB,UAAzD,CAAJ,EAA0E,MAAM,IAAId,KAAJ,CAAU,wLAAV,CAAN,CArB3B,CAuB/C;AACA;;AACA;AAGAI,QAAAA,KAAK,GAAG,SAASW,UAAT,CAAoBC,GAApB,EAAyB;AAC7B,cAAIC,GAAG,GAAG,IAAIC,cAAJ,EAAV;AACAD,UAAAA,GAAG,CAACE,IAAJ,CAAS,KAAT,EAAgBH,GAAhB,EAAqB,KAArB;AACAC,UAAAA,GAAG,CAACG,IAAJ,CAAS,IAAT;AACA,iBAAOH,GAAG,CAACI,YAAX;AACH,SALD;;AAOA,YAAIxB,qBAAJ,EAA2B;AACzBS,UAAAA,UAAU,GAAG,SAASA,UAAT,CAAoBU,GAApB,EAAyB;AAClC,gBAAIC,GAAG,GAAG,IAAIC,cAAJ,EAAV;AACAD,YAAAA,GAAG,CAACE,IAAJ,CAAS,KAAT,EAAgBH,GAAhB,EAAqB,KAArB;AACAC,YAAAA,GAAG,CAACK,YAAJ,GAAmB,aAAnB;AACAL,YAAAA,GAAG,CAACG,IAAJ,CAAS,IAAT;AACA,mBAAO,IAAIG,UAAJ,CAAeN,GAAG,CAACO,QAAnB,CAAP;AACH,WAND;AAOD;;AAEDnB,QAAAA,SAAS,GAAG,SAASA,SAAT,CAAmBW,GAAnB,EAAwBS,MAAxB,EAAgCC,OAAhC,EAAyC;AACnD,cAAIT,GAAG,GAAG,IAAIC,cAAJ,EAAV;AACAD,UAAAA,GAAG,CAACE,IAAJ,CAAS,KAAT,EAAgBH,GAAhB,EAAqB,IAArB;AACAC,UAAAA,GAAG,CAACK,YAAJ,GAAmB,aAAnB;;AACAL,UAAAA,GAAG,CAACQ,MAAJ,GAAa,SAASE,UAAT,GAAsB;AACjC,gBAAIV,GAAG,CAACvB,MAAJ,IAAc,GAAd,IAAsBuB,GAAG,CAACvB,MAAJ,IAAc,CAAd,IAAmBuB,GAAG,CAACO,QAAjD,EAA4D;AAAE;AAC5DC,cAAAA,MAAM,CAACR,GAAG,CAACO,QAAL,CAAN;AACA;AACD;;AACDE,YAAAA,OAAO;AACR,WAND;;AAOAT,UAAAA,GAAG,CAACS,OAAJ,GAAcA,OAAd;AACAT,UAAAA,GAAG,CAACG,IAAJ,CAAS,IAAT;AACD,SAbD;AAkBC;;AAEDb,MAAAA,cAAc,GAAG,wBAASqB,KAAT,EAAgB;AAAE5C,QAAAA,QAAQ,CAAC4C,KAAT,GAAiBA,KAAjB;AAAwB,OAA3D;AACD,KAlED,MAmEA;AACE,YAAM,IAAI5B,KAAJ,CAAU,6BAAV,CAAN;AACD,KApJgB,CAuJjB;AACA;;;AACA,QAAI6B,GAAG,GAAG/C,MAAM,CAAC,OAAD,CAAN,IAAmBgD,OAAO,CAACC,GAAR,CAAYC,IAAZ,CAAiBF,OAAjB,CAA7B;AACA,QAAIG,GAAG,GAAGnD,MAAM,CAAC,UAAD,CAAN,IAAsBgD,OAAO,CAACI,IAAR,CAAaF,IAAb,CAAkBF,OAAlB,CAAhC,CA1JiB,CA4JjB;;AACA,SAAKzC,GAAL,IAAYD,eAAZ,EAA6B;AAC3B,UAAIA,eAAe,CAACE,cAAhB,CAA+BD,GAA/B,CAAJ,EAAyC;AACvCP,QAAAA,MAAM,CAACO,GAAD,CAAN,GAAcD,eAAe,CAACC,GAAD,CAA7B;AACD;AACF,KAjKgB,CAkKjB;AACA;;;AACAD,IAAAA,eAAe,GAAG,IAAlB,CApKiB,CAsKjB;AACA;AACA;AACA;;AACA,QAAIN,MAAM,CAAC,WAAD,CAAV,EAAyBS,UAAU,GAAGT,MAAM,CAAC,WAAD,CAAnB;AAAiC,QAAI,CAAC,iCAAgCA,MAAhC,EAAwC,WAAxC,CAAL,EAA2D,uBAAsBA,MAAtB,EAA8B,WAA9B,EAA2C;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,0DAAD,CAAL;AAAmE;AAA3G,KAA3C;AACrH,QAAIvD,MAAM,CAAC,aAAD,CAAV,EAA2BU,WAAW,GAAGV,MAAM,CAAC,aAAD,CAApB;AAAoC,QAAI,CAAC,iCAAgCA,MAAhC,EAAwC,aAAxC,CAAL,EAA6D,uBAAsBA,MAAtB,EAA8B,aAA9B,EAA6C;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,6DAAD,CAAL;AAAsE;AAA9G,KAA7C;AAC5H,QAAIvD,MAAM,CAAC,MAAD,CAAV,EAAoBW,KAAK,GAAGX,MAAM,CAAC,MAAD,CAAd;AAAuB,QAAI,CAAC,iCAAgCA,MAAhC,EAAwC,MAAxC,CAAL,EAAsD,uBAAsBA,MAAtB,EAA8B,MAA9B,EAAsC;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,gDAAD,CAAL;AAAyD;AAAjG,KAAtC,EA5KhF,CA8KjB;AACA;;AACAC,IAAAA,MAAM,CAAC,OAAOxD,MAAM,CAAC,4BAAD,CAAb,KAAgD,WAAjD,EAA8D,qFAA9D,CAAN;AACAwD,IAAAA,MAAM,CAAC,OAAOxD,MAAM,CAAC,sBAAD,CAAb,KAA0C,WAA3C,EAAwD,+EAAxD,CAAN;AACAwD,IAAAA,MAAM,CAAC,OAAOxD,MAAM,CAAC,wBAAD,CAAb,KAA4C,WAA7C,EAA0D,iFAA1D,CAAN;AACAwD,IAAAA,MAAM,CAAC,OAAOxD,MAAM,CAAC,sBAAD,CAAb,KAA0C,WAA3C,EAAwD,+EAAxD,CAAN;AACAwD,IAAAA,MAAM,CAAC,OAAOxD,MAAM,CAAC,MAAD,CAAb,KAA0B,WAA3B,EAAwC,qDAAxC,CAAN;AACAwD,IAAAA,MAAM,CAAC,OAAOxD,MAAM,CAAC,WAAD,CAAb,KAA+B,WAAhC,EAA6C,8DAA7C,CAAN;AACAwD,IAAAA,MAAM,CAAC,OAAOxD,MAAM,CAAC,YAAD,CAAb,KAAgC,WAAjC,EAA8C,gEAA9C,CAAN;AACAwD,IAAAA,MAAM,CAAC,OAAOxD,MAAM,CAAC,gBAAD,CAAb,KAAoC,WAArC,EAAkD,wEAAlD,CAAN;AACA,QAAI,CAAC,iCAAgCA,MAAhC,EAAwC,MAAxC,CAAL,EAAsD,uBAAsBA,MAAtB,EAA8B,MAA9B,EAAsC;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,gDAAD,CAAL;AAAyD;AAAjG,KAAtC;AACtD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,WAAxC,CAAL,EAA2D,uBAAsBA,MAAtB,EAA8B,WAA9B,EAA2C;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,yDAAD,CAAL;AAAkE;AAA1G,KAA3C;AAC3D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,YAAxC,CAAL,EAA4D,uBAAsBA,MAAtB,EAA8B,YAA9B,EAA4C;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,2DAAD,CAAL;AAAoE;AAA5G,KAA5C,EA1L3C,CA2LjB;;AACA,QAAIE,KAAK,GAAG,+DAAZ;AACA,QAAIC,OAAO,GAAG,mEAAd;AACA,QAAIC,QAAQ,GAAG,qEAAf;AACA,QAAIC,MAAM,GAAG,iEAAb,CA/LiB,CAkMjB;AAIA;AACA;AACA;AACA;AAEA;;AAEA,QAAIC,WAAW,GAAG,EAAlB,CA7MiB,CA+MjB;AACA;;AACAC,IAAAA,SAAS,GAAGC,YAAY,GAAGC,UAAU,GAAG,sBAAW;AACjDT,MAAAA,KAAK,CAAC,0FAAD,CAAL;AACD,KAFD;;AAIA,aAASU,WAAT,CAAqBC,IAArB,EAA2B;AACzBX,MAAAA,KAAK,CAAC,4HAAD,CAAL;AACD;;AAED,aAASY,YAAT,CAAsBD,IAAtB,EAA4B;AAC1BV,MAAAA,MAAM,CAACY,cAAD,CAAN;AACA,UAAIC,GAAG,GAAGC,MAAM,CAACF,cAAc,IAAE,CAAjB,CAAhB;AACA,UAAIG,GAAG,GAAIF,GAAG,GAAGH,IAAN,GAAa,EAAd,GAAoB,CAAC,EAA/B;;AACA,UAAIK,GAAG,GAAGC,yBAAyB,EAAnC,EAAuC;AACrCjB,QAAAA,KAAK,CAAC,gGAAD,CAAL;AACD;;AACDe,MAAAA,MAAM,CAACF,cAAc,IAAE,CAAjB,CAAN,GAA4BG,GAA5B;AACA,aAAOF,GAAP;AACD;;AAED,aAASI,WAAT,CAAqBP,IAArB,EAA2BQ,MAA3B,EAAmC;AACjC,UAAI,CAACA,MAAL,EAAaA,MAAM,GAAGb,WAAT,CADoB,CACE;;AACnC,aAAOc,IAAI,CAACC,IAAL,CAAUV,IAAI,GAAGQ,MAAjB,IAA2BA,MAAlC;AACD;;AAED,aAASG,iBAAT,CAA2BC,IAA3B,EAAiC;AAC/B,cAAQA,IAAR;AACE,aAAK,IAAL;AAAW,aAAK,IAAL;AAAW,iBAAO,CAAP;;AACtB,aAAK,KAAL;AAAY,iBAAO,CAAP;;AACZ,aAAK,KAAL;AAAY,iBAAO,CAAP;;AACZ,aAAK,KAAL;AAAY,iBAAO,CAAP;;AACZ,aAAK,OAAL;AAAc,iBAAO,CAAP;;AACd,aAAK,QAAL;AAAe,iBAAO,CAAP;;AACf;AAAS;AACP,gBAAIA,IAAI,CAACA,IAAI,CAACC,MAAL,GAAY,CAAb,CAAJ,KAAwB,GAA5B,EAAiC;AAC/B,qBAAO,CAAP,CAD+B,CACrB;AACX,aAFD,MAEO,IAAID,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAhB,EAAqB;AAC1B,kBAAIE,IAAI,GAAG,UAASF,IAAI,CAAChD,MAAL,CAAY,CAAZ,CAAT,CAAX;;AACA0B,cAAAA,MAAM,CAACwB,IAAI,GAAG,CAAP,KAAa,CAAd,EAAiB,oCAAoCA,IAApC,GAA2C,SAA3C,GAAuDF,IAAxE,CAAN;AACA,qBAAOE,IAAI,GAAG,CAAd;AACD,aAJM,MAIA;AACL,qBAAO,CAAP;AACD;AACF;AAjBH;AAmBD;;AAED,aAASC,QAAT,CAAkBC,IAAlB,EAAwB;AACtB,UAAI,CAACD,QAAQ,CAACE,KAAd,EAAqBF,QAAQ,CAACE,KAAT,GAAiB,EAAjB;;AACrB,UAAI,CAACF,QAAQ,CAACE,KAAT,CAAeD,IAAf,CAAL,EAA2B;AACzBD,QAAAA,QAAQ,CAACE,KAAT,CAAeD,IAAf,IAAuB,CAAvB;AACA/B,QAAAA,GAAG,CAAC+B,IAAD,CAAH;AACD;AACF,KArQgB,CA4QjB;;;AACA,aAASE,uBAAT,CAAiCC,IAAjC,EAAuCC,GAAvC,EAA4C;AAE1C;AACA;AACA;AACA;AACA,UAAI,OAAOC,WAAW,CAACC,QAAnB,KAAgC,UAApC,EAAgD;AAC9C,YAAIC,SAAS,GAAG;AACd,eAAK,KADS;AAEd,eAAK,KAFS;AAGd,eAAK,KAHS;AAId,eAAK;AAJS,SAAhB;AAMA,YAAIX,IAAI,GAAG;AACTY,UAAAA,UAAU,EAAE,EADH;AAETC,UAAAA,OAAO,EAAEL,GAAG,CAAC,CAAD,CAAH,IAAU,GAAV,GAAgB,EAAhB,GAAqB,CAACG,SAAS,CAACH,GAAG,CAAC,CAAD,CAAJ,CAAV;AAFrB,SAAX;;AAIA,aAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,GAAG,CAACP,MAAxB,EAAgC,EAAEa,CAAlC,EAAqC;AACnCd,UAAAA,IAAI,CAACY,UAAL,CAAgBG,IAAhB,CAAqBJ,SAAS,CAACH,GAAG,CAACM,CAAD,CAAJ,CAA9B;AACD;;AACD,eAAO,IAAIL,WAAW,CAACC,QAAhB,CAAyBV,IAAzB,EAA+BO,IAA/B,CAAP;AACD,OArByC,CAuB1C;AACA;;;AACA,UAAIS,WAAW,GAAG,CAChB,IADgB,EACV;AACN,UAFgB,EAEV;AACN,UAHgB,EAGV;AACN,UAJgB,CAIV;AAJU,OAAlB;AAMA,UAAIC,MAAM,GAAGT,GAAG,CAACU,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAb;AACA,UAAIC,QAAQ,GAAGX,GAAG,CAACU,KAAJ,CAAU,CAAV,CAAf;AACA,UAAIE,SAAS,GAAG;AACd,aAAK,IADS;AACH;AACX,aAAK,IAFS;AAEH;AACX,aAAK,IAHS;AAGH;AACX,aAAK,IAJS,CAIH;;AAJG,OAAhB,CAjC0C,CAwC1C;;AACAJ,MAAAA,WAAW,CAACD,IAAZ,CAAiBI,QAAQ,CAAClB,MAA1B;;AACA,WAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGK,QAAQ,CAAClB,MAA7B,EAAqC,EAAEa,CAAvC,EAA0C;AACxCE,QAAAA,WAAW,CAACD,IAAZ,CAAiBK,SAAS,CAACD,QAAQ,CAACL,CAAD,CAAT,CAA1B;AACD,OA5CyC,CA8C1C;AACA;;;AACA,UAAIG,MAAM,IAAI,GAAd,EAAmB;AACjBD,QAAAA,WAAW,CAACD,IAAZ,CAAiB,IAAjB;AACD,OAFD,MAEO;AACLC,QAAAA,WAAW,GAAGA,WAAW,CAACK,MAAZ,CAAmB,CAAC,IAAD,EAAOD,SAAS,CAACH,MAAD,CAAhB,CAAnB,CAAd;AACD,OApDyC,CAsD1C;AACA;;;AACAD,MAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAACf,MAAZ,GAAqB,CAAtC,CAxD0C,CA0D1C;;AACA,UAAIqB,KAAK,GAAG,IAAI3D,UAAJ,CAAe,CACzB,IADyB,EACnB,IADmB,EACb,IADa,EACP,IADO,EACD;AACxB,UAFyB,EAEnB,IAFmB,EAEb,IAFa,EAEP,IAFO,CAED;AAFC,QAGzB0D,MAHyB,CAGlBL,WAHkB,EAGL,CACpB,IADoB,EACd,IADc,EACR;AACV;AACA,UAHkB,EAGZ,IAHY,EAGN,IAHM,EAGA,IAHA,EAGM,IAHN,EAGY,IAHZ,EAGkB,IAHlB,EAIpB,IAJoB,EAId,IAJc,EAIR;AACV;AACA,UANkB,EAMZ,IANY,EAMN,IANM,EAMA,IANA,EAMM,IANN,CAHK,CAAf,CAAZ,CA3D0C,CAuEzC;AACD;;AACA,UAAIO,MAAM,GAAG,IAAId,WAAW,CAACvF,MAAhB,CAAuBoG,KAAvB,CAAb;AACA,UAAIE,QAAQ,GAAG,IAAIf,WAAW,CAACgB,QAAhB,CAAyBF,MAAzB,EAAiC;AAC9C,aAAK;AACH,eAAKhB;AADF;AADyC,OAAjC,CAAf;AAKA,UAAImB,WAAW,GAAGF,QAAQ,CAACG,OAAT,CAAiB,GAAjB,CAAlB;AACA,aAAOD,WAAP;AACD,KA9VgB,CAgWjB;;;AACA,aAASE,eAAT,CAAyBrB,IAAzB,EAA+BC,GAA/B,EAAoC;AAClC,UAAIqB,KAAK,GAAGC,SAAZ;AACA,UAAIvC,GAAG,GAAGsC,KAAK,CAAC5B,MAAhB,CAFkC,CAIlC;;AACA,UAAI;AACF4B,QAAAA,KAAK,CAACE,IAAN,CAAW,CAAX;AACD,OAFD,CAEE,OAAO1D,GAAP,EAAY;AACZ,YAAI,EAAEA,GAAG,YAAY2D,UAAjB,CAAJ,EAAkC;AAChC,gBAAM3D,GAAN;AACD;;AACD,cAAM,yGAAN;AACD,OAZiC,CAclC;;;AACA,UAAI;AACF;AACAwD,QAAAA,KAAK,CAACI,GAAN,CAAU1C,GAAV,EAAegB,IAAf;AACD,OAHD,CAGE,OAAOlC,GAAP,EAAY;AACZ,YAAI,EAAEA,GAAG,YAAY6D,SAAjB,CAAJ,EAAiC;AAC/B,gBAAM7D,GAAN;AACD;;AACDK,QAAAA,MAAM,CAAC,OAAO8B,GAAP,KAAe,WAAhB,EAA6B,2CAA7B,CAAN;AACA,YAAI2B,OAAO,GAAG7B,uBAAuB,CAACC,IAAD,EAAOC,GAAP,CAArC;AACAqB,QAAAA,KAAK,CAACI,GAAN,CAAU1C,GAAV,EAAe4C,OAAf;AACD;;AAED,aAAO5C,GAAP;AACD;;AAED,aAAS6C,kBAAT,CAA4BC,KAA5B,EAAmC,CAElC,CAFD,CACE;AAGF;AACA;;;AACA,aAASC,WAAT,CAAqB/B,IAArB,EAA2BC,GAA3B,EAAgC;AAC9B9B,MAAAA,MAAM,CAAC,OAAO6B,IAAP,KAAgB,WAAjB,CAAN;AAEA,aAAOqB,eAAe,CAACrB,IAAD,EAAOC,GAAP,CAAtB;AACD;;AAED,aAAS+B,cAAT,CAAwBF,KAAxB,EAA+B;AAC7BD,MAAAA,kBAAkB,CAACC,KAAD,CAAlB;AACD;;AAID,QAAIG,YAAY,GAAG,EAAnB;;AAEA,aAASC,cAAT,CAAwBlC,IAAxB,EAA8BC,GAA9B,EAAmC;AACjC,UAAI,CAACD,IAAL,EAAW,OADsB,CACd;;AACnB7B,MAAAA,MAAM,CAAC8B,GAAD,CAAN;;AACA,UAAI,CAACgC,YAAY,CAAChC,GAAD,CAAjB,EAAwB;AACtBgC,QAAAA,YAAY,CAAChC,GAAD,CAAZ,GAAoB,EAApB;AACD;;AACD,UAAIkC,QAAQ,GAAGF,YAAY,CAAChC,GAAD,CAA3B;;AACA,UAAI,CAACkC,QAAQ,CAACnC,IAAD,CAAb,EAAqB;AACnB;AACA,YAAIC,GAAG,CAACP,MAAJ,KAAe,CAAnB,EAAsB;AACpByC,UAAAA,QAAQ,CAACnC,IAAD,CAAR,GAAiB,SAASoC,eAAT,GAA2B;AAC1C,mBAAOC,OAAO,CAACpC,GAAD,EAAMD,IAAN,CAAd;AACD,WAFD;AAGD,SAJD,MAIO,IAAIC,GAAG,CAACP,MAAJ,KAAe,CAAnB,EAAsB;AAC3ByC,UAAAA,QAAQ,CAACnC,IAAD,CAAR,GAAiB,SAASoC,eAAT,CAAyBE,GAAzB,EAA8B;AAC7C,mBAAOD,OAAO,CAACpC,GAAD,EAAMD,IAAN,EAAY,CAACsC,GAAD,CAAZ,CAAd;AACD,WAFD;AAGD,SAJM,MAIA;AACL;AACAH,UAAAA,QAAQ,CAACnC,IAAD,CAAR,GAAiB,SAASoC,eAAT,GAA2B;AAC1C,mBAAOC,OAAO,CAACpC,GAAD,EAAMD,IAAN,EAAYuC,KAAK,CAACC,SAAN,CAAgB7B,KAAhB,CAAsB8B,IAAtB,CAA2BC,SAA3B,CAAZ,CAAd;AACD,WAFD;AAGD;AACF;;AACD,aAAOP,QAAQ,CAACnC,IAAD,CAAf;AACD;;AAGD,aAAS2C,UAAT,CAAoBC,GAApB,EAAyBC,IAAzB,EAA+BC,QAA/B,EAAyC;AACvC,aAAOA,QAAQ,GAAK,EAAGF,GAAG,KAAG,CAAT,CAAD,GAAiB,EAAGC,IAAI,KAAG,CAAV,CAAD,GAAgB,YAApC,GAAuD,EAAGD,GAAG,KAAG,CAAT,CAAD,GAAiB,EAAGC,IAAI,GAAC,CAAR,CAAD,GAAc,YAAnG;AACD;;AAED,aAASR,OAAT,CAAiBpC,GAAjB,EAAsB8C,GAAtB,EAA2BC,IAA3B,EAAiC;AAC/B,UAAIA,IAAI,IAAIA,IAAI,CAACtD,MAAjB,EAAyB;AACvB;AACAvB,QAAAA,MAAM,CAAC6E,IAAI,CAACtD,MAAL,KAAgBO,GAAG,CAACgD,SAAJ,CAAc,CAAd,EAAiBC,OAAjB,CAAyB,IAAzB,EAA+B,IAA/B,EAAqCxD,MAAtD,CAAN;AACAvB,QAAAA,MAAM,CAAE,aAAa8B,GAAd,IAAsBtF,MAAvB,EAA+B,oDAAoDsF,GAApD,GAA0D,IAAzF,CAAN;AACA,eAAOtF,MAAM,CAAC,aAAasF,GAAd,CAAN,CAAyBkD,KAAzB,CAA+B,IAA/B,EAAqC,CAACJ,GAAD,EAAMjC,MAAN,CAAakC,IAAb,CAArC,CAAP;AACD,OALD,MAKO;AACL7E,QAAAA,MAAM,CAAC8B,GAAG,CAACP,MAAJ,IAAc,CAAf,CAAN;AACAvB,QAAAA,MAAM,CAAE,aAAa8B,GAAd,IAAsBtF,MAAvB,EAA+B,oDAAoDsF,GAApD,GAA0D,IAAzF,CAAN;AACA,eAAOtF,MAAM,CAAC,aAAasF,GAAd,CAAN,CAAyBwC,IAAzB,CAA8B,IAA9B,EAAoCM,GAApC,CAAP;AACD;AACF;;AAED,QAAIK,QAAQ,GAAG,CAAf;;AAEA,QAAIC,WAAW,GAAG,SAAdA,WAAc,CAASC,KAAT,EAAgB;AAChCF,MAAAA,QAAQ,GAAGE,KAAX;AACD,KAFD;;AAIA,QAAIC,WAAW,GAAG,SAAdA,WAAc,GAAW;AAC3B,aAAOH,QAAP;AACD,KAFD;;AAIA,aAASI,kBAAT,CAA4BC,IAA5B,EAAkC;AAChC,YAAM,qHAAN;AACD;;AAED,QAAIC,OAAO,GAAG;AACZ;AACAH,MAAAA,WAAW,EAAE,uBAAW;AAAErF,QAAAA,KAAK,CAAC,iGAAD,CAAL;AAA0G,OAFxH;AAGZU,MAAAA,WAAW,EAAE,uBAAW;AAAEV,QAAAA,KAAK,CAAC,iGAAD,CAAL;AAA0G,OAHxH;AAIZS,MAAAA,UAAU,EAAE,sBAAW;AAAET,QAAAA,KAAK,CAAC,gGAAD,CAAL;AAAyG;AAJtH,KAAd,CA9ciB,CAqdjB;AACA;AACA;AACA;;AACA,QAAIyF,WAAW,GAAG,IAAlB,CAzdiB,CA8djB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,QAAIC,UAAJ;AAAe,QAAIjJ,MAAM,CAAC,YAAD,CAAV,EAA0BiJ,UAAU,GAAGjJ,MAAM,CAAC,YAAD,CAAnB;AAAkC,QAAI,CAAC,iCAAgCA,MAAhC,EAAwC,YAAxC,CAAL,EAA4D,uBAAsBA,MAAtB,EAA8B,YAA9B,EAA4C;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,2DAAD,CAAL;AAAoE;AAA5G,KAA5C;AACvI,QAAI2F,aAAJ;AAAkB,QAAIlJ,MAAM,CAAC,eAAD,CAAV,EAA6BkJ,aAAa,GAAGlJ,MAAM,CAAC,eAAD,CAAtB;AAAwC,QAAI,CAAC,iCAAgCA,MAAhC,EAAwC,eAAxC,CAAL,EAA+D,uBAAsBA,MAAtB,EAA8B,eAA9B,EAA+C;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,iEAAD,CAAL;AAA0E;AAAlH,KAA/C;;AAGtJ,QAAI,OAAOgC,WAAP,KAAuB,QAA3B,EAAqC;AACnChC,MAAAA,KAAK,CAAC,kFAAD,CAAL;AACD,KA/egB,CAkfjB;AACA;;AAEA;;;AACA,aAAS4F,QAAT,CAAkBf,GAAlB,EAAuBO,KAAvB,EAA8B7D,IAA9B,EAAoCsE,MAApC,EAA4C;AAC1CtE,MAAAA,IAAI,GAAGA,IAAI,IAAI,IAAf;AACA,UAAIA,IAAI,CAACuE,MAAL,CAAYvE,IAAI,CAACC,MAAL,GAAY,CAAxB,MAA+B,GAAnC,EAAwCD,IAAI,GAAG,KAAP,CAFE,CAEY;;AACpD,cAAOA,IAAP;AACE,aAAK,IAAL;AAAWwE,UAAAA,KAAK,CAAGlB,GAAD,IAAO,CAAT,CAAL,GAAkBO,KAAlB;AAAyB;;AACpC,aAAK,IAAL;AAAWW,UAAAA,KAAK,CAAGlB,GAAD,IAAO,CAAT,CAAL,GAAkBO,KAAlB;AAAyB;;AACpC,aAAK,KAAL;AAAYY,UAAAA,MAAM,CAAGnB,GAAD,IAAO,CAAT,CAAN,GAAmBO,KAAnB;AAA0B;;AACtC,aAAK,KAAL;AAAYrE,UAAAA,MAAM,CAAG8D,GAAD,IAAO,CAAT,CAAN,GAAmBO,KAAnB;AAA0B;;AACtC,aAAK,KAAL;AAAaa,UAAAA,OAAO,GAAG,CAACb,KAAK,KAAG,CAAT,GAAYc,UAAU,GAACd,KAAX,EAAkB,CAAEe,QAAQ,CAACD,UAAD,CAAX,IAA6B,GAA7B,GAAoCA,UAAU,GAAG,GAAb,GAAmB,CAAEE,QAAQ,CAAE,CAAEC,UAAU,CAAEH,UAAD,GAAa,YAAd,CAAd,EAA6C,YAA7C,CAAT,GAAqE,CAAtE,MAA2E,CAA9F,GAAmG,CAAC,CAAG,CAAEI,SAAS,CAAC,CAACJ,UAAU,GAAG,EAAI,CAAC,CAAEA,UAAL,KAAqB,CAAvB,CAAd,IAAyC,YAA1C,CAAhB,KAA8E,CAApN,GAAyN,CAAtP,EAAV,EAAoQnF,MAAM,CAAG8D,GAAD,IAAO,CAAT,CAAN,GAAmBoB,OAAO,CAAC,CAAD,CAA9R,EAAkSlF,MAAM,CAAI8D,GAAD,GAAO,CAAR,IAAa,CAAf,CAAN,GAAyBoB,OAAO,CAAC,CAAD,CAAnU;AAAyU;;AACrV,aAAK,OAAL;AAAcM,UAAAA,OAAO,CAAG1B,GAAD,IAAO,CAAT,CAAP,GAAoBO,KAApB;AAA2B;;AACzC,aAAK,QAAL;AAAeoB,UAAAA,OAAO,CAAG3B,GAAD,IAAO,CAAT,CAAP,GAAoBO,KAApB;AAA2B;;AAC1C;AAASpF,UAAAA,KAAK,CAAC,gCAAgCuB,IAAjC,CAAL;AARX;AAUH;AAED;;;AACA,aAASkF,QAAT,CAAkB5B,GAAlB,EAAuBtD,IAAvB,EAA6BsE,MAA7B,EAAqC;AACnCtE,MAAAA,IAAI,GAAGA,IAAI,IAAI,IAAf;AACA,UAAIA,IAAI,CAACuE,MAAL,CAAYvE,IAAI,CAACC,MAAL,GAAY,CAAxB,MAA+B,GAAnC,EAAwCD,IAAI,GAAG,KAAP,CAFL,CAEmB;;AACpD,cAAOA,IAAP;AACE,aAAK,IAAL;AAAW,iBAAOwE,KAAK,CAAGlB,GAAD,IAAO,CAAT,CAAZ;;AACX,aAAK,IAAL;AAAW,iBAAOkB,KAAK,CAAGlB,GAAD,IAAO,CAAT,CAAZ;;AACX,aAAK,KAAL;AAAY,iBAAOmB,MAAM,CAAGnB,GAAD,IAAO,CAAT,CAAb;;AACZ,aAAK,KAAL;AAAY,iBAAO9D,MAAM,CAAG8D,GAAD,IAAO,CAAT,CAAb;;AACZ,aAAK,KAAL;AAAY,iBAAO9D,MAAM,CAAG8D,GAAD,IAAO,CAAT,CAAb;;AACZ,aAAK,OAAL;AAAc,iBAAO0B,OAAO,CAAG1B,GAAD,IAAO,CAAT,CAAd;;AACd,aAAK,QAAL;AAAe,iBAAO2B,OAAO,CAAG3B,GAAD,IAAO,CAAT,CAAd;;AACf;AAAS7E,UAAAA,KAAK,CAAC,gCAAgCuB,IAAjC,CAAL;AARX;;AAUF,aAAO,IAAP;AACD,KAphBgB,CA0hBjB;;;AAEA,QAAImF,UAAJ,CA5hBiB,CA8hBjB;AACA;AACA;;AACA,QAAIrD,SAAS,GAAG,IAAIrB,WAAW,CAAC2E,KAAhB,CAAsB;AACpC,iBAAW,CADyB;AAEpC,iBAAW,IAAI,CAFqB;AAGpC,iBAAW;AAHyB,KAAtB,CAAhB,CAjiBiB,CAwiBjB;AACA;AACA;AAEA;AACA;;AACA,QAAIC,KAAK,GAAG,KAAZ,CA9iBiB,CAgjBjB;AACA;AACA;;AACA,QAAIC,UAAU,GAAG,CAAjB;AAEA;;AACA,aAAS5G,MAAT,CAAgB6G,SAAhB,EAA2BnF,IAA3B,EAAiC;AAC/B,UAAI,CAACmF,SAAL,EAAgB;AACd9G,QAAAA,KAAK,CAAC,uBAAuB2B,IAAxB,CAAL;AACD;AACF,KA1jBgB,CA4jBjB;;;AACA,aAASoF,QAAT,CAAkBC,KAAlB,EAAyB;AACvB,UAAIlF,IAAI,GAAGrF,MAAM,CAAC,MAAMuK,KAAP,CAAjB,CADuB,CACS;;AAChC/G,MAAAA,MAAM,CAAC6B,IAAD,EAAO,kCAAkCkF,KAAlC,GAA0C,4BAAjD,CAAN;AACA,aAAOlF,IAAP;AACD,KAjkBgB,CAmkBjB;;;AACA,aAASmF,KAAT,CAAeD,KAAf,EAAsBE,UAAtB,EAAkCC,QAAlC,EAA4CrC,IAA5C,EAAkDsC,IAAlD,EAAwD;AACtD;AACA,UAAIC,GAAG,GAAG;AACR,kBAAU,gBAASC,GAAT,EAAc;AACtB,cAAIxG,GAAG,GAAG,CAAV;;AACA,cAAIwG,GAAG,KAAK,IAAR,IAAgBA,GAAG,KAAKxK,SAAxB,IAAqCwK,GAAG,KAAK,CAAjD,EAAoD;AAAE;AACpD;AACA,gBAAIC,GAAG,GAAG,CAACD,GAAG,CAAC9F,MAAJ,IAAc,CAAf,IAAoB,CAA9B;AACAV,YAAAA,GAAG,GAAGL,UAAU,CAAC8G,GAAD,CAAhB;AACAC,YAAAA,YAAY,CAACF,GAAD,EAAMxG,GAAN,EAAWyG,GAAX,CAAZ;AACD;;AACD,iBAAOzG,GAAP;AACD,SAVO;AAWR,iBAAS,eAAS2G,GAAT,EAAc;AACrB,cAAI3G,GAAG,GAAGL,UAAU,CAACgH,GAAG,CAACjG,MAAL,CAApB;AACAkG,UAAAA,kBAAkB,CAACD,GAAD,EAAM3G,GAAN,CAAlB;AACA,iBAAOA,GAAP;AACD;AAfO,OAAV;;AAkBA,eAAS6G,kBAAT,CAA4B7G,GAA5B,EAAiC;AAC/B,YAAIoG,UAAU,KAAK,QAAnB,EAA6B,OAAOU,YAAY,CAAC9G,GAAD,CAAnB;AAC7B,YAAIoG,UAAU,KAAK,SAAnB,EAA8B,OAAOW,OAAO,CAAC/G,GAAD,CAAd;AAC9B,eAAOA,GAAP;AACD;;AAED,UAAIgB,IAAI,GAAGiF,QAAQ,CAACC,KAAD,CAAnB;AACA,UAAIc,KAAK,GAAG,EAAZ;AACA,UAAIC,KAAK,GAAG,CAAZ;AACA9H,MAAAA,MAAM,CAACiH,UAAU,KAAK,OAAhB,EAAyB,oCAAzB,CAAN;;AACA,UAAIpC,IAAJ,EAAU;AACR,aAAK,IAAIzC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyC,IAAI,CAACtD,MAAzB,EAAiCa,CAAC,EAAlC,EAAsC;AACpC,cAAI2F,SAAS,GAAGX,GAAG,CAACF,QAAQ,CAAC9E,CAAD,CAAT,CAAnB;;AACA,cAAI2F,SAAJ,EAAe;AACb,gBAAID,KAAK,KAAK,CAAd,EAAiBA,KAAK,GAAGxH,SAAS,EAAjB;AACjBuH,YAAAA,KAAK,CAACzF,CAAD,CAAL,GAAW2F,SAAS,CAAClD,IAAI,CAACzC,CAAD,CAAL,CAApB;AACD,WAHD,MAGO;AACLyF,YAAAA,KAAK,CAACzF,CAAD,CAAL,GAAWyC,IAAI,CAACzC,CAAD,CAAf;AACD;AACF;AACF;;AACD,UAAIvB,GAAG,GAAGgB,IAAI,CAACmD,KAAL,CAAW,IAAX,EAAiB6C,KAAjB,CAAV;AAEAhH,MAAAA,GAAG,GAAG6G,kBAAkB,CAAC7G,GAAD,CAAxB;AACA,UAAIiH,KAAK,KAAK,CAAd,EAAiBvH,YAAY,CAACuH,KAAD,CAAZ;AACjB,aAAOjH,GAAP;AACD;;AAED,aAASmH,KAAT,CAAejB,KAAf,EAAsBE,UAAtB,EAAkCC,QAAlC,EAA4CC,IAA5C,EAAkD;AAChD,aAAO,YAAW;AAChB,eAAOH,KAAK,CAACD,KAAD,EAAQE,UAAR,EAAoBC,QAApB,EAA8B3C,SAA9B,EAAyC4C,IAAzC,CAAZ;AACD,OAFD;AAGD;;AAED,QAAIc,YAAY,GAAG,CAAnB,CA1nBiB,CA0nBK;;AACtB,QAAIC,WAAW,GAAG,CAAlB,CA3nBiB,CA2nBI;;AACrB,QAAIC,aAAa,GAAG,CAApB,CA5nBiB,CA4nBM;;AACvB,QAAIC,UAAU,GAAG,CAAjB,CA7nBiB,CA6nBG;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA,aAASC,QAAT,CAAkBC,IAAlB,EAAwBC,KAAxB,EAA+BC,SAA/B,EAA0C5D,GAA1C,EAA+C;AAC7C,UAAI6D,QAAJ,EAAc/H,IAAd;;AACA,UAAI,OAAO4H,IAAP,KAAgB,QAApB,EAA8B;AAC5BG,QAAAA,QAAQ,GAAG,IAAX;AACA/H,QAAAA,IAAI,GAAG4H,IAAP;AACD,OAHD,MAGO;AACLG,QAAAA,QAAQ,GAAG,KAAX;AACA/H,QAAAA,IAAI,GAAG4H,IAAI,CAAC/G,MAAZ;AACD;;AAED,UAAImH,UAAU,GAAG,OAAOH,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoC,IAArD;AAEA,UAAI1H,GAAJ;;AACA,UAAI2H,SAAS,IAAIJ,UAAjB,EAA6B;AAC3BvH,QAAAA,GAAG,GAAG+D,GAAN;AACD,OAFD,MAEO;AACL/D,QAAAA,GAAG,GAAG,CAAC8H,OAAD,EACNnI,UADM,EAENG,YAFM,EAEQ6H,SAFR,EAEmBrH,IAAI,CAACyH,GAAL,CAASlI,IAAT,EAAegI,UAAU,GAAG,CAAH,GAAOH,KAAK,CAAChH,MAAtC,CAFnB,CAAN;AAGD;;AAED,UAAIkH,QAAJ,EAAc;AACZ,YAAII,IAAJ;AACAjE,QAAAA,GAAG,GAAG/D,GAAN;AACAb,QAAAA,MAAM,CAAC,CAACa,GAAG,GAAG,CAAP,KAAa,CAAd,CAAN;AACAgI,QAAAA,IAAI,GAAGhI,GAAG,IAAIH,IAAI,GAAG,CAAC,CAAZ,CAAV;;AACA,eAAOkE,GAAG,GAAGiE,IAAb,EAAmBjE,GAAG,IAAI,CAA1B,EAA6B;AAC3B9D,UAAAA,MAAM,CAAG8D,GAAD,IAAO,CAAT,CAAN,GAAmB,CAAnB;AACD;;AACDiE,QAAAA,IAAI,GAAGhI,GAAG,GAAGH,IAAb;;AACA,eAAOkE,GAAG,GAAGiE,IAAb,EAAmB;AACjB/C,UAAAA,KAAK,CAAGlB,GAAG,EAAJ,IAAS,CAAX,CAAL,GAAoB,CAApB;AACD;;AACD,eAAO/D,GAAP;AACD;;AAED,UAAI6H,UAAU,KAAK,IAAnB,EAAyB;AACvB,YAAIJ,IAAI,CAACQ,QAAL,IAAiBR,IAAI,CAAC9F,KAA1B,EAAiC;AAC/BuG,UAAAA,MAAM,CAACxF,GAAP;AAAW;AAA4B+E,UAAAA,IAAvC,EAA8CzH,GAA9C;AACD,SAFD,MAEO;AACLkI,UAAAA,MAAM,CAACxF,GAAP,CAAW,IAAItE,UAAJ,CAAeqJ,IAAf,CAAX,EAAiCzH,GAAjC;AACD;;AACD,eAAOA,GAAP;AACD;;AAED,UAAIuB,CAAC,GAAG,CAAR;AAAA,UAAWd,IAAX;AAAA,UAAiB0H,QAAjB;AAAA,UAA2BC,YAA3B;;AACA,aAAO7G,CAAC,GAAG1B,IAAX,EAAiB;AACf,YAAIwI,IAAI,GAAGZ,IAAI,CAAClG,CAAD,CAAf;AAEAd,QAAAA,IAAI,GAAGoH,UAAU,IAAIH,KAAK,CAACnG,CAAD,CAA1B;;AACA,YAAId,IAAI,KAAK,CAAb,EAAgB;AACdc,UAAAA,CAAC;AACD;AACD;;AACDpC,QAAAA,MAAM,CAACsB,IAAD,EAAO,2CAAP,CAAN;AAEA,YAAIA,IAAI,IAAI,KAAZ,EAAmBA,IAAI,GAAG,KAAP,CAVJ,CAUkB;;AAEjCqE,QAAAA,QAAQ,CAAC9E,GAAG,GAACuB,CAAL,EAAQ8G,IAAR,EAAc5H,IAAd,CAAR,CAZe,CAcf;;AACA,YAAI2H,YAAY,KAAK3H,IAArB,EAA2B;AACzB0H,UAAAA,QAAQ,GAAG3H,iBAAiB,CAACC,IAAD,CAA5B;AACA2H,UAAAA,YAAY,GAAG3H,IAAf;AACD;;AACDc,QAAAA,CAAC,IAAI4G,QAAL;AACD;;AAED,aAAOnI,GAAP;AACD,KAltBgB,CAotBjB;;;AACA,aAASsI,SAAT,CAAmBzI,IAAnB,EAAyB;AACvB,UAAI,CAAC0I,kBAAL,EAAyB,OAAOzI,YAAY,CAACD,IAAD,CAAnB;AACzB,aAAOiI,OAAO,CAACjI,IAAD,CAAd;AACD,KAxtBgB,CA2tBjB;AAEA;AACA;;;AAEA,QAAI2I,WAAW,GAAG,OAAOC,WAAP,KAAuB,WAAvB,GAAqC,IAAIA,WAAJ,CAAgB,MAAhB,CAArC,GAA+DzM,SAAjF;AAEA;;;;;;AAKA,aAAS0M,iBAAT,CAA2BC,OAA3B,EAAoCC,GAApC,EAAyCC,cAAzC,EAAyD;AACvD,UAAIC,MAAM,GAAGF,GAAG,GAAGC,cAAnB;AACA,UAAIE,MAAM,GAAGH,GAAb,CAFuD,CAGvD;AACA;AACA;;AACA,aAAOD,OAAO,CAACI,MAAD,CAAP,IAAmB,EAAEA,MAAM,IAAID,MAAZ,CAA1B;AAA+C,UAAEC,MAAF;AAA/C;;AAEA,UAAIA,MAAM,GAAGH,GAAT,GAAe,EAAf,IAAqBD,OAAO,CAACV,QAA7B,IAAyCO,WAA7C,EAA0D;AACxD,eAAOA,WAAW,CAACQ,MAAZ,CAAmBL,OAAO,CAACV,QAAR,CAAiBW,GAAjB,EAAsBG,MAAtB,CAAnB,CAAP;AACD,OAFD,MAEO;AACL,YAAIvC,GAAG,GAAG,EAAV,CADK,CAEL;;AACA,eAAOoC,GAAG,GAAGG,MAAb,EAAqB;AACnB;AACA;AACA;AACA;AACA,cAAIE,EAAE,GAAGN,OAAO,CAACC,GAAG,EAAJ,CAAhB;;AACA,cAAI,EAAEK,EAAE,GAAG,IAAP,CAAJ,EAAkB;AAAEzC,YAAAA,GAAG,IAAI0C,MAAM,CAACC,YAAP,CAAoBF,EAApB,CAAP;AAAgC;AAAW;;AAC/D,cAAIG,EAAE,GAAGT,OAAO,CAACC,GAAG,EAAJ,CAAP,GAAiB,EAA1B;;AACA,cAAI,CAACK,EAAE,GAAG,IAAN,KAAe,IAAnB,EAAyB;AAAEzC,YAAAA,GAAG,IAAI0C,MAAM,CAACC,YAAP,CAAqB,CAACF,EAAE,GAAG,EAAN,KAAa,CAAd,GAAmBG,EAAvC,CAAP;AAAmD;AAAW;;AACzF,cAAIC,EAAE,GAAGV,OAAO,CAACC,GAAG,EAAJ,CAAP,GAAiB,EAA1B;;AACA,cAAI,CAACK,EAAE,GAAG,IAAN,KAAe,IAAnB,EAAyB;AACvBA,YAAAA,EAAE,GAAI,CAACA,EAAE,GAAG,EAAN,KAAa,EAAd,GAAqBG,EAAE,IAAI,CAA3B,GAAgCC,EAArC;AACD,WAFD,MAEO;AACL,gBAAI,CAACJ,EAAE,GAAG,IAAN,KAAe,IAAnB,EAAyBrI,QAAQ,CAAC,kCAAkCqI,EAAE,CAACK,QAAH,CAAY,EAAZ,CAAlC,GAAoD,wFAArD,CAAR;AACzBL,YAAAA,EAAE,GAAI,CAACA,EAAE,GAAG,CAAN,KAAY,EAAb,GAAoBG,EAAE,IAAI,EAA1B,GAAiCC,EAAE,IAAI,CAAvC,GAA6CV,OAAO,CAACC,GAAG,EAAJ,CAAP,GAAiB,EAAnE;AACD;;AAED,cAAIK,EAAE,GAAG,OAAT,EAAkB;AAChBzC,YAAAA,GAAG,IAAI0C,MAAM,CAACC,YAAP,CAAoBF,EAApB,CAAP;AACD,WAFD,MAEO;AACL,gBAAIM,EAAE,GAAGN,EAAE,GAAG,OAAd;AACAzC,YAAAA,GAAG,IAAI0C,MAAM,CAACC,YAAP,CAAoB,SAAUI,EAAE,IAAI,EAApC,EAAyC,SAAUA,EAAE,GAAG,KAAxD,CAAP;AACD;AACF;AACF;;AACD,aAAO/C,GAAP;AACD,KA9wBgB,CAgxBjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;;;;;AAKA,aAASM,YAAT,CAAsB/C,GAAtB,EAA2B8E,cAA3B,EAA2C;AACzC,aAAO9E,GAAG,GAAG2E,iBAAiB,CAACR,MAAD,EAASnE,GAAT,EAAc8E,cAAd,CAApB,GAAoD,EAA9D;AACD,KAjyBgB,CAmyBjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,aAASW,iBAAT,CAA2BhD,GAA3B,EAAgCiD,UAAhC,EAA4CC,MAA5C,EAAoDC,eAApD,EAAqE;AACnE,UAAI,EAAEA,eAAe,GAAG,CAApB,CAAJ,EAA4B;AAC1B,eAAO,CAAP;AAEF,UAAIC,QAAQ,GAAGF,MAAf;AACA,UAAIZ,MAAM,GAAGY,MAAM,GAAGC,eAAT,GAA2B,CAAxC,CALmE,CAKxB;;AAC3C,WAAK,IAAIpI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiF,GAAG,CAAC9F,MAAxB,EAAgC,EAAEa,CAAlC,EAAqC;AACnC;AACA;AACA;AACA,YAAIsI,CAAC,GAAGrD,GAAG,CAACsD,UAAJ,CAAevI,CAAf,CAAR,CAJmC,CAIR;;AAC3B,YAAIsI,CAAC,IAAI,MAAL,IAAeA,CAAC,IAAI,MAAxB,EAAgC;AAC9B,cAAIT,EAAE,GAAG5C,GAAG,CAACsD,UAAJ,CAAe,EAAEvI,CAAjB,CAAT;AACAsI,UAAAA,CAAC,GAAG,WAAW,CAACA,CAAC,GAAG,KAAL,KAAe,EAA1B,IAAiCT,EAAE,GAAG,KAA1C;AACD;;AACD,YAAIS,CAAC,IAAI,IAAT,EAAe;AACb,cAAIH,MAAM,IAAIZ,MAAd,EAAsB;AACtBW,UAAAA,UAAU,CAACC,MAAM,EAAP,CAAV,GAAuBG,CAAvB;AACD,SAHD,MAGO,IAAIA,CAAC,IAAI,KAAT,EAAgB;AACrB,cAAIH,MAAM,GAAG,CAAT,IAAcZ,MAAlB,EAA0B;AAC1BW,UAAAA,UAAU,CAACC,MAAM,EAAP,CAAV,GAAuB,OAAQG,CAAC,IAAI,CAApC;AACAJ,UAAAA,UAAU,CAACC,MAAM,EAAP,CAAV,GAAuB,OAAQG,CAAC,GAAG,EAAnC;AACD,SAJM,MAIA,IAAIA,CAAC,IAAI,MAAT,EAAiB;AACtB,cAAIH,MAAM,GAAG,CAAT,IAAcZ,MAAlB,EAA0B;AAC1BW,UAAAA,UAAU,CAACC,MAAM,EAAP,CAAV,GAAuB,OAAQG,CAAC,IAAI,EAApC;AACAJ,UAAAA,UAAU,CAACC,MAAM,EAAP,CAAV,GAAuB,OAASG,CAAC,IAAI,CAAN,GAAW,EAA1C;AACAJ,UAAAA,UAAU,CAACC,MAAM,EAAP,CAAV,GAAuB,OAAQG,CAAC,GAAG,EAAnC;AACD,SALM,MAKA;AACL,cAAIH,MAAM,GAAG,CAAT,IAAcZ,MAAlB,EAA0B;AAC1B,cAAIe,CAAC,IAAI,QAAT,EAAmBjJ,QAAQ,CAAC,kCAAkCiJ,CAAC,CAACP,QAAF,CAAW,EAAX,CAAlC,GAAmD,kJAApD,CAAR;AACnBG,UAAAA,UAAU,CAACC,MAAM,EAAP,CAAV,GAAuB,OAAQG,CAAC,IAAI,EAApC;AACAJ,UAAAA,UAAU,CAACC,MAAM,EAAP,CAAV,GAAuB,OAASG,CAAC,IAAI,EAAN,GAAY,EAA3C;AACAJ,UAAAA,UAAU,CAACC,MAAM,EAAP,CAAV,GAAuB,OAASG,CAAC,IAAI,CAAN,GAAW,EAA1C;AACAJ,UAAAA,UAAU,CAACC,MAAM,EAAP,CAAV,GAAuB,OAAQG,CAAC,GAAG,EAAnC;AACD;AACF,OAnCkE,CAoCnE;;;AACAJ,MAAAA,UAAU,CAACC,MAAD,CAAV,GAAqB,CAArB;AACA,aAAOA,MAAM,GAAGE,QAAhB;AACD,KAv1BgB,CAy1BjB;AACA;AACA;AACA;;;AAEA,aAASlD,YAAT,CAAsBF,GAAtB,EAA2BuD,MAA3B,EAAmCJ,eAAnC,EAAoD;AAClDxK,MAAAA,MAAM,CAAC,OAAOwK,eAAP,IAA0B,QAA3B,EAAqC,2HAArC,CAAN;AACA,aAAOH,iBAAiB,CAAChD,GAAD,EAAM0B,MAAN,EAAa6B,MAAb,EAAqBJ,eAArB,CAAxB;AACD,KAj2BgB,CAm2BjB;;;AACA,aAASK,eAAT,CAAyBxD,GAAzB,EAA8B;AAC5B,UAAIC,GAAG,GAAG,CAAV;;AACA,WAAK,IAAIlF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiF,GAAG,CAAC9F,MAAxB,EAAgC,EAAEa,CAAlC,EAAqC;AACnC;AACA;AACA,YAAIsI,CAAC,GAAGrD,GAAG,CAACsD,UAAJ,CAAevI,CAAf,CAAR,CAHmC,CAGR;;AAC3B,YAAIsI,CAAC,IAAI,MAAL,IAAeA,CAAC,IAAI,MAAxB,EAAgCA,CAAC,GAAG,WAAW,CAACA,CAAC,GAAG,KAAL,KAAe,EAA1B,IAAiCrD,GAAG,CAACsD,UAAJ,CAAe,EAAEvI,CAAjB,IAAsB,KAA3D;AAChC,YAAIsI,CAAC,IAAI,IAAT,EAAe,EAAEpD,GAAF,CAAf,KACK,IAAIoD,CAAC,IAAI,KAAT,EAAgBpD,GAAG,IAAI,CAAP,CAAhB,KACA,IAAIoD,CAAC,IAAI,MAAT,EAAiBpD,GAAG,IAAI,CAAP,CAAjB,KACAA,GAAG,IAAI,CAAP;AACN;;AACD,aAAOA,GAAP;AACD,KAj3BgB,CAq3BjB;AAEA;AACA;;;AAEA,aAASwD,aAAT,CAAuBlG,GAAvB,EAA4B;AAC1B,UAAIyC,GAAG,GAAG,EAAV;;AACA,aAAO,CAAP,EAAU;AACR,YAAI+C,EAAE,GAAGrB,MAAM,CAAGnE,GAAG,EAAJ,IAAS,CAAX,CAAf;AACA,YAAI,CAACwF,EAAL,EAAS,OAAO/C,GAAP;AACTA,QAAAA,GAAG,IAAI0C,MAAM,CAACC,YAAP,CAAoBI,EAApB,CAAP;AACD;AACF,KAj4BgB,CAm4BjB;AACA;;;AAEA,aAASW,aAAT,CAAuB1D,GAAvB,EAA4BuD,MAA5B,EAAoC;AAClC,aAAOI,kBAAkB,CAAC3D,GAAD,EAAMuD,MAAN,EAAc,KAAd,CAAzB;AACD,KAx4BgB,CA04BjB;AACA;;;AAEA,QAAIK,YAAY,GAAG,OAAO3B,WAAP,KAAuB,WAAvB,GAAqC,IAAIA,WAAJ,CAAgB,UAAhB,CAArC,GAAmEzM,SAAtF;;AAEA,aAASqO,aAAT,CAAuBtG,GAAvB,EAA4B;AAC1B5E,MAAAA,MAAM,CAAC4E,GAAG,GAAG,CAAN,IAAW,CAAZ,EAAe,+DAAf,CAAN;AACA,UAAIgF,MAAM,GAAGhF,GAAb,CAF0B,CAG1B;AACA;;AACA,UAAI6E,GAAG,GAAGG,MAAM,IAAI,CAApB;;AACA,aAAO7D,MAAM,CAAC0D,GAAD,CAAb;AAAoB,UAAEA,GAAF;AAApB;;AACAG,MAAAA,MAAM,GAAGH,GAAG,IAAI,CAAhB;;AAEA,UAAIG,MAAM,GAAGhF,GAAT,GAAe,EAAf,IAAqBqG,YAAzB,EAAuC;AACrC,eAAOA,YAAY,CAACpB,MAAb,CAAoBd,MAAM,CAACD,QAAP,CAAgBlE,GAAhB,EAAqBgF,MAArB,CAApB,CAAP;AACD,OAFD,MAEO;AACL,YAAIxH,CAAC,GAAG,CAAR;AAEA,YAAIiF,GAAG,GAAG,EAAV;;AACA,eAAO,CAAP,EAAU;AACR,cAAI8D,QAAQ,GAAGpF,MAAM,CAAInB,GAAD,GAAOxC,CAAC,GAAC,CAAV,IAAe,CAAjB,CAArB;AACA,cAAI+I,QAAQ,IAAI,CAAhB,EAAmB,OAAO9D,GAAP;AACnB,YAAEjF,CAAF,CAHQ,CAIR;;AACAiF,UAAAA,GAAG,IAAI0C,MAAM,CAACC,YAAP,CAAoBmB,QAApB,CAAP;AACD;AACF;AACF,KAt6BgB,CAw6BjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,aAASC,aAAT,CAAuB/D,GAAvB,EAA4BuD,MAA5B,EAAoCJ,eAApC,EAAqD;AACnDxK,MAAAA,MAAM,CAAC4K,MAAM,GAAG,CAAT,IAAc,CAAf,EAAkB,+DAAlB,CAAN;AACA5K,MAAAA,MAAM,CAAC,OAAOwK,eAAP,IAA0B,QAA3B,EAAqC,4HAArC,CAAN,CAFmD,CAGnD;;AACA,UAAIA,eAAe,KAAK3N,SAAxB,EAAmC;AACjC2N,QAAAA,eAAe,GAAG,UAAlB;AACD;;AACD,UAAIA,eAAe,GAAG,CAAtB,EAAyB,OAAO,CAAP;AACzBA,MAAAA,eAAe,IAAI,CAAnB,CARmD,CAQ7B;;AACtB,UAAIa,QAAQ,GAAGT,MAAf;AACA,UAAIU,eAAe,GAAId,eAAe,GAAGnD,GAAG,CAAC9F,MAAJ,GAAW,CAA9B,GAAoCiJ,eAAe,GAAG,CAAtD,GAA2DnD,GAAG,CAAC9F,MAArF;;AACA,WAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkJ,eAApB,EAAqC,EAAElJ,CAAvC,EAA0C;AACxC;AACA,YAAI+I,QAAQ,GAAG9D,GAAG,CAACsD,UAAJ,CAAevI,CAAf,CAAf,CAFwC,CAEN;;AAClC2D,QAAAA,MAAM,CAAG6E,MAAD,IAAU,CAAZ,CAAN,GAAsBO,QAAtB;AACAP,QAAAA,MAAM,IAAI,CAAV;AACD,OAhBkD,CAiBnD;;;AACA7E,MAAAA,MAAM,CAAG6E,MAAD,IAAU,CAAZ,CAAN,GAAsB,CAAtB;AACA,aAAOA,MAAM,GAAGS,QAAhB;AACD,KAv8BgB,CAy8BjB;;;AAEA,aAASE,gBAAT,CAA0BlE,GAA1B,EAA+B;AAC7B,aAAOA,GAAG,CAAC9F,MAAJ,GAAW,CAAlB;AACD;;AAED,aAASiK,aAAT,CAAuB5G,GAAvB,EAA4B;AAC1B5E,MAAAA,MAAM,CAAC4E,GAAG,GAAG,CAAN,IAAW,CAAZ,EAAe,gEAAf,CAAN;AACA,UAAIxC,CAAC,GAAG,CAAR;AAEA,UAAIiF,GAAG,GAAG,EAAV;;AACA,aAAO,CAAP,EAAU;AACR,YAAIoE,KAAK,GAAG3K,MAAM,CAAI8D,GAAD,GAAOxC,CAAC,GAAC,CAAV,IAAe,CAAjB,CAAlB;AACA,YAAIqJ,KAAK,IAAI,CAAb,EACE,OAAOpE,GAAP;AACF,UAAEjF,CAAF,CAJQ,CAKR;AACA;;AACA,YAAIqJ,KAAK,IAAI,OAAb,EAAsB;AACpB,cAAIrB,EAAE,GAAGqB,KAAK,GAAG,OAAjB;AACApE,UAAAA,GAAG,IAAI0C,MAAM,CAACC,YAAP,CAAoB,SAAUI,EAAE,IAAI,EAApC,EAAyC,SAAUA,EAAE,GAAG,KAAxD,CAAP;AACD,SAHD,MAGO;AACL/C,UAAAA,GAAG,IAAI0C,MAAM,CAACC,YAAP,CAAoByB,KAApB,CAAP;AACD;AACF;AACF,KAl+BgB,CAo+BjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,aAASC,aAAT,CAAuBrE,GAAvB,EAA4BuD,MAA5B,EAAoCJ,eAApC,EAAqD;AACnDxK,MAAAA,MAAM,CAAC4K,MAAM,GAAG,CAAT,IAAc,CAAf,EAAkB,gEAAlB,CAAN;AACA5K,MAAAA,MAAM,CAAC,OAAOwK,eAAP,IAA0B,QAA3B,EAAqC,4HAArC,CAAN,CAFmD,CAGnD;;AACA,UAAIA,eAAe,KAAK3N,SAAxB,EAAmC;AACjC2N,QAAAA,eAAe,GAAG,UAAlB;AACD;;AACD,UAAIA,eAAe,GAAG,CAAtB,EAAyB,OAAO,CAAP;AACzB,UAAIa,QAAQ,GAAGT,MAAf;AACA,UAAIhB,MAAM,GAAGyB,QAAQ,GAAGb,eAAX,GAA6B,CAA1C;;AACA,WAAK,IAAIpI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiF,GAAG,CAAC9F,MAAxB,EAAgC,EAAEa,CAAlC,EAAqC;AACnC;AACA;AACA,YAAI+I,QAAQ,GAAG9D,GAAG,CAACsD,UAAJ,CAAevI,CAAf,CAAf,CAHmC,CAGD;;AAClC,YAAI+I,QAAQ,IAAI,MAAZ,IAAsBA,QAAQ,IAAI,MAAtC,EAA8C;AAC5C,cAAIQ,cAAc,GAAGtE,GAAG,CAACsD,UAAJ,CAAe,EAAEvI,CAAjB,CAArB;AACA+I,UAAAA,QAAQ,GAAG,WAAW,CAACA,QAAQ,GAAG,KAAZ,KAAsB,EAAjC,IAAwCQ,cAAc,GAAG,KAApE;AACD;;AACD7K,QAAAA,MAAM,CAAG8J,MAAD,IAAU,CAAZ,CAAN,GAAsBO,QAAtB;AACAP,QAAAA,MAAM,IAAI,CAAV;AACA,YAAIA,MAAM,GAAG,CAAT,GAAahB,MAAjB,EAAyB;AAC1B,OArBkD,CAsBnD;;;AACA9I,MAAAA,MAAM,CAAG8J,MAAD,IAAU,CAAZ,CAAN,GAAsB,CAAtB;AACA,aAAOA,MAAM,GAAGS,QAAhB;AACD,KAxgCgB,CA0gCjB;;;AAEA,aAASO,gBAAT,CAA0BvE,GAA1B,EAA+B;AAC7B,UAAIC,GAAG,GAAG,CAAV;;AACA,WAAK,IAAIlF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiF,GAAG,CAAC9F,MAAxB,EAAgC,EAAEa,CAAlC,EAAqC;AACnC;AACA;AACA,YAAI+I,QAAQ,GAAG9D,GAAG,CAACsD,UAAJ,CAAevI,CAAf,CAAf;AACA,YAAI+I,QAAQ,IAAI,MAAZ,IAAsBA,QAAQ,IAAI,MAAtC,EAA8C,EAAE/I,CAAF,CAJX,CAIgB;;AACnDkF,QAAAA,GAAG,IAAI,CAAP;AACD;;AAED,aAAOA,GAAP;AACD,KAvhCgB,CAyhCjB;AACA;;;AACA,aAASuE,YAAT,CAAsBxE,GAAtB,EAA2B;AACzB,UAAI3G,IAAI,GAAGmK,eAAe,CAACxD,GAAD,CAAf,GAAuB,CAAlC;;AACA,UAAIxG,GAAG,GAAG8H,OAAO,CAACjI,IAAD,CAAjB;;AACA,UAAIG,GAAJ,EAASwJ,iBAAiB,CAAChD,GAAD,EAAMvB,KAAN,EAAajF,GAAb,EAAkBH,IAAlB,CAAjB;AACT,aAAOG,GAAP;AACD,KAhiCgB,CAkiCjB;;;AACA,aAASiL,mBAAT,CAA6BzE,GAA7B,EAAkC;AAChC,UAAI3G,IAAI,GAAGmK,eAAe,CAACxD,GAAD,CAAf,GAAuB,CAAlC;AACA,UAAIxG,GAAG,GAAGL,UAAU,CAACE,IAAD,CAApB;AACA2J,MAAAA,iBAAiB,CAAChD,GAAD,EAAMvB,KAAN,EAAajF,GAAb,EAAkBH,IAAlB,CAAjB;AACA,aAAOG,GAAP;AACD,KAxiCgB,CA0iCjB;AACA;AACA;AACA;;AACA;;;AACA,aAASkL,mBAAT,CAA6BC,MAA7B,EAAqCC,MAArC,EAA6CC,WAA7C,EAA0D;AACxDzK,MAAAA,QAAQ,CAAC,yFAAD,CAAR;AAEA;AAAI;AAAsB0K,MAAAA,QAA1B;AAAoC;AAAsBpL,MAAAA,GAA1D;;AACA,UAAImL,WAAJ,EAAiB;AACf;AACA;AACA;AACAnL,QAAAA,GAAG,GAAGkL,MAAM,GAAGpB,eAAe,CAACmB,MAAD,CAA9B;AACAG,QAAAA,QAAQ,GAAGrG,KAAK,CAAC/E,GAAD,CAAhB;AACD;;AACDwG,MAAAA,YAAY,CAACyE,MAAD,EAASC,MAAT,EAAiBG,QAAjB,CAAZ;AACA,UAAIF,WAAJ,EAAiBpG,KAAK,CAAC/E,GAAD,CAAL,GAAaoL,QAAb,CAZuC,CAYhB;AACzC;;AAED,aAAS1E,kBAAT,CAA4B4E,KAA5B,EAAmCJ,MAAnC,EAA2C;AACzCjM,MAAAA,MAAM,CAACqM,KAAK,CAAC9K,MAAN,IAAgB,CAAjB,EAAoB,iFAApB,CAAN;AACAuE,MAAAA,KAAK,CAACvC,GAAN,CAAU8I,KAAV,EAAiBJ,MAAjB;AACD;;AAED,aAASjB,kBAAT,CAA4B3D,GAA5B,EAAiC4E,MAAjC,EAAyCC,WAAzC,EAAsD;AACpD,WAAK,IAAI9J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiF,GAAG,CAAC9F,MAAxB,EAAgC,EAAEa,CAAlC,EAAqC;AACnCpC,QAAAA,MAAM,CAACqH,GAAG,CAACsD,UAAJ,CAAevI,CAAf,MAAsBiF,GAAG,CAACsD,UAAJ,CAAevI,CAAf,CAAtB,GAAwC,IAAzC,CAAN;AACA0D,QAAAA,KAAK,CAAGmG,MAAM,EAAP,IAAY,CAAd,CAAL,GAAuB5E,GAAG,CAACsD,UAAJ,CAAevI,CAAf,CAAvB;AACD,OAJmD,CAKpD;;;AACA,UAAI,CAAC8J,WAAL,EAAkBpG,KAAK,CAAGmG,MAAD,IAAU,CAAZ,CAAL,GAAqB,CAArB;AACnB,KA1kCgB,CA8kCjB;;;AAEA,QAAIK,SAAS,GAAG,KAAhB;AACA,QAAIC,cAAc,GAAG,KAArB;AACA,QAAIC,eAAe,GAAG,QAAtB;;AAEA,aAASC,OAAT,CAAiBC,CAAjB,EAAoBC,QAApB,EAA8B;AAC5B,UAAID,CAAC,GAAGC,QAAJ,GAAe,CAAnB,EAAsB;AACpBD,QAAAA,CAAC,IAAIC,QAAQ,GAAID,CAAC,GAAGC,QAArB;AACD;;AACD,aAAOD,CAAP;AACD;;AAED,QAAIE,IAAJ;AACA;AACEX,IAAAA,MAFF;AAGA;AACEnG,IAAAA,KAJF;AAKA;AACEiD,IAAAA,MANF;AAOA;AACEhD,IAAAA,MARF;AASA;AACE8G,IAAAA,OAVF;AAWA;AACE/L,IAAAA,MAZF;AAaA;AACEgM,IAAAA,OAdF;AAeA;AACExG,IAAAA,OAhBF;AAiBA;AACEC,IAAAA,OAlBF;;AAoBA,aAASwG,0BAAT,CAAoCC,GAApC,EAAyC;AACvCf,MAAAA,MAAM,GAAGe,GAAT;AACAxQ,MAAAA,MAAM,CAAC,OAAD,CAAN,GAAkBsJ,KAAK,GAAG,IAAImH,SAAJ,CAAcD,GAAd,CAA1B;AACAxQ,MAAAA,MAAM,CAAC,QAAD,CAAN,GAAmBuJ,MAAM,GAAG,IAAImH,UAAJ,CAAeF,GAAf,CAA5B;AACAxQ,MAAAA,MAAM,CAAC,QAAD,CAAN,GAAmBsE,MAAM,GAAG,IAAIqM,UAAJ,CAAeH,GAAf,CAA5B;AACAxQ,MAAAA,MAAM,CAAC,QAAD,CAAN,GAAmBuM,MAAM,GAAG,IAAI9J,UAAJ,CAAe+N,GAAf,CAA5B;AACAxQ,MAAAA,MAAM,CAAC,SAAD,CAAN,GAAoBqQ,OAAO,GAAG,IAAIO,WAAJ,CAAgBJ,GAAhB,CAA9B;AACAxQ,MAAAA,MAAM,CAAC,SAAD,CAAN,GAAoBsQ,OAAO,GAAG,IAAIO,WAAJ,CAAgBL,GAAhB,CAA9B;AACAxQ,MAAAA,MAAM,CAAC,SAAD,CAAN,GAAoB8J,OAAO,GAAG,IAAIgH,YAAJ,CAAiBN,GAAjB,CAA9B;AACAxQ,MAAAA,MAAM,CAAC,SAAD,CAAN,GAAoB+J,OAAO,GAAG,IAAIgH,YAAJ,CAAiBP,GAAjB,CAA9B;AACD;;AAED,QAAIQ,WAAW,GAAG,IAAlB;AAAA,QACIC,UAAU,GAAG,OADjB;AAAA,QAEIC,QAAQ,GAAGD,UAFf;AAAA,QAGIE,SAAS,GAAG,IAHhB;AAAA,QAIIC,YAAY,GAAG,OAJnB;AAAA,QAKIhN,cAAc,GAAG,IALrB;AAOAZ,IAAAA,MAAM,CAACyN,UAAU,GAAG,EAAb,KAAoB,CAArB,EAAwB,0BAAxB,CAAN;AACAzN,IAAAA,MAAM,CAAC4N,YAAY,GAAG,EAAf,KAAsB,CAAvB,EAA0B,yBAA1B,CAAN;AAIA,QAAIC,WAAW,GAAG,OAAlB;AACA,QAAIrR,MAAM,CAAC,aAAD,CAAV,EAA2BwD,MAAM,CAAC6N,WAAW,KAAKrR,MAAM,CAAC,aAAD,CAAvB,EAAwC,uDAAxC,CAAN;AAE3B,QAAIsR,oBAAoB,GAAGtR,MAAM,CAAC,cAAD,CAAN,IAA0B,QAArD;AAA8D,QAAI,CAAC,iCAAgCA,MAAhC,EAAwC,cAAxC,CAAL,EAA8D,uBAAsBA,MAAtB,EAA8B,cAA9B,EAA8C;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,uEAAD,CAAL;AAAgF;AAAxH,KAA9C;AAE5HC,IAAAA,MAAM,CAAC8N,oBAAoB,IAAID,WAAzB,EAAsC,yDAAyDC,oBAAzD,GAAgF,iBAAhF,GAAoGD,WAApG,GAAkH,GAAxJ,CAAN,CA5oCiB,CA8oCjB;;AACA7N,IAAAA,MAAM,CAAC,OAAOmN,UAAP,KAAsB,WAAtB,IAAqC,OAAOI,YAAP,KAAwB,WAA7D,IAA4EJ,UAAU,CAAC9I,SAAX,CAAqByE,QAArB,KAAkCjM,SAA9G,IAA2HsQ,UAAU,CAAC9I,SAAX,CAAqBd,GAArB,KAA6B1G,SAAzJ,EACC,qDADD,CAAN,CA/oCiB,CAupCjB;AACA;AAEA;AACA;;AAEE,QAAIL,MAAM,CAAC,YAAD,CAAV,EAA0B;AACxBiK,MAAAA,UAAU,GAAGjK,MAAM,CAAC,YAAD,CAAnB;AACD,KAFD,MAGA;AACEiK,MAAAA,UAAU,GAAG,IAAI1E,WAAW,CAACgM,MAAhB,CAAuB;AAClC,mBAAWD,oBAAoB,GAAGvB,cADA;AAGlC,mBAAWuB,oBAAoB,GAAGvB;AAHA,OAAvB,CAAb;AAKD;;AAGH,QAAI9F,UAAJ,EAAgB;AACdwF,MAAAA,MAAM,GAAGxF,UAAU,CAACwF,MAApB;AACD,KA3qCgB,CA6qCjB;AACA;;;AACA6B,IAAAA,oBAAoB,GAAG7B,MAAM,CAAC+B,UAA9B;AACAhO,IAAAA,MAAM,CAAC8N,oBAAoB,GAAGvB,cAAvB,KAA0C,CAA3C,CAAN;AACAQ,IAAAA,0BAA0B,CAACd,MAAD,CAA1B;AAEAnL,IAAAA,MAAM,CAACF,cAAc,IAAE,CAAjB,CAAN,GAA4BgN,YAA5B,CAnrCiB,CAwrCjB;;AACA,aAASK,gBAAT,GAA4B;AAC1BjO,MAAAA,MAAM,CAAC,CAAC2N,SAAS,GAAG,CAAb,KAAmB,CAApB,CAAN,CAD0B,CAE1B;;AACAb,MAAAA,OAAO,CAAC,CAACa,SAAS,IAAI,CAAd,IAAiB,CAAlB,CAAP,GAA8B,SAA9B;AACAb,MAAAA,OAAO,CAAC,CAACa,SAAS,IAAI,CAAd,IAAiB,CAAlB,CAAP,GAA8B,UAA9B,CAJ0B,CAK1B;AACA;;AACA7M,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,UAAZ;AAAwB;AACzB;;AAED,aAASoN,gBAAT,GAA4B;AAC1B,UAAIC,OAAO,GAAGrB,OAAO,CAAC,CAACa,SAAS,IAAI,CAAd,IAAiB,CAAlB,CAArB;AACA,UAAIS,OAAO,GAAGtB,OAAO,CAAC,CAACa,SAAS,IAAI,CAAd,IAAiB,CAAlB,CAArB;;AACA,UAAIQ,OAAO,IAAI,SAAX,IAAwBC,OAAO,IAAI,UAAvC,EAAmD;AACjDrO,QAAAA,KAAK,CAAC,qHAAqHqO,OAAO,CAACjE,QAAR,CAAiB,EAAjB,CAArH,GAA4I,GAA5I,GAAkJgE,OAAO,CAAChE,QAAR,CAAiB,EAAjB,CAAnJ,CAAL;AACD,OALyB,CAM1B;AACA;;;AACA,UAAIrJ,MAAM,CAAC,CAAD,CAAN,KAAc;AAAW;AAA7B,QAA2Cf,KAAK,CAAC,mFAAD,CAAL;AAC5C;;AAED,aAASsO,kBAAT,CAA4BC,SAA5B,EAAuC;AACrCvO,MAAAA,KAAK,CAAC,2CAA2CuO,SAA3C,GAAuD,0CAAvD,IAAqGX,SAAS,GAAGrN,SAAS,EAArB,GAA0BgO,SAA/H,IAA4I,mBAA7I,CAAL;AACD,KAhtCgB,CAqtCjB;;;AACA,KAAC,YAAW;AACV,UAAIC,GAAG,GAAG,IAAIrB,UAAJ,CAAe,CAAf,CAAV;AACA,UAAIsB,EAAE,GAAG,IAAIvB,SAAJ,CAAcsB,GAAG,CAACtC,MAAlB,CAAT;AACAsC,MAAAA,GAAG,CAAC,CAAD,CAAH,GAAS,MAAT;AACA,UAAIC,EAAE,CAAC,CAAD,CAAF,KAAU,IAAV,IAAkBA,EAAE,CAAC,CAAD,CAAF,KAAU,IAAhC,EAAsC,MAAM,yDAAN;AACvC,KALD;;AAOA,aAASC,eAAT,CAAyB7J,GAAzB,EAA8B9C,GAA9B,EAAmC;AAClC/B,MAAAA,KAAK,CAAC,8BAA8B6E,GAA9B,GAAoC,0BAApC,GAAiE9C,GAAjE,GAAuE,uVAAxE,CAAL;AACA;;AAID,aAAS4M,oBAAT,CAA8BC,SAA9B,EAAyC;AACvC,aAAMA,SAAS,CAACpN,MAAV,GAAmB,CAAzB,EAA4B;AAC1B,YAAIqN,QAAQ,GAAGD,SAAS,CAACE,KAAV,EAAf;;AACA,YAAI,OAAOD,QAAP,IAAmB,UAAvB,EAAmC;AACjCA,UAAAA,QAAQ;AACR;AACD;;AACD,YAAI/M,IAAI,GAAG+M,QAAQ,CAAC/M,IAApB;;AACA,YAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,cAAI+M,QAAQ,CAACzK,GAAT,KAAiBtH,SAArB,EAAgC;AAC9BL,YAAAA,MAAM,CAAC,WAAD,CAAN,CAAoBqF,IAApB;AACD,WAFD,MAEO;AACLrF,YAAAA,MAAM,CAAC,YAAD,CAAN,CAAqBqF,IAArB,EAA2B+M,QAAQ,CAACzK,GAApC;AACD;AACF,SAND,MAMO;AACLtC,UAAAA,IAAI,CAAC+M,QAAQ,CAACzK,GAAT,KAAiBtH,SAAjB,GAA6B,IAA7B,GAAoC+R,QAAQ,CAACzK,GAA9C,CAAJ;AACD;AACF;AACF;;AAED,QAAI2K,YAAY,GAAI,EAApB,CAvvCiB,CAuvCO;;AACxB,QAAIC,UAAU,GAAM,EAApB,CAxvCiB,CAwvCO;;AACxB,QAAIC,UAAU,GAAM,EAApB,CAzvCiB,CAyvCO;;AACxB,QAAIC,UAAU,GAAM,EAApB,CA1vCiB,CA0vCO;;AACxB,QAAIC,aAAa,GAAG,EAApB,CA3vCiB,CA2vCO;;AAExB,QAAI9F,kBAAkB,GAAG,KAAzB;AACA,QAAI+F,aAAa,GAAG,KAApB;;AAGA,aAASC,MAAT,GAAkB;AAEhB,UAAI5S,MAAM,CAAC,QAAD,CAAV,EAAsB;AACpB,YAAI,OAAOA,MAAM,CAAC,QAAD,CAAb,IAA2B,UAA/B,EAA2CA,MAAM,CAAC,QAAD,CAAN,GAAmB,CAACA,MAAM,CAAC,QAAD,CAAP,CAAnB;;AAC3C,eAAOA,MAAM,CAAC,QAAD,CAAN,CAAiB+E,MAAxB,EAAgC;AAC9B8N,UAAAA,WAAW,CAAC7S,MAAM,CAAC,QAAD,CAAN,CAAiBqS,KAAjB,EAAD,CAAX;AACD;AACF;;AAEDH,MAAAA,oBAAoB,CAACI,YAAD,CAApB;AACD;;AAED,aAASQ,WAAT,GAAuB;AACrBpB,MAAAA,gBAAgB;AAChBlO,MAAAA,MAAM,CAAC,CAACoJ,kBAAF,CAAN;AACAA,MAAAA,kBAAkB,GAAG,IAArB;AAEAsF,MAAAA,oBAAoB,CAACK,UAAD,CAApB;AACD;;AAED,aAASQ,OAAT,GAAmB;AACjBrB,MAAAA,gBAAgB;AAEhBQ,MAAAA,oBAAoB,CAACM,UAAD,CAApB;AACD;;AAED,aAASQ,WAAT,GAAuB;AACrBtB,MAAAA,gBAAgB;AAChBiB,MAAAA,aAAa,GAAG,IAAhB;AACD;;AAED,aAASM,OAAT,GAAmB;AACjBvB,MAAAA,gBAAgB;;AAEhB,UAAI1R,MAAM,CAAC,SAAD,CAAV,EAAuB;AACrB,YAAI,OAAOA,MAAM,CAAC,SAAD,CAAb,IAA4B,UAAhC,EAA4CA,MAAM,CAAC,SAAD,CAAN,GAAoB,CAACA,MAAM,CAAC,SAAD,CAAP,CAApB;;AAC5C,eAAOA,MAAM,CAAC,SAAD,CAAN,CAAkB+E,MAAzB,EAAiC;AAC/BmO,UAAAA,YAAY,CAAClT,MAAM,CAAC,SAAD,CAAN,CAAkBqS,KAAlB,EAAD,CAAZ;AACD;AACF;;AAEDH,MAAAA,oBAAoB,CAACQ,aAAD,CAApB;AACD;;AAED,aAASG,WAAT,CAAqBM,EAArB,EAAyB;AACvBb,MAAAA,YAAY,CAACc,OAAb,CAAqBD,EAArB;AACD;;AAED,aAASE,SAAT,CAAmBF,EAAnB,EAAuB;AACrBZ,MAAAA,UAAU,CAACa,OAAX,CAAmBD,EAAnB;AACD;;AAED,aAASG,YAAT,CAAsBH,EAAtB,EAA0B;AACxBX,MAAAA,UAAU,CAACY,OAAX,CAAmBD,EAAnB;AACD;;AAED,aAASI,SAAT,CAAmBJ,EAAnB,EAAuB,CACtB;;AAED,aAASD,YAAT,CAAsBC,EAAtB,EAA0B;AACxBT,MAAAA,aAAa,CAACU,OAAd,CAAsBD,EAAtB;AACD;;AAED,aAASK,MAAT,CAAgB7K,KAAhB,EAAuB3D,IAAvB,EAA6ByO,MAA7B,EAAqC;AACnC,UAAI9K,KAAK,IAAI,CAAb,EAAgB;AACd,eAAOA,KAAP;AACD;;AACD,aAAO3D,IAAI,IAAI,EAAR,GAAa,IAAEL,IAAI,CAAC+O,GAAL,CAAS,KAAM1O,IAAI,GAAC,CAApB,CAAF,GAA4B2D,KAAzC,CAA+C;AAA/C,QACahE,IAAI,CAACgP,GAAL,CAAS,CAAT,EAAY3O,IAAZ,IAA4B2D,KADhD;AAED;;AACD,aAASiL,MAAT,CAAgBjL,KAAhB,EAAuB3D,IAAvB,EAA6ByO,MAA7B,EAAqC;AACnC,UAAI9K,KAAK,IAAI,CAAb,EAAgB;AACd,eAAOA,KAAP;AACD;;AACD,UAAIkL,IAAI,GAAG7O,IAAI,IAAI,EAAR,GAAaL,IAAI,CAAC+O,GAAL,CAAS,KAAM1O,IAAI,GAAC,CAApB,CAAb,CAAqC;AAArC,QACaL,IAAI,CAACgP,GAAL,CAAS,CAAT,EAAY3O,IAAI,GAAC,CAAjB,CADxB;;AAEA,UAAI2D,KAAK,IAAIkL,IAAT,KAAkB7O,IAAI,IAAI,EAAR,IAAc2D,KAAK,GAAGkL,IAAxC,CAAJ,EAAmD;AAAE;AACA;AACA;AACnDlL,QAAAA,KAAK,GAAG,CAAC,CAAD,GAAGkL,IAAH,GAAUlL,KAAlB,CAHiD,CAGxB;AAC1B;;AACD,aAAOA,KAAP;AACD,KAn1CgB,CAs1CjB;AAEA;AAEA;AAEA;;;AAEAnF,IAAAA,MAAM,CAACmB,IAAI,CAACmP,IAAN,EAAY,6HAAZ,CAAN;AACAtQ,IAAAA,MAAM,CAACmB,IAAI,CAACoP,MAAN,EAAc,+HAAd,CAAN;AACAvQ,IAAAA,MAAM,CAACmB,IAAI,CAACqP,KAAN,EAAa,8HAAb,CAAN;AACAxQ,IAAAA,MAAM,CAACmB,IAAI,CAACsP,KAAN,EAAa,8HAAb,CAAN;AAEA,QAAIvK,QAAQ,GAAG/E,IAAI,CAAC+O,GAApB;AACA,QAAIQ,QAAQ,GAAGvP,IAAI,CAACwP,GAApB;AACA,QAAIC,QAAQ,GAAGzP,IAAI,CAAC0P,GAApB;AACA,QAAIC,QAAQ,GAAG3P,IAAI,CAAC4P,GAApB;AACA,QAAIC,SAAS,GAAG7P,IAAI,CAAC8P,IAArB;AACA,QAAIC,SAAS,GAAG/P,IAAI,CAACgQ,IAArB;AACA,QAAIC,SAAS,GAAGjQ,IAAI,CAACkQ,IAArB;AACA,QAAIC,UAAU,GAAGnQ,IAAI,CAACoQ,KAAtB;AACA,QAAIC,QAAQ,GAAGrQ,IAAI,CAACsQ,GAApB;AACA,QAAIC,QAAQ,GAAGvQ,IAAI,CAAC1B,GAApB;AACA,QAAIkS,SAAS,GAAGxQ,IAAI,CAACyQ,IAArB;AACA,QAAIvL,SAAS,GAAGlF,IAAI,CAACC,IAArB;AACA,QAAIgF,UAAU,GAAGjF,IAAI,CAAC0Q,KAAtB;AACA,QAAIC,QAAQ,GAAG3Q,IAAI,CAACgP,GAApB;AACA,QAAI4B,SAAS,GAAG5Q,IAAI,CAACmP,IAArB;AACA,QAAI0B,WAAW,GAAG7Q,IAAI,CAACoP,MAAvB;AACA,QAAI0B,UAAU,GAAG9Q,IAAI,CAAC+Q,KAAtB;AACA,QAAI/L,QAAQ,GAAGhF,IAAI,CAACgR,GAApB;AACA,QAAIC,QAAQ,GAAGjR,IAAI,CAACyH,GAApB;AACA,QAAIyJ,UAAU,GAAGlR,IAAI,CAACqP,KAAtB;AACA,QAAI8B,UAAU,GAAGnR,IAAI,CAACsP,KAAtB,CAv3CiB,CA23CjB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAI8B,eAAe,GAAG,CAAtB;AACA,QAAIC,oBAAoB,GAAG,IAA3B;AACA,QAAIC,qBAAqB,GAAG,IAA5B,CAp4CiB,CAo4CiB;;AAClC,QAAIC,qBAAqB,GAAG,EAA5B;;AAEA,aAASC,sBAAT,CAAgCC,EAAhC,EAAoC;AAClC,UAAIC,IAAI,GAAGD,EAAX;;AACA,aAAO,CAAP,EAAU;AACR,YAAI,CAACF,qBAAqB,CAACE,EAAD,CAA1B,EAAgC,OAAOA,EAAP;AAChCA,QAAAA,EAAE,GAAGC,IAAI,GAAG1R,IAAI,CAAC2R,MAAL,EAAZ;AACD;;AACD,aAAOF,EAAP;AACD;;AAED,aAASG,gBAAT,CAA0BH,EAA1B,EAA8B;AAC5BL,MAAAA,eAAe;;AAEf,UAAI/V,MAAM,CAAC,wBAAD,CAAV,EAAsC;AACpCA,QAAAA,MAAM,CAAC,wBAAD,CAAN,CAAiC+V,eAAjC;AACD;;AAED,UAAIK,EAAJ,EAAQ;AACN5S,QAAAA,MAAM,CAAC,CAAC0S,qBAAqB,CAACE,EAAD,CAAvB,CAAN;AACAF,QAAAA,qBAAqB,CAACE,EAAD,CAArB,GAA4B,CAA5B;;AACA,YAAIJ,oBAAoB,KAAK,IAAzB,IAAiC,OAAOQ,WAAP,KAAuB,WAA5D,EAAyE;AACvE;AACAR,UAAAA,oBAAoB,GAAGQ,WAAW,CAAC,YAAW;AAC5C,gBAAIrM,KAAJ,EAAW;AACTsM,cAAAA,aAAa,CAACT,oBAAD,CAAb;AACAA,cAAAA,oBAAoB,GAAG,IAAvB;AACA;AACD;;AACD,gBAAI7Q,KAAK,GAAG,KAAZ;;AACA,iBAAK,IAAIuR,GAAT,IAAgBR,qBAAhB,EAAuC;AACrC,kBAAI,CAAC/Q,KAAL,EAAY;AACVA,gBAAAA,KAAK,GAAG,IAAR;AACAhC,gBAAAA,GAAG,CAAC,oCAAD,CAAH;AACD;;AACDA,cAAAA,GAAG,CAAC,iBAAiBuT,GAAlB,CAAH;AACD;;AACD,gBAAIvR,KAAJ,EAAW;AACThC,cAAAA,GAAG,CAAC,eAAD,CAAH;AACD;AACF,WAjBiC,EAiB/B,KAjB+B,CAAlC;AAkBD;AACF,OAxBD,MAwBO;AACLA,QAAAA,GAAG,CAAC,0CAAD,CAAH;AACD;AACF;;AAED,aAASwT,mBAAT,CAA6BP,EAA7B,EAAiC;AAC/BL,MAAAA,eAAe;;AAEf,UAAI/V,MAAM,CAAC,wBAAD,CAAV,EAAsC;AACpCA,QAAAA,MAAM,CAAC,wBAAD,CAAN,CAAiC+V,eAAjC;AACD;;AAED,UAAIK,EAAJ,EAAQ;AACN5S,QAAAA,MAAM,CAAC0S,qBAAqB,CAACE,EAAD,CAAtB,CAAN;AACA,eAAOF,qBAAqB,CAACE,EAAD,CAA5B;AACD,OAHD,MAGO;AACLjT,QAAAA,GAAG,CAAC,4CAAD,CAAH;AACD;;AACD,UAAI4S,eAAe,IAAI,CAAvB,EAA0B;AACxB,YAAIC,oBAAoB,KAAK,IAA7B,EAAmC;AACjCS,UAAAA,aAAa,CAACT,oBAAD,CAAb;AACAA,UAAAA,oBAAoB,GAAG,IAAvB;AACD;;AACD,YAAIC,qBAAJ,EAA2B;AACzB,cAAI7D,QAAQ,GAAG6D,qBAAf;AACAA,UAAAA,qBAAqB,GAAG,IAAxB;AACA7D,UAAAA,QAAQ,GAHiB,CAGb;AACb;AACF;AACF;;AAEDpS,IAAAA,MAAM,CAAC,iBAAD,CAAN,GAA4B,EAA5B,CA98CiB,CA88Ce;;AAChCA,IAAAA,MAAM,CAAC,iBAAD,CAAN,GAA4B,EAA5B,CA/8CiB,CA+8Ce;;AAGhC,aAASuD,KAAT,CAAeqT,IAAf,EAAqB;AACnB,UAAI5W,MAAM,CAAC,SAAD,CAAV,EAAuB;AACrBA,QAAAA,MAAM,CAAC,SAAD,CAAN,CAAkB4W,IAAlB;AACD;;AAEDA,MAAAA,IAAI,IAAI,EAAR;AACA7T,MAAAA,GAAG,CAAC6T,IAAD,CAAH;AACAzT,MAAAA,GAAG,CAACyT,IAAD,CAAH;AAEAzM,MAAAA,KAAK,GAAG,IAAR;AACAC,MAAAA,UAAU,GAAG,CAAb;AAEA,UAAIyM,MAAM,GAAG,WAAWD,IAAX,GAAkB,OAAlB,GAA4BE,UAAU,EAAnD;AACAF,MAAAA,IAAI,GAAGC,MAAP,CAbmB,CAenB;AACA;AACA;;AACA,YAAM,IAAItR,WAAW,CAACwR,YAAhB,CAA6BH,IAA7B,CAAN;AACD;;AAGD,QAAII,iBAAiB,GAAG,IAAxB,CAx+CiB,CA2+CjB;;AACA,QAAIC,EAAE,GAAG;AACPC,MAAAA,KAAK,EAAE,iBAAW;AAChB3T,QAAAA,KAAK,CAAC,kPAAD,CAAL;AACD,OAHM;AAIP4T,MAAAA,IAAI,EAAE,gBAAW;AAAEF,QAAAA,EAAE,CAACC,KAAH;AAAY,OAJxB;AAKPE,MAAAA,cAAc,EAAE,0BAAW;AAAEH,QAAAA,EAAE,CAACC,KAAH;AAAY,OALlC;AAMPG,MAAAA,mBAAmB,EAAE,+BAAW;AAAEJ,QAAAA,EAAE,CAACC,KAAH;AAAY,OANvC;AAOPI,MAAAA,cAAc,EAAE,0BAAW;AAAEL,QAAAA,EAAE,CAACC,KAAH;AAAY,OAPlC;AAQP7U,MAAAA,IAAI,EAAE,gBAAW;AAAE4U,QAAAA,EAAE,CAACC,KAAH;AAAY,OARxB;AASPK,MAAAA,KAAK,EAAE,iBAAW;AAAEN,QAAAA,EAAE,CAACC,KAAH;AAAY,OATzB;AAUPM,MAAAA,cAAc,EAAE,0BAAW;AAAEP,QAAAA,EAAE,CAACC,KAAH;AAAY,OAVlC;AAWPO,MAAAA,WAAW,EAAE,uBAAW;AAAER,QAAAA,EAAE,CAACC,KAAH;AAAY,OAX/B;AAYPQ,MAAAA,eAAe,EAAE,2BAAW;AAAET,QAAAA,EAAE,CAACC,KAAH;AAAY,OAZnC;AAcPS,MAAAA,UAAU,EAAE,SAASA,UAAT,GAAsB;AAAEV,QAAAA,EAAE,CAACC,KAAH;AAAY;AAdzC,KAAT;AAgBAlX,IAAAA,MAAM,CAAC,mBAAD,CAAN,GAA8BiX,EAAE,CAACG,cAAjC;AACApX,IAAAA,MAAM,CAAC,wBAAD,CAAN,GAAmCiX,EAAE,CAACI,mBAAtC,CA7/CiB,CAigDjB;AACA;AACA;AACA;AAEA;;AACA,QAAIO,aAAa,GAAG,uCAApB,CAvgDiB,CAygDjB;;AACA,aAASC,SAAT,CAAmBC,QAAnB,EAA6B;AAC3B,aAAOvK,MAAM,CAAC1F,SAAP,CAAiBkQ,UAAjB,GACHD,QAAQ,CAACC,UAAT,CAAoBH,aAApB,CADG,GAEHE,QAAQ,CAACjW,OAAT,CAAiB+V,aAAjB,MAAoC,CAFxC;AAGD;;AAKD,QAAII,cAAc,GAAG,YAArB;;AACA,QAAI,CAACH,SAAS,CAACG,cAAD,CAAd,EAAgC;AAC9BA,MAAAA,cAAc,GAAG5W,UAAU,CAAC4W,cAAD,CAA3B;AACD;;AAED,aAASC,SAAT,GAAqB;AACnB,UAAI;AACF,YAAIhP,UAAJ,EAAgB;AACd,iBAAO,IAAIxG,UAAJ,CAAewG,UAAf,CAAP;AACD;;AAED,YAAIzH,UAAJ,EAAgB;AACd,iBAAOA,UAAU,CAACwW,cAAD,CAAjB;AACD,SAFD,MAEO;AACL,gBAAM,iDAAN;AACD;AACF,OAVD,CAWA,OAAO7U,GAAP,EAAY;AACVI,QAAAA,KAAK,CAACJ,GAAD,CAAL;AACD;AACF;;AAED,aAAS+U,gBAAT,GAA4B;AAC1B;AACA;AACA,UAAI,CAACjP,UAAD,KAAgBnI,kBAAkB,IAAIC,qBAAtC,KAAgE,OAAOoX,KAAP,KAAiB,UAArF,EAAiG;AAC/F,eAAOA,KAAK,CAACH,cAAD,EAAiB;AAAEI,UAAAA,WAAW,EAAE;AAAf,SAAjB,CAAL,CAAsDC,IAAtD,CAA2D,UAAS3V,QAAT,EAAmB;AACnF,cAAI,CAACA,QAAQ,CAAC,IAAD,CAAb,EAAqB;AACnB,kBAAM,yCAAyCsV,cAAzC,GAA0D,GAAhE;AACD;;AACD,iBAAOtV,QAAQ,CAAC,aAAD,CAAR,EAAP;AACD,SALM,WAKE,YAAY;AACnB,iBAAOuV,SAAS,EAAhB;AACD,SAPM,CAAP;AAQD,OAZyB,CAa1B;;;AACA,aAAO,aAAY,UAASK,OAAT,EAAkBC,MAAlB,EAA0B;AAC3CD,QAAAA,OAAO,CAACL,SAAS,EAAV,CAAP;AACD,OAFM,CAAP;AAGD,KA1jDgB,CA8jDjB;AACA;;;AACA,aAASO,UAAT,GAAsB;AACpB;AACA,UAAIC,IAAI,GAAG;AACT,eAAOC,aADE;AAET,kCAA0BA;AAFjB,OAAX,CAFoB,CAMpB;AACA;AACA;;AACA;;AACA,eAASC,eAAT,CAAyBrS,QAAzB,EAAmCD,MAAnC,EAA2C;AACzC,YAAII,OAAO,GAAGH,QAAQ,CAACG,OAAvB;AACAzG,QAAAA,MAAM,CAAC,KAAD,CAAN,GAAgByG,OAAhB;AACAkQ,QAAAA,mBAAmB,CAAC,kBAAD,CAAnB;AACD,OAdmB,CAenB;;;AACDJ,MAAAA,gBAAgB,CAAC,kBAAD,CAAhB,CAhBoB,CAmBpB;AACA;AACA;;AACA,UAAIqC,UAAU,GAAG5Y,MAAjB;;AACA,eAAS6Y,yBAAT,CAAmChC,MAAnC,EAA2C;AACzC;AACA;AACArT,QAAAA,MAAM,CAACxD,MAAM,KAAK4Y,UAAZ,EAAwB,kHAAxB,CAAN;AACAA,QAAAA,UAAU,GAAG,IAAb,CAJyC,CAKvC;AACA;;AACFD,QAAAA,eAAe,CAAC9B,MAAM,CAAC,UAAD,CAAP,CAAf;AACD;;AAGD,eAASiC,sBAAT,CAAgCC,QAAhC,EAA0C;AACxC,eAAOb,gBAAgB,GAAGG,IAAnB,CAAwB,UAASW,MAAT,EAAiB;AAC9C,iBAAOzT,WAAW,CAAC0T,WAAZ,CAAwBD,MAAxB,EAAgCP,IAAhC,CAAP;AACD,SAFM,EAEJJ,IAFI,CAECU,QAFD,EAEW,UAASG,MAAT,EAAiB;AACjC/V,UAAAA,GAAG,CAAC,4CAA4C+V,MAA7C,CAAH;AACA3V,UAAAA,KAAK,CAAC2V,MAAD,CAAL;AACD,SALM,CAAP;AAMD,OAzCmB,CA2CpB;;;AACA,eAASC,gBAAT,GAA4B;AAC1B,YAAI,CAAClQ,UAAD,IACA,OAAO1D,WAAW,CAAC6T,oBAAnB,KAA4C,UAD5C,IAEA,CAACvB,SAAS,CAACG,cAAD,CAFV,IAGA,OAAOG,KAAP,KAAiB,UAHrB,EAGiC;AAC/BA,UAAAA,KAAK,CAACH,cAAD,EAAiB;AAAEI,YAAAA,WAAW,EAAE;AAAf,WAAjB,CAAL,CAAsDC,IAAtD,CAA2D,UAAU3V,QAAV,EAAoB;AAC7E,gBAAI2W,MAAM,GAAG9T,WAAW,CAAC6T,oBAAZ,CAAiC1W,QAAjC,EAA2C+V,IAA3C,CAAb;AACA,mBAAOY,MAAM,CAAChB,IAAP,CAAYQ,yBAAZ,EAAuC,UAASK,MAAT,EAAiB;AAC3D;AACA;AACA/V,cAAAA,GAAG,CAAC,oCAAoC+V,MAArC,CAAH;AACA/V,cAAAA,GAAG,CAAC,2CAAD,CAAH;AACA2V,cAAAA,sBAAsB,CAACD,yBAAD,CAAtB;AACD,aANI,CAAP;AAOD,WATD;AAUD,SAdD,MAcO;AACL,iBAAOC,sBAAsB,CAACD,yBAAD,CAA7B;AACD;AACF,OA9DmB,CA+DpB;AACA;AACA;;;AACA,UAAI7Y,MAAM,CAAC,iBAAD,CAAV,EAA+B;AAC7B,YAAI;AACF,cAAIyG,OAAO,GAAGzG,MAAM,CAAC,iBAAD,CAAN,CAA0ByY,IAA1B,EAAgCE,eAAhC,CAAd;AACA,iBAAOlS,OAAP;AACD,SAHD,CAGE,OAAM6S,CAAN,EAAS;AACTnW,UAAAA,GAAG,CAAC,wDAAwDmW,CAAzD,CAAH;AACA,iBAAO,KAAP;AACD;AACF;;AAEDH,MAAAA,gBAAgB;AAChB,aAAO,EAAP,CA7EoB,CA6ET;AACZ,KA9oDgB,CAipDjB;;;AACA,QAAI1P,UAAJ;AACA,QAAID,OAAJ,CAnpDiB,CAqpDjB;;AAEA,QAAI+P,UAAU,GAAG,EAAjB,CAvpDiB,CA8pDjB;;AACA;;AAA2BhH,IAAAA,UAAU,CAAC1M,IAAX,CAAgB;AAAER,MAAAA,IAAI,EAAE,gBAAW;AAAEmU,QAAAA,kBAAkB;AAAI;AAA3C,KAAhB;AAK3B;AACA;;;AAGE,aAASC,QAAT,CAAkBpU,IAAlB,EAAwB;AACpBJ,MAAAA,QAAQ,CAAC,6EAAD,CAAR;AACA,aAAOI,IAAP;AACD;;AAEH,aAASqU,WAAT,CAAqBxU,IAArB,EAA2B;AACvB,UAAIyU,KAAK,GACP,eADF;AAEA,aAAOzU,IAAI,CAACqD,OAAL,CAAaoR,KAAb,EACL,UAASzJ,CAAT,EAAY;AACV,YAAI0J,CAAC,GAAGH,QAAQ,CAACvJ,CAAD,CAAhB;AACA,eAAOA,CAAC,KAAK0J,CAAN,GAAU1J,CAAV,GAAe0J,CAAC,GAAG,IAAJ,GAAW1J,CAAX,GAAe,GAArC;AACD,OAJI,CAAP;AAKD;;AAEH,aAAS2J,YAAT,GAAwB;AACpB,UAAI1W,GAAG,GAAG,IAAIjC,KAAJ,EAAV;;AACA,UAAI,CAACiC,GAAG,CAACmI,KAAT,EAAgB;AACd;AACA;AACA,YAAI;AACF,gBAAM,IAAIpK,KAAJ,EAAN;AACD,SAFD,CAEE,OAAMoY,CAAN,EAAS;AACTnW,UAAAA,GAAG,GAAGmW,CAAN;AACD;;AACD,YAAI,CAACnW,GAAG,CAACmI,KAAT,EAAgB;AACd,iBAAO,4BAAP;AACD;AACF;;AACD,aAAOnI,GAAG,CAACmI,KAAJ,CAAUqC,QAAV,EAAP;AACD;;AAEH,aAASmJ,UAAT,GAAsB;AAClB,UAAIgD,EAAE,GAAGD,YAAY,EAArB;AACA,UAAI7Z,MAAM,CAAC,iBAAD,CAAV,EAA+B8Z,EAAE,IAAI,OAAO9Z,MAAM,CAAC,iBAAD,CAAN,EAAb;AAC/B,aAAO0Z,WAAW,CAACI,EAAD,CAAlB;AACD;;AAEH,aAASC,wBAAT,GAAoC;AAChCxW,MAAAA,KAAK,CAAC,gBAAD,CAAL;AACD;;AAEH,aAASyW,OAAT,GAAmB,CAAE;;AAErB,aAASC,SAAT,GAAqB,CAAE;;AAEvB,aAASzV,yBAAT,GAAqC;AACjC,aAAO+H,MAAM,CAACxH,MAAd;AACD;;AAEH,aAASmV,wBAAT,GAAoC;AAChC,aAAO,IAAP;AACD;;AAEH,aAASC,sBAAT,CAAgCC,IAAhC,EAAsCha,GAAtC,EAA2Cia,GAA3C,EAAgD;AAC5C9N,MAAAA,MAAM,CAACxF,GAAP,CAAWwF,MAAM,CAACD,QAAP,CAAgBlM,GAAhB,EAAqBA,GAAG,GAACia,GAAzB,CAAX,EAA0CD,IAA1C;AACD;;AAGH,aAASE,uBAAT,CAAiCC,aAAjC,EAAgD;AAC5ChX,MAAAA,KAAK,CAAC,0CAA0CgX,aAA1C,GAA0D,iGAA1D,GAA8JjR,KAAK,CAACvE,MAApK,GAA6K,oMAA9K,CAAL;AACD;;AAAA,aAASyV,uBAAT,CAAiCD,aAAjC,EAAgD;AAC/CD,MAAAA,uBAAuB,CAACC,aAAD,CAAvB;AACD;;AAGH,aAASE,mBAAT,GAA+B;AAC3B;AACA,UAAI,OAAOC,OAAP,KAAmB,WAAvB,EAAoCA,OAAO,CAAC,CAAD,CAAP;AACpC,UAAIC,OAAO,GAAGC,QAAQ,CAACD,OAAvB;AACA,UAAIA,OAAO,CAAC,CAAD,CAAP,CAAW5V,MAAf,EAAuB6V,QAAQ,CAACC,SAAT,CAAmB,CAAnB,EAAsB,EAAtB;AACvB,UAAIF,OAAO,CAAC,CAAD,CAAP,CAAW5V,MAAf,EAAuB6V,QAAQ,CAACC,SAAT,CAAmB,CAAnB,EAAsB,EAAtB;AACxB;;AAGH,QAAIC,IAAI,GAAC;AAACC,MAAAA,SAAS,EAAC,mBAASjD,QAAT,EAAmB;AACjC,YAAIkD,WAAW,GAAG,+DAAlB;AACA,eAAOA,WAAW,CAACC,IAAZ,CAAiBnD,QAAjB,EAA2B9R,KAA3B,CAAiC,CAAjC,CAAP;AACD,OAHI;AAGHkV,MAAAA,cAAc,EAAC,wBAASC,KAAT,EAAgBC,cAAhB,EAAgC;AAC/C;AACA,YAAIC,EAAE,GAAG,CAAT;;AACA,aAAK,IAAIzV,CAAC,GAAGuV,KAAK,CAACpW,MAAN,GAAe,CAA5B,EAA+Ba,CAAC,IAAI,CAApC,EAAuCA,CAAC,EAAxC,EAA4C;AAC1C,cAAI0V,IAAI,GAAGH,KAAK,CAACvV,CAAD,CAAhB;;AACA,cAAI0V,IAAI,KAAK,GAAb,EAAkB;AAChBH,YAAAA,KAAK,CAACI,MAAN,CAAa3V,CAAb,EAAgB,CAAhB;AACD,WAFD,MAEO,IAAI0V,IAAI,KAAK,IAAb,EAAmB;AACxBH,YAAAA,KAAK,CAACI,MAAN,CAAa3V,CAAb,EAAgB,CAAhB;AACAyV,YAAAA,EAAE;AACH,WAHM,MAGA,IAAIA,EAAJ,EAAQ;AACbF,YAAAA,KAAK,CAACI,MAAN,CAAa3V,CAAb,EAAgB,CAAhB;AACAyV,YAAAA,EAAE;AACH;AACF,SAd8C,CAe/C;;;AACA,YAAID,cAAJ,EAAoB;AAClB,iBAAOC,EAAP,EAAWA,EAAE,EAAb,EAAiB;AACfF,YAAAA,KAAK,CAAC/H,OAAN,CAAc,IAAd;AACD;AACF;;AACD,eAAO+H,KAAP;AACD,OAzBI;AAyBHK,MAAAA,SAAS,EAAC,mBAASna,IAAT,EAAe;AACzB,YAAIoa,UAAU,GAAGpa,IAAI,CAACgI,MAAL,CAAY,CAAZ,MAAmB,GAApC;AAAA,YACIqS,aAAa,GAAGra,IAAI,CAACS,MAAL,CAAY,CAAC,CAAb,MAAoB,GADxC,CADyB,CAGzB;;AACAT,QAAAA,IAAI,GAAGyZ,IAAI,CAACI,cAAL,CAAoB7Z,IAAI,CAACsa,KAAL,CAAW,GAAX,EAAgBC,MAAhB,CAAuB,UAASC,CAAT,EAAY;AAC5D,iBAAO,CAAC,CAACA,CAAT;AACD,SAF0B,CAApB,EAEH,CAACJ,UAFE,EAEUK,IAFV,CAEe,GAFf,CAAP;;AAGA,YAAI,CAACza,IAAD,IAAS,CAACoa,UAAd,EAA0B;AACxBpa,UAAAA,IAAI,GAAG,GAAP;AACD;;AACD,YAAIA,IAAI,IAAIqa,aAAZ,EAA2B;AACzBra,UAAAA,IAAI,IAAI,GAAR;AACD;;AACD,eAAO,CAACoa,UAAU,GAAG,GAAH,GAAS,EAApB,IAA0Bpa,IAAjC;AACD,OAvCI;AAuCH0a,MAAAA,OAAO,EAAC,iBAAS1a,IAAT,EAAe;AACvB,YAAIgY,MAAM,GAAGyB,IAAI,CAACC,SAAL,CAAe1Z,IAAf,CAAb;AAAA,YACI2a,IAAI,GAAG3C,MAAM,CAAC,CAAD,CADjB;AAAA,YAEI4C,GAAG,GAAG5C,MAAM,CAAC,CAAD,CAFhB;;AAGA,YAAI,CAAC2C,IAAD,IAAS,CAACC,GAAd,EAAmB;AACjB;AACA,iBAAO,GAAP;AACD;;AACD,YAAIA,GAAJ,EAAS;AACP;AACAA,UAAAA,GAAG,GAAGA,GAAG,CAACna,MAAJ,CAAW,CAAX,EAAcma,GAAG,CAAClX,MAAJ,GAAa,CAA3B,CAAN;AACD;;AACD,eAAOiX,IAAI,GAAGC,GAAd;AACD,OApDI;AAoDHC,MAAAA,QAAQ,EAAC,kBAAS7a,IAAT,EAAe;AACxB;AACA,YAAIA,IAAI,KAAK,GAAb,EAAkB,OAAO,GAAP;AAClB,YAAI8a,SAAS,GAAG9a,IAAI,CAACU,WAAL,CAAiB,GAAjB,CAAhB;AACA,YAAIoa,SAAS,KAAK,CAAC,CAAnB,EAAsB,OAAO9a,IAAP;AACtB,eAAOA,IAAI,CAACS,MAAL,CAAYqa,SAAS,GAAC,CAAtB,CAAP;AACD,OA1DI;AA0DHC,MAAAA,OAAO,EAAC,iBAAS/a,IAAT,EAAe;AACvB,eAAOyZ,IAAI,CAACC,SAAL,CAAe1Z,IAAf,EAAqB,CAArB,CAAP;AACD,OA5DI;AA4DHya,MAAAA,IAAI,EAAC,gBAAW;AAChB,YAAIO,KAAK,GAAGzU,KAAK,CAACC,SAAN,CAAgB7B,KAAhB,CAAsB8B,IAAtB,CAA2BC,SAA3B,EAAsC,CAAtC,CAAZ;AACA,eAAO+S,IAAI,CAACU,SAAL,CAAea,KAAK,CAACP,IAAN,CAAW,GAAX,CAAf,CAAP;AACD,OA/DI;AA+DHQ,MAAAA,KAAK,EAAC,eAASC,CAAT,EAAYC,CAAZ,EAAe;AACrB,eAAO1B,IAAI,CAACU,SAAL,CAAee,CAAC,GAAG,GAAJ,GAAUC,CAAzB,CAAP;AACD;AAjEI,KAAT;AAiEO,QAAI5B,QAAQ,GAAC;AAACD,MAAAA,OAAO,EAAC,CAAC,IAAD,EAAM,EAAN,EAAS,EAAT,CAAT;AAAsBE,MAAAA,SAAS,EAAC,mBAAS4B,MAAT,EAAiB/P,IAAjB,EAAuB;AACrE,YAAI+C,MAAM,GAAGmL,QAAQ,CAACD,OAAT,CAAiB8B,MAAjB,CAAb;AACAjZ,QAAAA,MAAM,CAACiM,MAAD,CAAN;;AACA,YAAI/C,IAAI,KAAK,CAAT,IAAcA,IAAI,KAAK,EAA3B,EAA+B;AAC7B,WAAC+P,MAAM,KAAK,CAAX,GAAe1Z,GAAf,GAAqBI,GAAtB,EAA2B4J,iBAAiB,CAAC0C,MAAD,EAAS,CAAT,CAA5C;AACAA,UAAAA,MAAM,CAAC1K,MAAP,GAAgB,CAAhB;AACD,SAHD,MAGO;AACL0K,UAAAA,MAAM,CAAC5J,IAAP,CAAY6G,IAAZ;AACD;AACF,OATe;AASdgQ,MAAAA,OAAO,EAAC,CATM;AASJpZ,MAAAA,GAAG,EAAC,aAASoZ,OAAT,EAAkB;AAChC9B,QAAAA,QAAQ,CAAC8B,OAAT,IAAoB,CAApB;AACA,YAAIrY,GAAG,GAAGC,MAAM,CAAIsW,QAAQ,CAAC8B,OAAV,GAAoB,CAArB,IAA0B,CAA5B,CAAhB;AACA,eAAOrY,GAAP;AACD,OAbe;AAadsY,MAAAA,MAAM,EAAC,kBAAW;AAClB,YAAItY,GAAG,GAAG8G,YAAY,CAACyP,QAAQ,CAACtX,GAAT,EAAD,CAAtB;AACA,eAAOe,GAAP;AACD,OAhBe;AAgBduY,MAAAA,KAAK,EAAC,iBAAW;AACjB,YAAI3U,GAAG,GAAG2S,QAAQ,CAACtX,GAAT,EAAV;AAAA,YAA0B4E,IAAI,GAAG0S,QAAQ,CAACtX,GAAT,EAAjC;AACA,YAAI2E,GAAG,IAAI,CAAX,EAAczE,MAAM,CAAC0E,IAAI,KAAK,CAAV,CAAN,CAAd,KACK1E,MAAM,CAAC0E,IAAI,KAAK,CAAC,CAAX,CAAN;AACL,eAAOD,GAAP;AACD,OArBe;AAqBd4U,MAAAA,OAAO,EAAC,mBAAW;AACnBrZ,QAAAA,MAAM,CAACoX,QAAQ,CAACtX,GAAT,OAAmB,CAApB,CAAN;AACD;AAvBe,KAAb;;AAuBA,aAASwZ,SAAT,CAAmBC,EAAnB,EAAuBC,GAAvB,EAA4BC,MAA5B,EAAoCC,IAApC,EAA0C;AAAC,UAAI;AAElD;AACA,YAAI7C,GAAG,GAAG,CAAV;;AACA,aAAK,IAAIzU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqX,MAApB,EAA4BrX,CAAC,EAA7B,EAAiC;AAC/B,cAAIwC,GAAG,GAAG9D,MAAM,CAAI0Y,GAAD,GAAOpX,CAAC,GAAC,CAAV,IAAe,CAAjB,CAAhB;AACA,cAAIkF,GAAG,GAAGxG,MAAM,CAAI0Y,GAAD,IAAOpX,CAAC,GAAC,CAAF,GAAM,CAAb,CAAD,IAAmB,CAArB,CAAhB;;AACA,eAAK,IAAIuX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrS,GAApB,EAAyBqS,CAAC,EAA1B,EAA8B;AAC5BvC,YAAAA,QAAQ,CAACC,SAAT,CAAmBkC,EAAnB,EAAuBxQ,MAAM,CAACnE,GAAG,GAAC+U,CAAL,CAA7B;AACD;;AACD9C,UAAAA,GAAG,IAAIvP,GAAP;AACD;;AACDxG,QAAAA,MAAM,CAAG4Y,IAAD,IAAQ,CAAV,CAAN,GAAoB7C,GAApB;AACA,eAAO,CAAP;AACD,OAd+C,CAc9C,OAAOf,CAAP,EAAU;AACZ,YAAI,OAAOrC,EAAP,KAAc,WAAd,IAA6B,EAAEqC,CAAC,YAAYrC,EAAE,CAACU,UAAlB,CAAjC,EAAgEpU,KAAK,CAAC+V,CAAD,CAAL;AAChE,eAAOA,CAAC,CAAC8D,KAAT;AACD;AACA;;AAGD,aAASC,OAAT,CAAiBjD,IAAjB,EAAuBha,GAAvB,EAA4Bia,GAA5B,EAAiC;AAC7BD,MAAAA,IAAI,GAAGA,IAAI,GAAC,CAAZ;AAAeha,MAAAA,GAAG,GAAGA,GAAG,GAAC,CAAV;AAAaia,MAAAA,GAAG,GAAGA,GAAG,GAAC,CAAV;AAC5B,UAAIhW,GAAG,GAAG,CAAV;AACA,UAAIiZ,gBAAgB,GAAG,CAAvB;AACA,UAAIC,sBAAsB,GAAG,CAA7B;AACA,UAAIC,QAAQ,GAAG,CAAf,CAL6B,CAM7B;;AACA,UAAI,CAACnD,GAAG,GAAC,CAAL,KAAW,IAAf,EAAqB;AACnBF,QAAAA,sBAAsB,CAACC,IAAI,GAAC,CAAN,EAASha,GAAG,GAAC,CAAb,EAAgBia,GAAG,GAAC,CAApB,CAAtB,GAA6C,CAA7C;AACA,eAAOD,IAAI,GAAC,CAAZ;AACD;;AAED/V,MAAAA,GAAG,GAAG+V,IAAI,GAAC,CAAX;AACAoD,MAAAA,QAAQ,GAAIpD,IAAI,GAAGC,GAAR,GAAa,CAAxB;;AACA,UAAI,CAACD,IAAI,GAAC,CAAN,MAAaha,GAAG,GAAC,CAAjB,CAAJ,EAAyB;AACvB;AACA,eAAOga,IAAI,GAAG,CAAd,EAAiB;AACf,cAAI,CAACC,GAAG,GAAC,CAAL,KAAW,CAAf,EAAkB,OAAOhW,GAAG,GAAC,CAAX;AAClBiF,UAAAA,KAAK,CAAG8Q,IAAD,IAAQ,CAAV,CAAL,GAAqB9Q,KAAK,CAAGlJ,GAAD,IAAO,CAAT,CAAN,GAAoB,CAAxC;AACAga,UAAAA,IAAI,GAAIA,IAAI,GAAC,CAAN,GAAS,CAAhB;AACAha,UAAAA,GAAG,GAAIA,GAAG,GAAC,CAAL,GAAQ,CAAd;AACAia,UAAAA,GAAG,GAAIA,GAAG,GAAC,CAAL,GAAQ,CAAd;AACD;;AACDiD,QAAAA,gBAAgB,GAAIE,QAAQ,GAAG,CAAC,CAAb,GAAgB,CAAnC;AACAD,QAAAA,sBAAsB,GAAID,gBAAgB,GAAG,EAApB,GAAwB,CAAjD;;AACA,eAAO,CAAClD,IAAI,GAAC,CAAN,MAAamD,sBAAsB,GAAC,CAApC,CAAP,EAAgD;AAC9CjZ,UAAAA,MAAM,CAAG8V,IAAD,IAAQ,CAAV,CAAN,GAAsB9V,MAAM,CAAGlE,GAAD,IAAO,CAAT,CAAP,GAAqB,CAA1C;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,CAAT,IAAc,CAAhB,CAAN,GAA4B9V,MAAM,CAAIlE,GAAD,GAAO,CAAR,IAAa,CAAf,CAAP,GAA2B,CAAtD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,CAAT,IAAc,CAAhB,CAAN,GAA4B9V,MAAM,CAAIlE,GAAD,GAAO,CAAR,IAAa,CAAf,CAAP,GAA2B,CAAtD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAkE,UAAAA,MAAM,CAAI8V,IAAD,GAAQ,EAAT,IAAe,CAAjB,CAAN,GAA6B9V,MAAM,CAAIlE,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAP,GAA4B,CAAxD;AACAga,UAAAA,IAAI,GAAIA,IAAI,GAAC,EAAN,GAAU,CAAjB;AACAha,UAAAA,GAAG,GAAIA,GAAG,GAAC,EAAL,GAAS,CAAf;AACD;;AACD,eAAO,CAACga,IAAI,GAAC,CAAN,KAAYkD,gBAAgB,GAAC,CAA7B,CAAP,EAAyC;AACvChZ,UAAAA,MAAM,CAAG8V,IAAD,IAAQ,CAAV,CAAN,GAAsB9V,MAAM,CAAGlE,GAAD,IAAO,CAAT,CAAP,GAAqB,CAA1C;AACAga,UAAAA,IAAI,GAAIA,IAAI,GAAC,CAAN,GAAS,CAAhB;AACAha,UAAAA,GAAG,GAAIA,GAAG,GAAC,CAAL,GAAQ,CAAd;AACD;AACF,OApCD,MAoCO;AACL;AACAkd,QAAAA,gBAAgB,GAAIE,QAAQ,GAAG,CAAZ,GAAe,CAAlC;;AACA,eAAO,CAACpD,IAAI,GAAC,CAAN,KAAYkD,gBAAgB,GAAC,CAA7B,CAAP,EAAyC;AACvChU,UAAAA,KAAK,CAAG8Q,IAAD,IAAQ,CAAV,CAAL,GAAqB9Q,KAAK,CAAGlJ,GAAD,IAAO,CAAT,CAAN,GAAoB,CAAxC;AACAkJ,UAAAA,KAAK,CAAI8Q,IAAD,GAAQ,CAAT,IAAc,CAAhB,CAAL,GAA2B9Q,KAAK,CAAIlJ,GAAD,GAAO,CAAR,IAAa,CAAf,CAAN,GAA0B,CAApD;AACAkJ,UAAAA,KAAK,CAAI8Q,IAAD,GAAQ,CAAT,IAAc,CAAhB,CAAL,GAA2B9Q,KAAK,CAAIlJ,GAAD,GAAO,CAAR,IAAa,CAAf,CAAN,GAA0B,CAApD;AACAkJ,UAAAA,KAAK,CAAI8Q,IAAD,GAAQ,CAAT,IAAc,CAAhB,CAAL,GAA2B9Q,KAAK,CAAIlJ,GAAD,GAAO,CAAR,IAAa,CAAf,CAAN,GAA0B,CAApD;AACAga,UAAAA,IAAI,GAAIA,IAAI,GAAC,CAAN,GAAS,CAAhB;AACAha,UAAAA,GAAG,GAAIA,GAAG,GAAC,CAAL,GAAQ,CAAd;AACD;AACF,OA7D4B,CA8D7B;;;AACA,aAAO,CAACga,IAAI,GAAC,CAAN,KAAYoD,QAAQ,GAAC,CAArB,CAAP,EAAgC;AAC9BlU,QAAAA,KAAK,CAAG8Q,IAAD,IAAQ,CAAV,CAAL,GAAqB9Q,KAAK,CAAGlJ,GAAD,IAAO,CAAT,CAAN,GAAoB,CAAxC;AACAga,QAAAA,IAAI,GAAIA,IAAI,GAAC,CAAN,GAAS,CAAhB;AACAha,QAAAA,GAAG,GAAIA,GAAG,GAAC,CAAL,GAAQ,CAAd;AACD;;AACD,aAAOiE,GAAG,GAAC,CAAX;AACD;;AAEH,aAASoZ,OAAT,CAAiBrV,GAAjB,EAAsBO,KAAtB,EAA6B0R,GAA7B,EAAkC;AAC9BjS,MAAAA,GAAG,GAAGA,GAAG,GAAC,CAAV;AAAaO,MAAAA,KAAK,GAAGA,KAAK,GAAC,CAAd;AAAiB0R,MAAAA,GAAG,GAAGA,GAAG,GAAC,CAAV;AAC9B,UAAI9V,GAAG,GAAG,CAAV;AAAA,UAAamZ,WAAW,GAAG,CAA3B;AAAA,UAA8BC,iBAAiB,GAAG,CAAlD;AAAA,UAAqDC,MAAM,GAAG,CAA9D;AACArZ,MAAAA,GAAG,GAAI6D,GAAG,GAAGiS,GAAP,GAAY,CAAlB;AAEA1R,MAAAA,KAAK,GAAGA,KAAK,GAAG,IAAhB;;AACA,UAAI,CAAC0R,GAAG,GAAC,CAAL,KAAW;AAAG;AAAlB,QAAmF;AACjF,iBAAO,CAACjS,GAAG,GAAC,CAAL,KAAW,CAAlB,EAAqB;AACnBkB,YAAAA,KAAK,CAAGlB,GAAD,IAAO,CAAT,CAAL,GAAkBO,KAAlB;AACAP,YAAAA,GAAG,GAAIA,GAAG,GAAC,CAAL,GAAQ,CAAd;AACD;;AAEDsV,UAAAA,WAAW,GAAInZ,GAAG,GAAG,CAAC,CAAR,GAAW,CAAzB;AACAqZ,UAAAA,MAAM,GAAGjV,KAAK,GAAIA,KAAK,IAAI,CAAlB,GAAwBA,KAAK,IAAI,EAAjC,GAAwCA,KAAK,IAAI,EAA1D;AAEAgV,UAAAA,iBAAiB,GAAID,WAAW,GAAG,EAAf,GAAmB,CAAvC;;AAEA,iBAAM,CAACtV,GAAG,GAAC,CAAL,MAAYuV,iBAAiB,GAAC,CAA9B,CAAN,EAAwC;AACtCrZ,YAAAA,MAAM,CAAG8D,GAAD,IAAO,CAAT,CAAN,GAAmBwV,MAAnB;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,CAAR,IAAa,CAAf,CAAN,GAAyBwV,MAAzB;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,CAAR,IAAa,CAAf,CAAN,GAAyBwV,MAAzB;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAtZ,YAAAA,MAAM,CAAI8D,GAAD,GAAO,EAAR,IAAc,CAAhB,CAAN,GAA0BwV,MAA1B;AACAxV,YAAAA,GAAG,GAAIA,GAAG,GAAG,EAAP,GAAW,CAAjB;AACD;;AAED,iBAAO,CAACA,GAAG,GAAC,CAAL,KAAWsV,WAAW,GAAC,CAAvB,CAAP,EAAmC;AACjCpZ,YAAAA,MAAM,CAAG8D,GAAD,IAAO,CAAT,CAAN,GAAmBwV,MAAnB;AACAxV,YAAAA,GAAG,GAAIA,GAAG,GAAC,CAAL,GAAQ,CAAd;AACD;AACF,SAzC6B,CA0C9B;;;AACA,aAAO,CAACA,GAAG,GAAC,CAAL,KAAW7D,GAAG,GAAC,CAAf,CAAP,EAA0B;AACxB+E,QAAAA,KAAK,CAAGlB,GAAD,IAAO,CAAT,CAAL,GAAkBO,KAAlB;AACAP,QAAAA,GAAG,GAAIA,GAAG,GAAC,CAAL,GAAQ,CAAd;AACD;;AACD,aAAQ7D,GAAG,GAAC8V,GAAL,GAAU,CAAjB;AACD;;AAEH,aAASwD,YAAT,CAAsBC,EAAtB,EAA0B;AACtBpV,MAAAA,WAAW,CAAEoV,EAAD,GAAO,CAAR,CAAX;AACD;;AACL,QAAIC,UAAU,GAAG,IAAjB,CA59DiB,CA89DjB;AACA;AACA;AACA;;AAEA;;AACA,aAASC,kBAAT,CAA4BC,OAA5B,EAAqCvO,WAArC,EAAkD3K,MAAlD,EAA0D;AACxD,UAAI+F,GAAG,GAAG/F,MAAM,GAAG,CAAT,GAAaA,MAAb,GAAsBsJ,eAAe,CAAC4P,OAAD,CAAf,GAAyB,CAAzD;AACA,UAAIC,OAAO,GAAG,IAAItW,KAAJ,CAAUkD,GAAV,CAAd;AACA,UAAIqT,eAAe,GAAGtQ,iBAAiB,CAACoQ,OAAD,EAAUC,OAAV,EAAmB,CAAnB,EAAsBA,OAAO,CAACnZ,MAA9B,CAAvC;AACA,UAAI2K,WAAJ,EAAiBwO,OAAO,CAACnZ,MAAR,GAAiBoZ,eAAjB;AACjB,aAAOD,OAAP;AACD;;AAED,aAASE,gBAAT,CAA0BvO,KAA1B,EAAiC;AAC/B,UAAIxL,GAAG,GAAG,EAAV;;AACA,WAAK,IAAIuB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiK,KAAK,CAAC9K,MAA1B,EAAkCa,CAAC,EAAnC,EAAuC;AACrC,YAAIyY,GAAG,GAAGxO,KAAK,CAACjK,CAAD,CAAf;;AACA,YAAIyY,GAAG,GAAG,IAAV,EAAgB;AACd,cAAIN,UAAJ,EAAgB;AACdva,YAAAA,MAAM,CAAC,KAAD,EAAQ,oBAAoB6a,GAApB,GAA0B,IAA1B,GAAiC9Q,MAAM,CAACC,YAAP,CAAoB6Q,GAApB,CAAjC,GAA4D,eAA5D,GAA8EzY,CAA9E,GAAkF,oBAA1F,CAAN;AACD;;AACDyY,UAAAA,GAAG,IAAI,IAAP;AACD;;AACDha,QAAAA,GAAG,CAACwB,IAAJ,CAAS0H,MAAM,CAACC,YAAP,CAAoB6Q,GAApB,CAAT;AACD;;AACD,aAAOha,GAAG,CAACyX,IAAJ,CAAS,EAAT,CAAP;AACD,KAz/DgB,CA4/DjB;;;AAEA,QAAIwC,YAAY,GAAG,EAAnB;AACA,QAAI5F,aAAa,GAAG;AAAE,iCAA2BqB,wBAA7B;AAAuD,gBAAUC,OAAjE;AAA0E,kBAAYC,SAAtF;AAAiG,iCAA2BC,wBAA5H;AAAsJ,+BAAyBC,sBAA/K;AAAuM,gCAA0BK,uBAAjO;AAA0P,kBAAYsC,SAAtQ;AAAiR,gBAAU7S,UAA3R;AAAuS,qBAAe4T,YAAtT;AAAoU,eAASjX;AAA7U,KAApB;AACA,QAAI2X,GAAG,GAAG/F,UAAU,EAApB;AACAxY,IAAAA,MAAM,CAAC,KAAD,CAAN,GAAgBue,GAAhB;;AACA,QAAI/E,kBAAkB,GAAGxZ,MAAM,CAAC,oBAAD,CAAN,GAA+B,YAAW;AACjEwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,mBAAd,EAAmCwI,KAAnC,CAAyC,IAAzC,EAA+CT,SAA/C,CAAP;AACD,KAJD;;AAMA,QAAIyW,KAAK,GAAGxe,MAAM,CAAC,OAAD,CAAN,GAAkB,YAAW;AACvCwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,MAAd,EAAsBwI,KAAtB,CAA4B,IAA5B,EAAkCT,SAAlC,CAAP;AACD,KAJD;;AAMA,QAAI0W,iBAAiB,GAAGze,MAAM,CAAC,mBAAD,CAAN,GAA8B,YAAW;AAC/DwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,kBAAd,EAAkCwI,KAAlC,CAAwC,IAAxC,EAA8CT,SAA9C,CAAP;AACD,KAJD;;AAMA,QAAI2S,OAAO,GAAG1a,MAAM,CAAC,SAAD,CAAN,GAAoB,YAAW;AAC3CwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,QAAd,EAAwBwI,KAAxB,CAA8B,IAA9B,EAAoCT,SAApC,CAAP;AACD,KAJD;;AAMA,QAAI2W,SAAS,GAAG1e,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAW;AAC/CwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,UAAd,EAA0BwI,KAA1B,CAAgC,IAAhC,EAAsCT,SAAtC,CAAP;AACD,KAJD;;AAMA,QAAIoE,OAAO,GAAGnM,MAAM,CAAC,SAAD,CAAN,GAAoB,YAAW;AAC3CwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,QAAd,EAAwBwI,KAAxB,CAA8B,IAA9B,EAAoCT,SAApC,CAAP;AACD,KAJD;;AAMA,QAAI4W,KAAK,GAAG3e,MAAM,CAAC,OAAD,CAAN,GAAkB,YAAW;AACvCwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,MAAd,EAAsBwI,KAAtB,CAA4B,IAA5B,EAAkCT,SAAlC,CAAP;AACD,KAJD;;AAMA,QAAI6W,kBAAkB,GAAG5e,MAAM,CAAC,oBAAD,CAAN,GAA+B,YAAW;AACjEwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,mBAAd,EAAmCwI,KAAnC,CAAyC,IAAzC,EAA+CT,SAA/C,CAAP;AACD,KAJD;;AAMA,QAAIjE,SAAS,GAAG9D,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAW;AAC/CwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,WAAd,EAA2BwI,KAA3B,CAAiC,IAAjC,EAAuCT,SAAvC,CAAP;AACD,KAJD;;AAMA,QAAI/D,UAAU,GAAGhE,MAAM,CAAC,YAAD,CAAN,GAAuB,YAAW;AACjDwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,YAAd,EAA4BwI,KAA5B,CAAkC,IAAlC,EAAwCT,SAAxC,CAAP;AACD,KAJD;;AAMA,QAAIhE,YAAY,GAAG/D,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AACrDwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,cAAd,EAA8BwI,KAA9B,CAAoC,IAApC,EAA0CT,SAA1C,CAAP;AACD,KAJD;;AAMA,QAAI8W,gBAAgB,GAAG7e,MAAM,CAAC,kBAAD,CAAN,GAA6B,YAAW;AAC7DwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,kBAAd,EAAkCwI,KAAlC,CAAwC,IAAxC,EAA8CT,SAA9C,CAAP;AACD,KAJD;;AAMA,QAAI+W,UAAU,GAAG9e,MAAM,CAAC,YAAD,CAAN,GAAuB,YAAW;AACjDwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,YAAd,EAA4BwI,KAA5B,CAAkC,IAAlC,EAAwCT,SAAxC,CAAP;AACD,KAJD;;AAMA,QAAIgX,YAAY,GAAG/e,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AACrDwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,cAAd,EAA8BwI,KAA9B,CAAoC,IAApC,EAA0CT,SAA1C,CAAP;AACD,KAJD;;AAMA,QAAIiX,YAAY,GAAGhf,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AACrDwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,cAAd,EAA8BwI,KAA9B,CAAoC,IAApC,EAA0CT,SAA1C,CAAP;AACD,KAJD;;AAMA,QAAIkX,eAAe,GAAGjf,MAAM,CAAC,iBAAD,CAAN,GAA4B,YAAW;AAC3DwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,iBAAd,EAAiCwI,KAAjC,CAAuC,IAAvC,EAA6CT,SAA7C,CAAP;AACD,KAJD;;AAMA,QAAImX,WAAW,GAAGlf,MAAM,CAAC,aAAD,CAAN,GAAwB,YAAW;AACnDwD,MAAAA,MAAM,CAACoJ,kBAAD,EAAqB,kFAArB,CAAN;AACApJ,MAAAA,MAAM,CAAC,CAACmP,aAAF,EAAiB,kFAAjB,CAAN;AACA,aAAO3S,MAAM,CAAC,KAAD,CAAN,CAAc,aAAd,EAA6BwI,KAA7B,CAAmC,IAAnC,EAAyCT,SAAzC,CAAP;AACD,KAJD,CAlmEiB,CA2mEjB;;;AAEA/H,IAAAA,MAAM,CAAC,KAAD,CAAN,GAAgBue,GAAhB;AAEA,QAAI,CAAC,iCAAgCve,MAAhC,EAAwC,oBAAxC,CAAL,EAAoEA,MAAM,CAAC,oBAAD,CAAN,GAA+B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,+FAAD,CAAL;AAAwG,KAApJ;AACpE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,kBAAxC,CAAL,EAAkEA,MAAM,CAAC,kBAAD,CAAN,GAA6B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,6FAAD,CAAL;AAAsG,KAAhJ;AAClE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,OAAxC,CAAL,EAAuDA,MAAM,CAAC,OAAD,CAAN,GAAkB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,kFAAD,CAAL;AAA2F,KAA1H;AACvD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,OAAxC,CAAL,EAAuDA,MAAM,CAAC,OAAD,CAAN,GAAkB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,kFAAD,CAAL;AAA2F,KAA1H;AACvD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,WAAxC,CAAL,EAA2DA,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,iLAAD,CAAL;AAA0L,KAA7N;AAC3D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,mBAAxC,CAAL,EAAmEA,MAAM,CAAC,mBAAD,CAAN,GAA8B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,8FAAD,CAAL;AAAuG,KAAlJ;AACnE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,cAAxC,CAAL,EAA8DA,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG,KAAxI;AAC9D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,mBAAxC,CAAL,EAAmEA,MAAM,CAAC,mBAAD,CAAN,GAA8B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,8FAAD,CAAL;AAAuG,KAAlJ;AACnE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,cAAxC,CAAL,EAA8DA,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG,KAAxI;AAC9D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,iBAAxC,CAAL,EAAiEA,MAAM,CAAC,iBAAD,CAAN,GAA4B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,4FAAD,CAAL;AAAqG,KAA9I;AACjE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,YAAxC,CAAL,EAA4DA,MAAM,CAAC,YAAD,CAAN,GAAuB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,uFAAD,CAAL;AAAgG,KAApI;AAC5D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,aAAxC,CAAL,EAA6DA,MAAM,CAAC,aAAD,CAAN,GAAwB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,wFAAD,CAAL;AAAiG,KAAtI;AAC7D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,WAAxC,CAAL,EAA2DA,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,sFAAD,CAAL;AAA+F,KAAlI;AAC3D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,cAAxC,CAAL,EAA8DA,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG,KAAxI;AAC9D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,WAAxC,CAAL,EAA2DA,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,sFAAD,CAAL;AAA+F,KAAlI;AAC3D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,cAAxC,CAAL,EAA8DA,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG,KAAxI;AAC9D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,qBAAxC,CAAL,EAAqEA,MAAM,CAAC,qBAAD,CAAN,GAAgC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,gGAAD,CAAL;AAAyG,KAAtJ;AACrE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,oBAAxC,CAAL,EAAoEA,MAAM,CAAC,oBAAD,CAAN,GAA+B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,+FAAD,CAAL;AAAwG,KAApJ;AACpE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,oBAAxC,CAAL,EAAoEA,MAAM,CAAC,oBAAD,CAAN,GAA+B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,+FAAD,CAAL;AAAwG,KAApJ;AACpE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,kBAAxC,CAAL,EAAkEA,MAAM,CAAC,kBAAD,CAAN,GAA6B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,wLAAD,CAAL;AAAiM,KAA3O;AAClE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,qBAAxC,CAAL,EAAqEA,MAAM,CAAC,qBAAD,CAAN,GAAgC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,2LAAD,CAAL;AAAoM,KAAjP;AACrE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,iBAAxC,CAAL,EAAiEA,MAAM,CAAC,iBAAD,CAAN,GAA4B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,uLAAD,CAAL;AAAgM,KAAzO;AACjE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qLAAD,CAAL;AAA8L,KAArO;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,mBAAxC,CAAL,EAAmEA,MAAM,CAAC,mBAAD,CAAN,GAA8B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yLAAD,CAAL;AAAkM,KAA7O;AACnE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,wBAAxC,CAAL,EAAwEA,MAAM,CAAC,wBAAD,CAAN,GAAmC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,8LAAD,CAAL;AAAuM,KAAvP;AACxE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,mBAAxC,CAAL,EAAmEA,MAAM,CAAC,mBAAD,CAAN,GAA8B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yLAAD,CAAL;AAAkM,KAA7O;AACnE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qLAAD,CAAL;AAA8L,KAArO;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,iBAAxC,CAAL,EAAiEA,MAAM,CAAC,iBAAD,CAAN,GAA4B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,uLAAD,CAAL;AAAgM,KAAzO;AACjE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,WAAxC,CAAL,EAA2DA,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,iLAAD,CAAL;AAA0L,KAA7N;AAC3D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,cAAxC,CAAL,EAA8DA,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG,KAAxI;AAC9D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,oBAAxC,CAAL,EAAoEA,MAAM,CAAC,oBAAD,CAAN,GAA+B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,+FAAD,CAAL;AAAwG,KAApJ;AACpE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,uBAAxC,CAAL,EAAuEA,MAAM,CAAC,uBAAD,CAAN,GAAkC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,kGAAD,CAAL;AAA2G,KAA1J;AACvE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,QAAxC,CAAL,EAAwDA,MAAM,CAAC,QAAD,CAAN,GAAmB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,mFAAD,CAAL;AAA4F,KAA5H;AACxD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,mBAAxC,CAAL,EAAmEA,MAAM,CAAC,mBAAD,CAAN,GAA8B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,8FAAD,CAAL;AAAuG,KAAlJ;AACnE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,qBAAxC,CAAL,EAAqEA,MAAM,CAAC,qBAAD,CAAN,GAAgC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,gGAAD,CAAL;AAAyG,KAAtJ;AACrE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,mBAAxC,CAAL,EAAmEA,MAAM,CAAC,mBAAD,CAAN,GAA8B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,8FAAD,CAAL;AAAuG,KAAlJ;AACnE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,aAAxC,CAAL,EAA6DA,MAAM,CAAC,aAAD,CAAN,GAAwB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,wFAAD,CAAL;AAAiG,KAAtI;AAC7D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,gBAAxC,CAAL,EAAgEA,MAAM,CAAC,gBAAD,CAAN,GAA2B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,2FAAD,CAAL;AAAoG,KAA5I;AAChE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,gBAAxC,CAAL,EAAgEA,MAAM,CAAC,gBAAD,CAAN,GAA2B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,2FAAD,CAAL;AAAoG,KAA5I;AAChE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,aAAxC,CAAL,EAA6DA,MAAM,CAAC,aAAD,CAAN,GAAwB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,wFAAD,CAAL;AAAiG,KAAtI;AAC7D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,YAAxC,CAAL,EAA4DA,MAAM,CAAC,YAAD,CAAN,GAAuB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,uFAAD,CAAL;AAAgG,KAApI;AAC5D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,SAAxC,CAAL,EAAyDA,MAAM,CAAC,SAAD,CAAN,GAAoB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,oFAAD,CAAL;AAA6F,KAA9H;AACzD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,oBAAxC,CAAL,EAAoEA,MAAM,CAAC,oBAAD,CAAN,GAA+B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,+FAAD,CAAL;AAAwG,KAApJ;AACpE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,OAAxC,CAAL,EAAuDA,MAAM,CAAC,OAAD,CAAN,GAAkB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,kFAAD,CAAL;AAA2F,KAA1H;AACvD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,aAAxC,CAAL,EAA6DA,MAAM,CAAC,aAAD,CAAN,GAAwB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,wFAAD,CAAL;AAAiG,KAAtI;AAC7D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,aAAxC,CAAL,EAA6DA,MAAM,CAAC,aAAD,CAAN,GAAwB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,wFAAD,CAAL;AAAiG,KAAtI;AAC7D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,OAAxC,CAAL,EAAuDA,MAAM,CAAC,OAAD,CAAN,GAAkB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,kFAAD,CAAL;AAA2F,KAA1H;AACvD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,iBAAxC,CAAL,EAAiEA,MAAM,CAAC,iBAAD,CAAN,GAA4B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,4FAAD,CAAL;AAAqG,KAA9I;AACjE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,yBAAxC,CAAL,EAAyEA,MAAM,CAAC,yBAAD,CAAN,GAAoC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,oGAAD,CAAL;AAA6G,KAA9J;AACzE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,2BAAxC,CAAL,EAA2EA,MAAM,CAAC,2BAAD,CAAN,GAAsC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,sGAAD,CAAL;AAA+G,KAAlK;AAC3E,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,KAAxC,CAAL,EAAqDA,MAAM,CAAC,KAAD,CAAN,GAAgB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,gFAAD,CAAL;AAAyF,KAAtH;AACrD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,aAAxC,CAAL,EAA6DA,MAAM,CAAC,aAAD,CAAN,GAAwB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,wFAAD,CAAL;AAAiG,KAAtI;AAC7D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,gBAAxC,CAAL,EAAgEA,MAAM,CAAC,gBAAD,CAAN,GAA2B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,2FAAD,CAAL;AAAoG,KAA5I;AAChE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,WAAxC,CAAL,EAA2DA,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,sFAAD,CAAL;AAA+F,KAAlI;AAC3D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,KAAxC,CAAL,EAAqDA,MAAM,CAAC,KAAD,CAAN,GAAgB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,gFAAD,CAAL;AAAyF,KAAtH;AACrD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,oBAAxC,CAAL,EAAoEA,MAAM,CAAC,oBAAD,CAAN,GAA+B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,+FAAD,CAAL;AAAwG,KAApJ;AACpE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,WAAxC,CAAL,EAA2DA,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,sFAAD,CAAL;AAA+F,KAAlI;AAC3D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,0FAAD,CAAL;AAAmG,KAA1I;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,SAAxC,CAAL,EAAyDA,MAAM,CAAC,SAAD,CAAN,GAAoB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,oFAAD,CAAL;AAA6F,KAA9H;AACzD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,cAAxC,CAAL,EAA8DA,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG,KAAxI;AAC9D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,kBAAxC,CAAL,EAAkEA,MAAM,CAAC,kBAAD,CAAN,GAA6B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,6FAAD,CAAL;AAAsG,KAAhJ;AAClE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,MAAxC,CAAL,EAAsDA,MAAM,CAAC,MAAD,CAAN,GAAiB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,iFAAD,CAAL;AAA0F,KAAxH;AACtD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,0FAAD,CAAL;AAAmG,KAA1I;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,SAAxC,CAAL,EAAyDA,MAAM,CAAC,SAAD,CAAN,GAAoB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,oFAAD,CAAL;AAA6F,KAA9H;AACzD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,gBAAxC,CAAL,EAAgEA,MAAM,CAAC,gBAAD,CAAN,GAA2B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,2FAAD,CAAL;AAAoG,KAA5I;AAChE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,qBAAxC,CAAL,EAAqEA,MAAM,CAAC,qBAAD,CAAN,GAAgC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,gGAAD,CAAL;AAAyG,KAAtJ;AACrE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,gBAAxC,CAAL,EAAgEA,MAAM,CAAC,gBAAD,CAAN,GAA2B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,2FAAD,CAAL;AAAoG,KAA5I;AAChE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,aAAxC,CAAL,EAA6DA,MAAM,CAAC,aAAD,CAAN,GAAwB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,wFAAD,CAAL;AAAiG,KAAtI;AAC7D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,cAAxC,CAAL,EAA8DA,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG,KAAxI;AAC9D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,YAAxC,CAAL,EAA4DA,MAAM,CAAC,YAAD,CAAN,GAAuB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,uFAAD,CAAL;AAAgG,KAApI;AAC5D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,qBAAxC,CAAL,EAAqEA,MAAM,CAAC,qBAAD,CAAN,GAAgC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,gGAAD,CAAL;AAAyG,KAAtJ;AACrE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,0FAAD,CAAL;AAAmG,KAA1I;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,sBAAxC,CAAL,EAAsEA,MAAM,CAAC,sBAAD,CAAN,GAAiC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,iGAAD,CAAL;AAA0G,KAAxJ;AACtE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,wBAAxC,CAAL,EAAwEA,MAAM,CAAC,wBAAD,CAAN,GAAmC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,mGAAD,CAAL;AAA4G,KAA5J;AACxE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,sBAAxC,CAAL,EAAsEA,MAAM,CAAC,sBAAD,CAAN,GAAiC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,iGAAD,CAAL;AAA0G,KAAxJ;AACtE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,wBAAxC,CAAL,EAAwEA,MAAM,CAAC,wBAAD,CAAN,GAAmC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,mGAAD,CAAL;AAA4G,KAA5J;AACxE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,gBAAxC,CAAL,EAAgEA,MAAM,CAAC,gBAAD,CAAN,GAA2B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,2FAAD,CAAL;AAAoG,KAA5I;AAChE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,gBAAxC,CAAL,EAAgEA,MAAM,CAAC,gBAAD,CAAN,GAA2B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,2FAAD,CAAL;AAAoG,KAA5I;AAChE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,qBAAxC,CAAL,EAAqEA,MAAM,CAAC,qBAAD,CAAN,GAAgC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,gGAAD,CAAL;AAAyG,KAAtJ;AACrE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,qBAAxC,CAAL,EAAqEA,MAAM,CAAC,qBAAD,CAAN,GAAgC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,gGAAD,CAAL;AAAyG,KAAtJ;AACrE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,0FAAD,CAAL;AAAmG,KAA1I;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,kBAAxC,CAAL,EAAkEA,MAAM,CAAC,kBAAD,CAAN,GAA6B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,6FAAD,CAAL;AAAsG,KAAhJ;AAClE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,SAAxC,CAAL,EAAyDA,MAAM,CAAC,SAAD,CAAN,GAAoB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,oFAAD,CAAL;AAA6F,KAA9H;AACzD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,wBAAxC,CAAL,EAAwEA,MAAM,CAAC,wBAAD,CAAN,GAAmC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,mGAAD,CAAL;AAA4G,KAA5J;AACxE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,aAAxC,CAAL,EAA6DA,MAAM,CAAC,aAAD,CAAN,GAAwB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,wFAAD,CAAL;AAAiG,KAAtI;AAC7D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,IAAxC,CAAL,EAAoDA,MAAM,CAAC,IAAD,CAAN,GAAe,YAAW;AAAEuD,MAAAA,KAAK,CAAC,+EAAD,CAAL;AAAwF,KAApH;AACpD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,aAAxC,CAAL,EAA6DA,MAAM,CAAC,aAAD,CAAN,GAAwB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,wFAAD,CAAL;AAAiG,KAAtI;AAC7D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,OAAxC,CAAL,EAAuDA,MAAM,CAAC,OAAD,CAAN,GAAkB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,kFAAD,CAAL;AAA2F,KAA1H;AACvD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,WAAxC,CAAL,EAA2DA,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,sFAAD,CAAL;AAA+F,KAAlI;AAC3D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,cAAxC,CAAL,EAA8DA,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG,KAAxI;AAC9D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,KAAxC,CAAL,EAAqDA,MAAM,CAAC,KAAD,CAAN,GAAgB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,gFAAD,CAAL;AAAyF,KAAtH;AACrD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,iBAAxC,CAAL,EAAiEA,MAAM,CAAC,iBAAD,CAAN,GAA4B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,4FAAD,CAAL;AAAqG,KAA9I;AACjE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,cAAxC,CAAL,EAA8DA,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG,KAAxI;AAC9D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,QAAxC,CAAL,EAAwDA,MAAM,CAAC,QAAD,CAAN,GAAmB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,mFAAD,CAAL;AAA4F,KAA5H;AACxD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,iBAAxC,CAAL,EAAiEA,MAAM,CAAC,iBAAD,CAAN,GAA4B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,4FAAD,CAAL;AAAqG,KAA9I;AACjE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,cAAxC,CAAL,EAA8DA,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG,KAAxI;AAC9D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,QAAxC,CAAL,EAAwDA,MAAM,CAAC,QAAD,CAAN,GAAmB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,mFAAD,CAAL;AAA4F,KAA5H;AACxD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,aAAxC,CAAL,EAA6DA,MAAM,CAAC,aAAD,CAAN,GAAwB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,wFAAD,CAAL;AAAiG,KAAtI;AAC7D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,IAAxC,CAAL,EAAoDA,MAAM,CAAC,IAAD,CAAN,GAAe,YAAW;AAAEuD,MAAAA,KAAK,CAAC,+EAAD,CAAL;AAAwF,KAApH;AACpD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,0BAAxC,CAAL,EAA0EA,MAAM,CAAC,0BAAD,CAAN,GAAqC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qGAAD,CAAL;AAA8G,KAAhK;AAC1E,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,oBAAxC,CAAL,EAAoEA,MAAM,CAAC,oBAAD,CAAN,GAA+B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,+FAAD,CAAL;AAAwG,KAApJ;AACpE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,sCAAxC,CAAL,EAAsFA,MAAM,CAAC,sCAAD,CAAN,GAAiD,YAAW;AAAEuD,MAAAA,KAAK,CAAC,iHAAD,CAAL;AAA0H,KAAxL;AACtF,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,gCAAxC,CAAL,EAAgFA,MAAM,CAAC,gCAAD,CAAN,GAA2C,YAAW;AAAEuD,MAAAA,KAAK,CAAC,2GAAD,CAAL;AAAoH,KAA5K;AAChF,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,2BAAxC,CAAL,EAA2EA,MAAM,CAAC,2BAAD,CAAN,GAAsC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,sGAAD,CAAL;AAA+G,KAAlK;AAC3E,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,gCAAxC,CAAL,EAAgFA,MAAM,CAAC,gCAAD,CAAN,GAA2C,YAAW;AAAEuD,MAAAA,KAAK,CAAC,2GAAD,CAAL;AAAoH,KAA5K;AAChF,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,mBAAxC,CAAL,EAAmEA,MAAM,CAAC,mBAAD,CAAN,GAA8B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,8FAAD,CAAL;AAAuG,KAAlJ;AACnE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,iCAAxC,CAAL,EAAiFA,MAAM,CAAC,iCAAD,CAAN,GAA4C,YAAW;AAAEuD,MAAAA,KAAK,CAAC,4GAAD,CAAL;AAAqH,KAA9K;AACjF,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,sCAAxC,CAAL,EAAsFA,MAAM,CAAC,sCAAD,CAAN,GAAiD,YAAW;AAAEuD,MAAAA,KAAK,CAAC,iHAAD,CAAL;AAA0H,KAAxL;AACtF,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,IAAxC,CAAL,EAAoDA,MAAM,CAAC,IAAD,CAAN,GAAe,YAAW;AAAEuD,MAAAA,KAAK,CAAC,+EAAD,CAAL;AAAwF,KAApH;AACpD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,OAAxC,CAAL,EAAuDA,MAAM,CAAC,OAAD,CAAN,GAAkB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,kFAAD,CAAL;AAA2F,KAA1H;AACvD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,aAAxC,CAAL,EAA6DA,MAAM,CAAC,aAAD,CAAN,GAAwB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,wFAAD,CAAL;AAAiG,KAAtI;AAC7D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,WAAxC,CAAL,EAA2DA,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,sFAAD,CAAL;AAA+F,KAAlI;AAC3D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,KAAxC,CAAL,EAAqDA,MAAM,CAAC,KAAD,CAAN,GAAgB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,gFAAD,CAAL;AAAyF,KAAtH;AACrD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,SAAxC,CAAL,EAAyDA,MAAM,CAAC,SAAD,CAAN,GAAoB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,oFAAD,CAAL;AAA6F,KAA9H;AACzD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,0FAAD,CAAL;AAAmG,KAA1I;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,YAAxC,CAAL,EAA4DA,MAAM,CAAC,YAAD,CAAN,GAAuB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,uFAAD,CAAL;AAAgG,KAApI;AAC5D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,MAAxC,CAAL,EAAsDA,MAAM,CAAC,MAAD,CAAN,GAAiB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,iFAAD,CAAL;AAA0F,KAAxH;AACtD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,WAAxC,CAAL,EAA2DA,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,sFAAD,CAAL;AAA+F,KAAlI;AAC3D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,KAAxC,CAAL,EAAqDA,MAAM,CAAC,KAAD,CAAN,GAAgB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,gFAAD,CAAL;AAAyF,KAAtH;AACrD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,YAAxC,CAAL,EAA4DA,MAAM,CAAC,YAAD,CAAN,GAAuB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,uFAAD,CAAL;AAAgG,KAApI;AAC5D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,MAAxC,CAAL,EAAsDA,MAAM,CAAC,MAAD,CAAN,GAAiB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,iFAAD,CAAL;AAA0F,KAAxH;AACtD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,YAAxC,CAAL,EAA4DA,MAAM,CAAC,YAAD,CAAN,GAAuB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,uFAAD,CAAL;AAAgG,KAApI;AAC5D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,MAAxC,CAAL,EAAsDA,MAAM,CAAC,MAAD,CAAN,GAAiB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,iFAAD,CAAL;AAA0F,KAAxH;AACtD,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,gBAAxC,CAAL,EAAgEA,MAAM,CAAC,gBAAD,CAAN,GAA2B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,2FAAD,CAAL;AAAoG,KAA5I;AAChE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,oBAAxC,CAAL,EAAoEA,MAAM,CAAC,oBAAD,CAAN,GAA+B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,+FAAD,CAAL;AAAwG,KAApJ;AACpE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,UAAxC,CAAL,EAA0DA,MAAM,CAAC,UAAD,CAAN,GAAqB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,qFAAD,CAAL;AAA8F,KAAhI;AAC1D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,WAAxC,CAAL,EAA2DA,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,sFAAD,CAAL;AAA+F,KAAlI;AAC3D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,cAAxC,CAAL,EAA8DA,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG,KAAxI;AAC9D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,YAAxC,CAAL,EAA4DA,MAAM,CAAC,YAAD,CAAN,GAAuB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,uFAAD,CAAL;AAAgG,KAApI;AAC5D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,0FAAD,CAAL;AAAmG,KAA1I;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,0FAAD,CAAL;AAAmG,KAA1I;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,0FAAD,CAAL;AAAmG,KAA1I;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,0FAAD,CAAL;AAAmG,KAA1I;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,kBAAxC,CAAL,EAAkEA,MAAM,CAAC,kBAAD,CAAN,GAA6B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,6FAAD,CAAL;AAAsG,KAAhJ;AAClE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,0FAAD,CAAL;AAAmG,KAA1I;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+DA,MAAM,CAAC,eAAD,CAAN,GAA0B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,0FAAD,CAAL;AAAmG,KAA1I;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,kBAAxC,CAAL,EAAkEA,MAAM,CAAC,kBAAD,CAAN,GAA6B,YAAW;AAAEuD,MAAAA,KAAK,CAAC,6FAAD,CAAL;AAAsG,KAAhJ;AAClE,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,cAAxC,CAAL,EAA8DA,MAAM,CAAC,cAAD,CAAN,GAAyB,YAAW;AAAEuD,MAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG,KAAxI;AAC9D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,qBAAxC,CAAL,EAAqEA,MAAM,CAAC,qBAAD,CAAN,GAAgC,YAAW;AAAEuD,MAAAA,KAAK,CAAC,gGAAD,CAAL;AAAyG,KAAtJ;AACrEvD,IAAAA,MAAM,CAAC,kBAAD,CAAN,GAA6ByR,gBAA7B;AACAzR,IAAAA,MAAM,CAAC,kBAAD,CAAN,GAA6B0R,gBAA7B;AACA1R,IAAAA,MAAM,CAAC,oBAAD,CAAN,GAA+B6R,kBAA/B;AAAkD,QAAI,CAAC,iCAAgC7R,MAAhC,EAAwC,cAAxC,CAAL,EAA8D,uBAAsBA,MAAtB,EAA8B,cAA9B,EAA8C;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,yFAAD,CAAL;AAAkG;AAA1I,KAA9C;AAChH,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,aAAxC,CAAL,EAA6D,uBAAsBA,MAAtB,EAA8B,aAA9B,EAA6C;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,wFAAD,CAAL;AAAiG;AAAzI,KAA7C;AAC7D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,eAAxC,CAAL,EAA+D,uBAAsBA,MAAtB,EAA8B,eAA9B,EAA+C;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,0FAAD,CAAL;AAAmG;AAA3I,KAA/C;AAC/D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,YAAxC,CAAL,EAA4D,uBAAsBA,MAAtB,EAA8B,YAA9B,EAA4C;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,uFAAD,CAAL;AAAgG;AAAxI,KAA5C;AAC5D,QAAI,CAAC,iCAAgCvD,MAAhC,EAAwC,WAAxC,CAAL,EAA2D,uBAAsBA,MAAtB,EAA8B,WAA9B,EAA2C;AAAEqD,MAAAA,YAAY,EAAE,IAAhB;AAAsBC,MAAAA,GAAG,EAAE,eAAW;AAAEC,QAAAA,KAAK,CAAC,iLAAD,CAAL;AAA0L;AAAlO,KAA3C;AAI3D,QAAI4b,SAAJ,CAlxEiB,CAoxEjB;AACA;AACA;AACA;AACA;AACA;;AACAnf,IAAAA,MAAM,CAAC,MAAD,CAAN,GAAiB,UAASqF,IAAT,EAAe;AAC9B;AACA;AACA,UAAI8Z,SAAJ,EAAe;AACb9Z,QAAAA,IAAI,CAACrF,MAAD,CAAJ;AACD,OAFD,MAEO;AACL;AACA;AACA,YAAIof,GAAG,GAAGpf,MAAM,CAAC,sBAAD,CAAhB;;AACAA,QAAAA,MAAM,CAAC,sBAAD,CAAN,GAAiC,YAAW;AAC1C,cAAIof,GAAJ,EAASA,GAAG;AACZ/Z,UAAAA,IAAI,CAACrF,MAAD,CAAJ;AACD,SAHD;AAID;;AACD,aAAOA,MAAP;AACD,KAfD;AAiBA;;;;;;AAIA,aAASqf,UAAT,CAAoBze,MAApB,EAA4B;AAC1B,WAAKkI,IAAL,GAAY,YAAZ;AACA,WAAKwW,OAAL,GAAe,kCAAkC1e,MAAlC,GAA2C,GAA1D;AACA,WAAKA,MAAL,GAAcA,MAAd;AACD;;AAED,QAAI2e,UAAU,GAAG,KAAjB;;AAGAtJ,IAAAA,qBAAqB,GAAG,SAASuJ,SAAT,GAAqB;AAC3C;AACA,UAAI,CAACL,SAAL,EAAgBM,GAAG;AACnB,UAAI,CAACN,SAAL,EAAgBlJ,qBAAqB,GAAGuJ,SAAxB,CAH2B,CAGQ;AACpD,KAJD;;AAMA,aAASE,QAAT,CAAkBrX,IAAlB,EAAwB;AACtB7E,MAAAA,MAAM,CAACuS,eAAe,IAAI,CAApB,EAAuB,6FAAvB,CAAN;AACAvS,MAAAA,MAAM,CAAC8O,YAAY,CAACvN,MAAb,IAAuB,CAAxB,EAA2B,4DAA3B,CAAN;AAEA,UAAI4a,aAAa,GAAG3f,MAAM,CAAC,OAAD,CAA1B;AAGAqI,MAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AAEA,UAAIuX,IAAI,GAAGvX,IAAI,CAACtD,MAAL,GAAY,CAAvB;AACA,UAAI8a,IAAI,GAAG7b,UAAU,CAAC,CAAC4b,IAAI,GAAG,CAAR,IAAa,CAAd,CAArB;AACAtb,MAAAA,MAAM,CAACub,IAAI,IAAI,CAAT,CAAN,GAAoBvQ,mBAAmB,CAAC5O,WAAD,CAAvC;;AACA,WAAK,IAAIkF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGga,IAApB,EAA0Bha,CAAC,EAA3B,EAA+B;AAC7BtB,QAAAA,MAAM,CAAC,CAACub,IAAI,IAAI,CAAT,IAAcja,CAAf,CAAN,GAA0B0J,mBAAmB,CAACjH,IAAI,CAACzC,CAAC,GAAG,CAAL,CAAL,CAA7C;AACD;;AACDtB,MAAAA,MAAM,CAAC,CAACub,IAAI,IAAI,CAAT,IAAcD,IAAf,CAAN,GAA6B,CAA7B;;AAGA,UAAI;AAEF5f,QAAAA,MAAM,CAAC,oBAAD,CAAN,CAA6BmR,SAA7B;AAEA,YAAI9M,GAAG,GAAGsb,aAAa,CAACC,IAAD,EAAOC,IAAP,CAAvB,CAJE,CAOF;AACA;AACA;;AACEC,QAAAA,IAAI,CAACzb,GAAD;AAAM;AAAiB,YAAvB,CAAJ;AACH,OAXD,CAYA,OAAMiV,CAAN,EAAS;AACP,YAAIA,CAAC,YAAY+F,UAAjB,EAA6B;AAC3B;AACA;AACA;AACD,SAJD,MAIO,IAAI/F,CAAC,IAAI,QAAT,EAAmB;AACxB;AACApQ,UAAAA,aAAa,GAAG,IAAhB;AACA;AACD,SAJM,MAIA;AACL,cAAI6W,KAAK,GAAGzG,CAAZ;;AACA,cAAIA,CAAC,IAAI,OAAOA,CAAP,KAAa,QAAlB,IAA8BA,CAAC,CAAChO,KAApC,EAA2C;AACzCyU,YAAAA,KAAK,GAAG,CAACzG,CAAD,EAAIA,CAAC,CAAChO,KAAN,CAAR;AACD;;AACDnI,UAAAA,GAAG,CAAC,uBAAuB4c,KAAxB,CAAH;AACApf,UAAAA,KAAK,CAAC,CAAD,EAAI2Y,CAAJ,CAAL;AACD;AACF,OA7BD,SA6BU;AACRiG,QAAAA,UAAU,GAAG,IAAb;AACD;AACF;AAKD;;;AACA,aAASE,GAAT,CAAapX,IAAb,EAAmB;AACjBA,MAAAA,IAAI,GAAGA,IAAI,IAAI5H,UAAf;;AAEA,UAAIsV,eAAe,GAAG,CAAtB,EAAyB;AACvB;AACD;;AAEDtE,MAAAA,gBAAgB;AAEhBmB,MAAAA,MAAM;AAEN,UAAImD,eAAe,GAAG,CAAtB,EAAyB,OAXR,CAWgB;;AAEjC,eAASiK,KAAT,GAAiB;AACf;AACA;AACA,YAAIb,SAAJ,EAAe;AACfA,QAAAA,SAAS,GAAG,IAAZ;AAEA,YAAIhV,KAAJ,EAAW;AAEX2I,QAAAA,WAAW;AAEXC,QAAAA,OAAO;AAEP,YAAI/S,MAAM,CAAC,sBAAD,CAAV,EAAoCA,MAAM,CAAC,sBAAD,CAAN;AAEpC,YAAIigB,YAAJ,EAAkBP,QAAQ,CAACrX,IAAD,CAAR;AAElB4K,QAAAA,OAAO;AACR;;AAED,UAAIjT,MAAM,CAAC,WAAD,CAAV,EAAyB;AACvBA,QAAAA,MAAM,CAAC,WAAD,CAAN,CAAoB,YAApB;AACAkgB,QAAAA,UAAU,CAAC,YAAW;AACpBA,UAAAA,UAAU,CAAC,YAAW;AACpBlgB,YAAAA,MAAM,CAAC,WAAD,CAAN,CAAoB,EAApB;AACD,WAFS,EAEP,CAFO,CAAV;AAGAggB,UAAAA,KAAK;AACN,SALS,EAKP,CALO,CAAV;AAMD,OARD,MASA;AACEA,QAAAA,KAAK;AACN;;AACDtO,MAAAA,gBAAgB;AACjB;;AACD1R,IAAAA,MAAM,CAAC,KAAD,CAAN,GAAgByf,GAAhB;;AAEA,aAASU,qBAAT,GAAiC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAIC,KAAK,GAAGrd,GAAZ;AACA,UAAIsd,QAAQ,GAAGld,GAAf;AACA,UAAImd,GAAG,GAAG,KAAV;;AACAvd,MAAAA,GAAG,GAAGI,GAAG,GAAG,aAAS+M,CAAT,EAAY;AACtBoQ,QAAAA,GAAG,GAAG,IAAN;AACD,OAFD;;AAGA,UAAI;AAAE;AACJ,YAAIC,KAAK,GAAG9F,mBAAZ;AACA,YAAI8F,KAAJ,EAAWA,KAAK,CAAC,CAAD,CAAL;AACZ,OAHD,CAGE,OAAMjH,CAAN,EAAS,CAAE;;AACbvW,MAAAA,GAAG,GAAGqd,KAAN;AACAjd,MAAAA,GAAG,GAAGkd,QAAN;;AACA,UAAIC,GAAJ,EAAS;AACPrb,QAAAA,QAAQ,CAAC,6JAAD,CAAR;AACAA,QAAAA,QAAQ,CAAC,2GAAD,CAAR;AACD;AACF;;AAED,aAAS6a,IAAT,CAAclf,MAAd,EAAsB4f,QAAtB,EAAgC;AAC9BL,MAAAA,qBAAqB,GADS,CAG9B;AACA;AACA;AACA;;AACA,UAAIK,QAAQ,IAAItX,aAAZ,IAA6BtI,MAAM,KAAK,CAA5C,EAA+C;AAC7C;AACD;;AAED,UAAIsI,aAAJ,EAAmB;AACjB;AACA,YAAI,CAACsX,QAAL,EAAe;AACbrd,UAAAA,GAAG,CAAC,kCAAkCvC,MAAlC,GAA2C,iLAA5C,CAAH;AACD;AACF,OALD,MAKO;AAELuJ,QAAAA,KAAK,GAAG,IAAR;AACAC,QAAAA,UAAU,GAAGxJ,MAAb;AAEAoS,QAAAA,WAAW;AAEX,YAAIhT,MAAM,CAAC,QAAD,CAAV,EAAsBA,MAAM,CAAC,QAAD,CAAN,CAAiBY,MAAjB;AACvB;;AAEDD,MAAAA,KAAK,CAACC,MAAD,EAAS,IAAIye,UAAJ,CAAeze,MAAf,CAAT,CAAL;AACD;;AAED,QAAIZ,MAAM,CAAC,SAAD,CAAV,EAAuB;AACrB,UAAI,OAAOA,MAAM,CAAC,SAAD,CAAb,IAA4B,UAAhC,EAA4CA,MAAM,CAAC,SAAD,CAAN,GAAoB,CAACA,MAAM,CAAC,SAAD,CAAP,CAApB;;AAC5C,aAAOA,MAAM,CAAC,SAAD,CAAN,CAAkB+E,MAAlB,GAA2B,CAAlC,EAAqC;AACnC/E,QAAAA,MAAM,CAAC,SAAD,CAAN,CAAkBygB,GAAlB;AACD;AACF,KAt+EgB,CAw+EjB;;;AACA,QAAIR,YAAY,GAAG,IAAnB;AAEA,QAAIjgB,MAAM,CAAC,cAAD,CAAV,EAA4BigB,YAAY,GAAG,KAAf;AAG1B/W,IAAAA,aAAa,GAAG,IAAhB;AAEFuW,IAAAA,GAAG,GAh/Ec,CAs/EjB;;AAME,WAAOzf,MAAP;AACD,GA9/EC;AAggFD,CAngFY,EAAb;;AAogFA,IAAI,OAAOyG,OAAP,KAAmB,QAAnB,IAA+B,OAAOJ,MAAP,KAAkB,QAArD,EACMA,MAAM,CAACI,OAAP,GAAiBzG,MAAjB,CADN,KAES,IAAI,OAAO0gB,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAAC,KAAD,CAA1C,EACHA,MAAM,CAAC,EAAD,EAAK,YAAW;AAAE,SAAO1gB,MAAP;AAAgB,CAAlC,CAAN,CADG,KAEA,IAAI,OAAOyG,OAAP,KAAmB,QAAvB,EACHA,OAAO,CAAC,QAAD,CAAP,GAAoBzG,MAApB","sourcesContent":["\nvar Module = (function() {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  \n  return (\nfunction(Module) {\n  Module = Module || {};\n\n// Copyright 2010 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof Module !== 'undefined' ? Module : {};\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = {};\nvar key;\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\nvar arguments_ = [];\nvar thisProgram = './this.program';\nvar quit_ = function(status, toThrow) {\n  throw toThrow;\n};\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\nvar ENVIRONMENT_IS_WEB = true;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\n\nif (Module['ENVIRONMENT']) {\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');\n}\n\n\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar read_,\n    readAsync,\n    readBinary,\n    setWindowTitle;\n\n\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n// ENVIRONMENT_IS_NODE.\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\n    scriptDirectory = self.location.href;\n  } else if (document.currentScript) { // web\n    scriptDirectory = document.currentScript.src;\n  }\n  // When MODULARIZE (and not _INSTANCE), this JS may be executed later, after document.currentScript\n  // is gone, so we saved it, and we use it here instead of any other info.\n  if (_scriptDir) {\n    scriptDirectory = _scriptDir;\n  }\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n  // otherwise, slice off the final part of the url to find the script directory.\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n  // and scriptDirectory will correctly be replaced with an empty string.\n  if (scriptDirectory.indexOf('blob:') !== 0) {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);\n  } else {\n    scriptDirectory = '';\n  }\n\n  if (!(typeof window === 'object' || typeof importScripts === 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n  // Differentiate the Web Worker from the Node Worker case, as reading must\n  // be done differently.\n  {\n\n\n  read_ = function shell_read(url) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.send(null);\n      return xhr.responseText;\n  };\n\n  if (ENVIRONMENT_IS_WORKER) {\n    readBinary = function readBinary(url) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.responseType = 'arraybuffer';\n        xhr.send(null);\n        return new Uint8Array(xhr.response);\n    };\n  }\n\n  readAsync = function readAsync(url, onload, onerror) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function xhr_onload() {\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n        onload(xhr.response);\n        return;\n      }\n      onerror();\n    };\n    xhr.onerror = onerror;\n    xhr.send(null);\n  };\n\n\n\n\n  }\n\n  setWindowTitle = function(title) { document.title = title };\n} else\n{\n  throw new Error('environment detection error');\n}\n\n\n// Set up the out() and err() hooks, which are how we can print to stdout or\n// stderr, respectively.\nvar out = Module['print'] || console.log.bind(console);\nvar err = Module['printErr'] || console.warn.bind(console);\n\n// Merge back in the overrides\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n}\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = null;\n\n// Emit code to handle expected values on the Module object. This applies Module.x\n// to the proper local x. This has two benefits: first, we only emit it if it is\n// expected to arrive, and second, by using a local everywhere else that can be\n// minified.\nif (Module['arguments']) arguments_ = Module['arguments'];if (!Object.getOwnPropertyDescriptor(Module, 'arguments')) Object.defineProperty(Module, 'arguments', { configurable: true, get: function() { abort('Module.arguments has been replaced with plain arguments_') } });\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];if (!Object.getOwnPropertyDescriptor(Module, 'thisProgram')) Object.defineProperty(Module, 'thisProgram', { configurable: true, get: function() { abort('Module.thisProgram has been replaced with plain thisProgram') } });\nif (Module['quit']) quit_ = Module['quit'];if (!Object.getOwnPropertyDescriptor(Module, 'quit')) Object.defineProperty(Module, 'quit', { configurable: true, get: function() { abort('Module.quit has been replaced with plain quit_') } });\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n// Assertions on removed incoming Module JS APIs.\nassert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['read'] === 'undefined', 'Module.read option was removed (modify read_ in JS)');\nassert(typeof Module['readAsync'] === 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\nassert(typeof Module['readBinary'] === 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\nassert(typeof Module['setWindowTitle'] === 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');\nif (!Object.getOwnPropertyDescriptor(Module, 'read')) Object.defineProperty(Module, 'read', { configurable: true, get: function() { abort('Module.read has been replaced with plain read_') } });\nif (!Object.getOwnPropertyDescriptor(Module, 'readAsync')) Object.defineProperty(Module, 'readAsync', { configurable: true, get: function() { abort('Module.readAsync has been replaced with plain readAsync') } });\nif (!Object.getOwnPropertyDescriptor(Module, 'readBinary')) Object.defineProperty(Module, 'readBinary', { configurable: true, get: function() { abort('Module.readBinary has been replaced with plain readBinary') } });\n// TODO: add when SDL2 is fixed if (!Object.getOwnPropertyDescriptor(Module, 'setWindowTitle')) Object.defineProperty(Module, 'setWindowTitle', { configurable: true, get: function() { abort('Module.setWindowTitle has been replaced with plain setWindowTitle') } });\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\n\n\n// TODO remove when SDL2 is fixed (also see above)\n\n\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// {{PREAMBLE_ADDITIONS}}\n\nvar STACK_ALIGN = 16;\n\n// stack management, and other functionality that is provided by the compiled code,\n// should not be used before it is ready\nstackSave = stackRestore = stackAlloc = function() {\n  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n};\n\nfunction staticAlloc(size) {\n  abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');\n}\n\nfunction dynamicAlloc(size) {\n  assert(DYNAMICTOP_PTR);\n  var ret = HEAP32[DYNAMICTOP_PTR>>2];\n  var end = (ret + size + 15) & -16;\n  if (end > _emscripten_get_heap_size()) {\n    abort('failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly');\n  }\n  HEAP32[DYNAMICTOP_PTR>>2] = end;\n  return ret;\n}\n\nfunction alignMemory(size, factor) {\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n  return Math.ceil(size / factor) * factor;\n}\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1': case 'i8': return 1;\n    case 'i16': return 2;\n    case 'i32': return 4;\n    case 'i64': return 8;\n    case 'float': return 4;\n    case 'double': return 8;\n    default: {\n      if (type[type.length-1] === '*') {\n        return 4; // A pointer\n      } else if (type[0] === 'i') {\n        var bits = parseInt(type.substr(1));\n        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\n        return bits / 8;\n      } else {\n        return 0;\n      }\n    }\n  }\n}\n\nfunction warnOnce(text) {\n  if (!warnOnce.shown) warnOnce.shown = {};\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    err(text);\n  }\n}\n\n\n\n\n\n\n// Wraps a JS function as a wasm function with a given signature.\nfunction convertJsFunctionToWasm(func, sig) {\n\n  // If the type reflection proposal is available, use the new\n  // \"WebAssembly.Function\" constructor.\n  // Otherwise, construct a minimal wasm module importing the JS function and\n  // re-exporting it.\n  if (typeof WebAssembly.Function === \"function\") {\n    var typeNames = {\n      'i': 'i32',\n      'j': 'i64',\n      'f': 'f32',\n      'd': 'f64'\n    };\n    var type = {\n      parameters: [],\n      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\n    };\n    for (var i = 1; i < sig.length; ++i) {\n      type.parameters.push(typeNames[sig[i]]);\n    }\n    return new WebAssembly.Function(type, func);\n  }\n\n  // The module is static, with the exception of the type section, which is\n  // generated based on the signature passed in.\n  var typeSection = [\n    0x01, // id: section,\n    0x00, // length: 0 (placeholder)\n    0x01, // count: 1\n    0x60, // form: func\n  ];\n  var sigRet = sig.slice(0, 1);\n  var sigParam = sig.slice(1);\n  var typeCodes = {\n    'i': 0x7f, // i32\n    'j': 0x7e, // i64\n    'f': 0x7d, // f32\n    'd': 0x7c, // f64\n  };\n\n  // Parameters, length + signatures\n  typeSection.push(sigParam.length);\n  for (var i = 0; i < sigParam.length; ++i) {\n    typeSection.push(typeCodes[sigParam[i]]);\n  }\n\n  // Return values, length + signatures\n  // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n  if (sigRet == 'v') {\n    typeSection.push(0x00);\n  } else {\n    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\n  }\n\n  // Write the overall length of the type section back into the section header\n  // (excepting the 2 bytes for the section id and length)\n  typeSection[1] = typeSection.length - 2;\n\n  // Rest of the module is static\n  var bytes = new Uint8Array([\n    0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\n    0x01, 0x00, 0x00, 0x00, // version: 1\n  ].concat(typeSection, [\n    0x02, 0x07, // import section\n      // (import \"e\" \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,\n    0x07, 0x05, // export section\n      // (export \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x66, 0x00, 0x00,\n  ]));\n\n   // We can compile this wasm module synchronously because it is very small.\n  // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n  var module = new WebAssembly.Module(bytes);\n  var instance = new WebAssembly.Instance(module, {\n    'e': {\n      'f': func\n    }\n  });\n  var wrappedFunc = instance.exports['f'];\n  return wrappedFunc;\n}\n\n// Add a wasm function to the table.\nfunction addFunctionWasm(func, sig) {\n  var table = wasmTable;\n  var ret = table.length;\n\n  // Grow the table\n  try {\n    table.grow(1);\n  } catch (err) {\n    if (!(err instanceof RangeError)) {\n      throw err;\n    }\n    throw 'Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.';\n  }\n\n  // Insert new element\n  try {\n    // Attempting to call this with JS function will cause of table.set() to fail\n    table.set(ret, func);\n  } catch (err) {\n    if (!(err instanceof TypeError)) {\n      throw err;\n    }\n    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');\n    var wrapped = convertJsFunctionToWasm(func, sig);\n    table.set(ret, wrapped);\n  }\n\n  return ret;\n}\n\nfunction removeFunctionWasm(index) {\n  // TODO(sbc): Look into implementing this to allow re-using of table slots\n}\n\n// 'sig' parameter is required for the llvm backend but only when func is not\n// already a WebAssembly function.\nfunction addFunction(func, sig) {\n  assert(typeof func !== 'undefined');\n\n  return addFunctionWasm(func, sig);\n}\n\nfunction removeFunction(index) {\n  removeFunctionWasm(index);\n}\n\n\n\nvar funcWrappers = {};\n\nfunction getFuncWrapper(func, sig) {\n  if (!func) return; // on null pointer, return undefined\n  assert(sig);\n  if (!funcWrappers[sig]) {\n    funcWrappers[sig] = {};\n  }\n  var sigCache = funcWrappers[sig];\n  if (!sigCache[func]) {\n    // optimize away arguments usage in common cases\n    if (sig.length === 1) {\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func);\n      };\n    } else if (sig.length === 2) {\n      sigCache[func] = function dynCall_wrapper(arg) {\n        return dynCall(sig, func, [arg]);\n      };\n    } else {\n      // general case\n      sigCache[func] = function dynCall_wrapper() {\n        return dynCall(sig, func, Array.prototype.slice.call(arguments));\n      };\n    }\n  }\n  return sigCache[func];\n}\n\n\nfunction makeBigInt(low, high, unsigned) {\n  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));\n}\n\nfunction dynCall(sig, ptr, args) {\n  if (args && args.length) {\n    // j (64-bit integer) must be passed in as two numbers [low 32, high 32].\n    assert(args.length === sig.substring(1).replace(/j/g, '--').length);\n    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n  } else {\n    assert(sig.length == 1);\n    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n    return Module['dynCall_' + sig].call(null, ptr);\n  }\n}\n\nvar tempRet0 = 0;\n\nvar setTempRet0 = function(value) {\n  tempRet0 = value;\n};\n\nvar getTempRet0 = function() {\n  return tempRet0;\n};\n\nfunction getCompilerSetting(name) {\n  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n}\n\nvar Runtime = {\n  // helpful errors\n  getTempRet0: function() { abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n  staticAlloc: function() { abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n  stackAlloc: function() { abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"') },\n};\n\n// The address globals begin at. Very low in memory, for code size and optimization opportunities.\n// Above 0 is static memory, starting with globals.\n// Then the stack.\n// Then 'dynamic' memory for sbrk.\nvar GLOBAL_BASE = 1024;\n\n\n\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n\nvar wasmBinary;if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];if (!Object.getOwnPropertyDescriptor(Module, 'wasmBinary')) Object.defineProperty(Module, 'wasmBinary', { configurable: true, get: function() { abort('Module.wasmBinary has been replaced with plain wasmBinary') } });\nvar noExitRuntime;if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];if (!Object.getOwnPropertyDescriptor(Module, 'noExitRuntime')) Object.defineProperty(Module, 'noExitRuntime', { configurable: true, get: function() { abort('Module.noExitRuntime has been replaced with plain noExitRuntime') } });\n\n\nif (typeof WebAssembly !== 'object') {\n  abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');\n}\n\n\n// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.\n// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)\n\n/** @type {function(number, number, string, boolean=)} */\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': HEAP8[((ptr)>>0)]=value; break;\n      case 'i8': HEAP8[((ptr)>>0)]=value; break;\n      case 'i16': HEAP16[((ptr)>>1)]=value; break;\n      case 'i32': HEAP32[((ptr)>>2)]=value; break;\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;\n      case 'float': HEAPF32[((ptr)>>2)]=value; break;\n      case 'double': HEAPF64[((ptr)>>3)]=value; break;\n      default: abort('invalid type for setValue: ' + type);\n    }\n}\n\n/** @type {function(number, string, boolean=)} */\nfunction getValue(ptr, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': return HEAP8[((ptr)>>0)];\n      case 'i8': return HEAP8[((ptr)>>0)];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': return HEAP32[((ptr)>>2)];\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      default: abort('invalid type for getValue: ' + type);\n    }\n  return null;\n}\n\n\n\n\n\n// Wasm globals\n\nvar wasmMemory;\n\n// In fastcomp asm.js, we don't need a wasm Table at all.\n// In the wasm backend, we polyfill the WebAssembly object,\n// so this creates a (non-native-wasm) table for us.\nvar wasmTable = new WebAssembly.Table({\n  'initial': 6,\n  'maximum': 6 + 0,\n  'element': 'anyfunc'\n});\n\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS = 0;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed: ' + text);\n  }\n}\n\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\nfunction getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n  return func;\n}\n\n// C calling interface.\nfunction ccall(ident, returnType, argTypes, args, opts) {\n  // For fast lookup of conversion functions\n  var toC = {\n    'string': function(str) {\n      var ret = 0;\n      if (str !== null && str !== undefined && str !== 0) { // null string\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n        var len = (str.length << 2) + 1;\n        ret = stackAlloc(len);\n        stringToUTF8(str, ret, len);\n      }\n      return ret;\n    },\n    'array': function(arr) {\n      var ret = stackAlloc(arr.length);\n      writeArrayToMemory(arr, ret);\n      return ret;\n    }\n  };\n\n  function convertReturnValue(ret) {\n    if (returnType === 'string') return UTF8ToString(ret);\n    if (returnType === 'boolean') return Boolean(ret);\n    return ret;\n  }\n\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  assert(returnType !== 'array', 'Return type should not be \"array\".');\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n  var ret = func.apply(null, cArgs);\n\n  ret = convertReturnValue(ret);\n  if (stack !== 0) stackRestore(stack);\n  return ret;\n}\n\nfunction cwrap(ident, returnType, argTypes, opts) {\n  return function() {\n    return ccall(ident, returnType, argTypes, arguments, opts);\n  }\n}\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\nvar ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk\nvar ALLOC_NONE = 3; // Do not allocate\n\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n//        in *bytes* (note that this is sometimes confusing: the next parameter does not\n//        affect this!)\n// @types: Either an array of types, one for each byte (or 0 if no type at that position),\n//         or a single type which is used for the entire block. This only matters if there\n//         is initial data - if @slab is a number, then this does not matter at all and is\n//         ignored.\n// @allocator: How to allocate memory, see ALLOC_*\n/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\nfunction allocate(slab, types, allocator, ptr) {\n  var zeroinit, size;\n  if (typeof slab === 'number') {\n    zeroinit = true;\n    size = slab;\n  } else {\n    zeroinit = false;\n    size = slab.length;\n  }\n\n  var singleType = typeof types === 'string' ? types : null;\n\n  var ret;\n  if (allocator == ALLOC_NONE) {\n    ret = ptr;\n  } else {\n    ret = [_malloc,\n    stackAlloc,\n    dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));\n  }\n\n  if (zeroinit) {\n    var stop;\n    ptr = ret;\n    assert((ret & 3) == 0);\n    stop = ret + (size & ~3);\n    for (; ptr < stop; ptr += 4) {\n      HEAP32[((ptr)>>2)]=0;\n    }\n    stop = ret + size;\n    while (ptr < stop) {\n      HEAP8[((ptr++)>>0)]=0;\n    }\n    return ret;\n  }\n\n  if (singleType === 'i8') {\n    if (slab.subarray || slab.slice) {\n      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);\n    } else {\n      HEAPU8.set(new Uint8Array(slab), ret);\n    }\n    return ret;\n  }\n\n  var i = 0, type, typeSize, previousType;\n  while (i < size) {\n    var curr = slab[i];\n\n    type = singleType || types[i];\n    if (type === 0) {\n      i++;\n      continue;\n    }\n    assert(type, 'Must know what type to store in allocate!');\n\n    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n    setValue(ret+i, curr, type);\n\n    // no need to look up size unless type changes, so cache it\n    if (previousType !== type) {\n      typeSize = getNativeTypeSize(type);\n      previousType = type;\n    }\n    i += typeSize;\n  }\n\n  return ret;\n}\n\n// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\nfunction getMemory(size) {\n  if (!runtimeInitialized) return dynamicAlloc(size);\n  return _malloc(size);\n}\n\n\n// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n\n/**\n * @param {number} idx\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ArrayToString(u8Array, idx, maxBytesToRead) {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\n  while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n  } else {\n    var str = '';\n    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\n    while (idx < endPtr) {\n      // For UTF8 byte structure, see:\n      // http://en.wikipedia.org/wiki/UTF-8#Description\n      // https://www.ietf.org/rfc/rfc2279.txt\n      // https://tools.ietf.org/html/rfc3629\n      var u0 = u8Array[idx++];\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n      var u1 = u8Array[idx++] & 63;\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n      var u2 = u8Array[idx++] & 63;\n      if ((u0 & 0xF0) == 0xE0) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (u8Array[idx++] & 63);\n      }\n\n      if (u0 < 0x10000) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 0x10000;\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n      }\n    }\n  }\n  return str;\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\n// copy of that string as a Javascript String object.\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\n//                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\n//                 style or the other.\n/**\n * @param {number} ptr\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ToString(ptr, maxBytesToRead) {\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n}\n\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n//                    This count should include the null terminator,\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) {\n      var u1 = str.charCodeAt(++i);\n      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\n    }\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      outU8Array[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      outU8Array[outIdx++] = 0xC0 | (u >> 6);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      outU8Array[outIdx++] = 0xE0 | (u >> 12);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');\n      outU8Array[outIdx++] = 0xF0 | (u >> 18);\n      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);\n      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);\n      outU8Array[outIdx++] = 0x80 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  outU8Array[outIdx] = 0;\n  return outIdx - startIdx;\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) ++len;\n    else if (u <= 0x7FF) len += 2;\n    else if (u <= 0xFFFF) len += 3;\n    else len += 4;\n  }\n  return len;\n}\n\n\n\n// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.\n\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction AsciiToString(ptr) {\n  var str = '';\n  while (1) {\n    var ch = HEAPU8[((ptr++)>>0)];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\nfunction stringToAscii(str, outPtr) {\n  return writeAsciiToMemory(str, outPtr, false);\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\nfunction UTF16ToString(ptr) {\n  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n  var endPtr = ptr;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  var idx = endPtr >> 1;\n  while (HEAP16[idx]) ++idx;\n  endPtr = idx << 1;\n\n  if (endPtr - ptr > 32 && UTF16Decoder) {\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n  } else {\n    var i = 0;\n\n    var str = '';\n    while (1) {\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\n      if (codeUnit == 0) return str;\n      ++i;\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n      str += String.fromCharCode(codeUnit);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2; // Null terminator.\n  var startPtr = outPtr;\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    HEAP16[((outPtr)>>1)]=codeUnit;\n    outPtr += 2;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP16[((outPtr)>>1)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF16(str) {\n  return str.length*2;\n}\n\nfunction UTF32ToString(ptr) {\n  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n  var i = 0;\n\n  var str = '';\n  while (1) {\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\n    if (utf32 == 0)\n      return str;\n    ++i;\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    if (utf32 >= 0x10000) {\n      var ch = utf32 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    } else {\n      str += String.fromCharCode(utf32);\n    }\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 4) return 0;\n  var startPtr = outPtr;\n  var endPtr = startPtr + maxBytesToWrite - 4;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n      var trailSurrogate = str.charCodeAt(++i);\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n    }\n    HEAP32[((outPtr)>>2)]=codeUnit;\n    outPtr += 4;\n    if (outPtr + 4 > endPtr) break;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP32[((outPtr)>>2)]=0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF32(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i);\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n    len += 4;\n  }\n\n  return len;\n}\n\n// Allocate heap space for a JS string, and write it there.\n// It is the responsibility of the caller to free() that memory.\nfunction allocateUTF8(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = _malloc(size);\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Allocate stack space for a JS string, and write it there.\nfunction allocateUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Deprecated: This function should not be called because it is unsafe and does not provide\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\n// to be secure from out of bounds writes.\n/** @deprecated */\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\n  if (dontAddNull) {\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\n    // character that existed at the location where the null will be placed, and restore\n    // that after the write (below).\n    end = buffer + lengthBytesUTF8(string);\n    lastChar = HEAP8[end];\n  }\n  stringToUTF8(string, buffer, Infinity);\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n}\n\nfunction writeArrayToMemory(array, buffer) {\n  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')\n  HEAP8.set(array, buffer);\n}\n\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);\n    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);\n  }\n  // Null-terminate the pointer to the HEAP.\n  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;\n}\n\n\n\n// Memory management\n\nvar PAGE_SIZE = 16384;\nvar WASM_PAGE_SIZE = 65536;\nvar ASMJS_PAGE_SIZE = 16777216;\n\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - (x % multiple);\n  }\n  return x;\n}\n\nvar HEAP,\n/** @type {ArrayBuffer} */\n  buffer,\n/** @type {Int8Array} */\n  HEAP8,\n/** @type {Uint8Array} */\n  HEAPU8,\n/** @type {Int16Array} */\n  HEAP16,\n/** @type {Uint16Array} */\n  HEAPU16,\n/** @type {Int32Array} */\n  HEAP32,\n/** @type {Uint32Array} */\n  HEAPU32,\n/** @type {Float32Array} */\n  HEAPF32,\n/** @type {Float64Array} */\n  HEAPF64;\n\nfunction updateGlobalBufferAndViews(buf) {\n  buffer = buf;\n  Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buf);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buf);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\n}\n\nvar STATIC_BASE = 1024,\n    STACK_BASE = 5246640,\n    STACKTOP = STACK_BASE,\n    STACK_MAX = 3760,\n    DYNAMIC_BASE = 5246640,\n    DYNAMICTOP_PTR = 3600;\n\nassert(STACK_BASE % 16 === 0, 'stack must start aligned');\nassert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');\n\n\n\nvar TOTAL_STACK = 5242880;\nif (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')\n\nvar INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;if (!Object.getOwnPropertyDescriptor(Module, 'TOTAL_MEMORY')) Object.defineProperty(Module, 'TOTAL_MEMORY', { configurable: true, get: function() { abort('Module.TOTAL_MEMORY has been replaced with plain INITIAL_TOTAL_MEMORY') } });\n\nassert(INITIAL_TOTAL_MEMORY >= TOTAL_STACK, 'TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');\n\n// check for full engine support (use string 'subarray' to avoid closure compiler confusion)\nassert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,\n       'JS engine does not provide full typed array support');\n\n\n\n\n\n\n// In standalone mode, the wasm creates the memory, and the user can't provide it.\n// In non-standalone/normal mode, we create the memory here.\n\n// Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm\n// memory is created in the wasm, not in JS.)\n\n  if (Module['wasmMemory']) {\n    wasmMemory = Module['wasmMemory'];\n  } else\n  {\n    wasmMemory = new WebAssembly.Memory({\n      'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE\n      ,\n      'maximum': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE\n    });\n  }\n\n\nif (wasmMemory) {\n  buffer = wasmMemory.buffer;\n}\n\n// If the user provides an incorrect length, just use that length instead rather than providing the user to\n// specifically provide the memory length with Module['TOTAL_MEMORY'].\nINITIAL_TOTAL_MEMORY = buffer.byteLength;\nassert(INITIAL_TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\nupdateGlobalBufferAndViews(buffer);\n\nHEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;\n\n\n\n\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\nfunction writeStackCookie() {\n  assert((STACK_MAX & 3) == 0);\n  // The stack grows downwards\n  HEAPU32[(STACK_MAX >> 2)+1] = 0x2135467;\n  HEAPU32[(STACK_MAX >> 2)+2] = 0x89BACDFE;\n  // Also test the global address 0 for integrity.\n  // We don't do this with ASan because ASan does its own checks for this.\n  HEAP32[0] = 0x63736d65; /* 'emsc' */\n}\n\nfunction checkStackCookie() {\n  var cookie1 = HEAPU32[(STACK_MAX >> 2)+1];\n  var cookie2 = HEAPU32[(STACK_MAX >> 2)+2];\n  if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {\n    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' ' + cookie1.toString(16));\n  }\n  // Also test the global address 0 for integrity.\n  // We don't do this with ASan because ASan does its own checks for this.\n  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n}\n\nfunction abortStackOverflow(allocSize) {\n  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');\n}\n\n\n\n\n// Endianness check (note: assumes compiler arch was little-endian)\n(function() {\n  var h16 = new Int16Array(1);\n  var h8 = new Int8Array(h16.buffer);\n  h16[0] = 0x6373;\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n})();\n\nfunction abortFnPtrError(ptr, sig) {\n\tabort(\"Invalid function pointer \" + ptr + \" called with signature '\" + sig + \"'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). Build with ASSERTIONS=2 for more info.\");\n}\n\n\n\nfunction callRuntimeCallbacks(callbacks) {\n  while(callbacks.length > 0) {\n    var callback = callbacks.shift();\n    if (typeof callback == 'function') {\n      callback();\n      continue;\n    }\n    var func = callback.func;\n    if (typeof func === 'number') {\n      if (callback.arg === undefined) {\n        Module['dynCall_v'](func);\n      } else {\n        Module['dynCall_vi'](func, callback.arg);\n      }\n    } else {\n      func(callback.arg === undefined ? null : callback.arg);\n    }\n  }\n}\n\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATMAIN__    = []; // functions called when main() is to be run\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\n\nfunction preRun() {\n\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n  checkStackCookie();\n  assert(!runtimeInitialized);\n  runtimeInitialized = true;\n  \n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  checkStackCookie();\n  \n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n  checkStackCookie();\n  runtimeExited = true;\n}\n\nfunction postRun() {\n  checkStackCookie();\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnPreMain(cb) {\n  __ATMAIN__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\nfunction unSign(value, bits, ignore) {\n  if (value >= 0) {\n    return value;\n  }\n  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n                    : Math.pow(2, bits)         + value;\n}\nfunction reSign(value, bits, ignore) {\n  if (value <= 0) {\n    return value;\n  }\n  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32\n                        : Math.pow(2, bits-1);\n  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that\n                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n                                                       // TODO: In i64 mode 1, resign the two parts separately and safely\n    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n  }\n  return value;\n}\n\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\nassert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n\nvar Math_abs = Math.abs;\nvar Math_cos = Math.cos;\nvar Math_sin = Math.sin;\nvar Math_tan = Math.tan;\nvar Math_acos = Math.acos;\nvar Math_asin = Math.asin;\nvar Math_atan = Math.atan;\nvar Math_atan2 = Math.atan2;\nvar Math_exp = Math.exp;\nvar Math_log = Math.log;\nvar Math_sqrt = Math.sqrt;\nvar Math_ceil = Math.ceil;\nvar Math_floor = Math.floor;\nvar Math_pow = Math.pow;\nvar Math_imul = Math.imul;\nvar Math_fround = Math.fround;\nvar Math_round = Math.round;\nvar Math_min = Math.min;\nvar Math_max = Math.max;\nvar Math_clz32 = Math.clz32;\nvar Math_trunc = Math.trunc;\n\n\n\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\nvar runDependencyTracking = {};\n\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(function() {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n        var shown = false;\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            err('still waiting on run dependencies:');\n          }\n          err('dependency: ' + dep);\n        }\n        if (shown) {\n          err('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    err('warning: run dependency added without ID');\n  }\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    err('warning: run dependency removed without ID');\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\nModule[\"preloadedImages\"] = {}; // maps url to image data\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\n\n\nfunction abort(what) {\n  if (Module['onAbort']) {\n    Module['onAbort'](what);\n  }\n\n  what += '';\n  out(what);\n  err(what);\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  var output = 'abort(' + what + ') at ' + stackTrace();\n  what = output;\n\n  // Throw a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  throw new WebAssembly.RuntimeError(what);\n}\n\n\nvar memoryInitializer = null;\n\n\n// show errors on likely calls to FS when it was not included\nvar FS = {\n  error: function() {\n    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n  },\n  init: function() { FS.error() },\n  createDataFile: function() { FS.error() },\n  createPreloadedFile: function() { FS.error() },\n  createLazyFile: function() { FS.error() },\n  open: function() { FS.error() },\n  mkdev: function() { FS.error() },\n  registerDevice: function() { FS.error() },\n  analyzePath: function() { FS.error() },\n  loadFilesFromDB: function() { FS.error() },\n\n  ErrnoError: function ErrnoError() { FS.error() },\n};\nModule['FS_createDataFile'] = FS.createDataFile;\nModule['FS_createPreloadedFile'] = FS.createPreloadedFile;\n\n\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n// Indicates whether filename is a base64 data URI.\nfunction isDataURI(filename) {\n  return String.prototype.startsWith ?\n      filename.startsWith(dataURIPrefix) :\n      filename.indexOf(dataURIPrefix) === 0;\n}\n\n\n\n\nvar wasmBinaryFile = 'hello.wasm';\nif (!isDataURI(wasmBinaryFile)) {\n  wasmBinaryFile = locateFile(wasmBinaryFile);\n}\n\nfunction getBinary() {\n  try {\n    if (wasmBinary) {\n      return new Uint8Array(wasmBinary);\n    }\n\n    if (readBinary) {\n      return readBinary(wasmBinaryFile);\n    } else {\n      throw \"both async and sync fetching of the wasm failed\";\n    }\n  }\n  catch (err) {\n    abort(err);\n  }\n}\n\nfunction getBinaryPromise() {\n  // if we don't have the binary yet, and have the Fetch api, use that\n  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n    return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\n      if (!response['ok']) {\n        throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n      }\n      return response['arrayBuffer']();\n    }).catch(function () {\n      return getBinary();\n    });\n  }\n  // Otherwise, getBinary should be able to get it synchronously\n  return new Promise(function(resolve, reject) {\n    resolve(getBinary());\n  });\n}\n\n\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nfunction createWasm() {\n  // prepare imports\n  var info = {\n    'env': asmLibraryArg,\n    'wasi_snapshot_preview1': asmLibraryArg\n  };\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  /** @param {WebAssembly.Module=} module*/\n  function receiveInstance(instance, module) {\n    var exports = instance.exports;\n    Module['asm'] = exports;\n    removeRunDependency('wasm-instantiate');\n  }\n   // we can't run yet (except in a pthread, where we have a custom sync instantiator)\n  addRunDependency('wasm-instantiate');\n\n\n  // Async compilation can be confusing when an error on the page overwrites Module\n  // (for example, if the order of elements is wrong, and the one defining Module is\n  // later), so we save Module and check it later.\n  var trueModule = Module;\n  function receiveInstantiatedSource(output) {\n    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n    trueModule = null;\n      // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n      // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\n    receiveInstance(output['instance']);\n  }\n\n\n  function instantiateArrayBuffer(receiver) {\n    return getBinaryPromise().then(function(binary) {\n      return WebAssembly.instantiate(binary, info);\n    }).then(receiver, function(reason) {\n      err('failed to asynchronously prepare wasm: ' + reason);\n      abort(reason);\n    });\n  }\n\n  // Prefer streaming instantiation if available.\n  function instantiateAsync() {\n    if (!wasmBinary &&\n        typeof WebAssembly.instantiateStreaming === 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        typeof fetch === 'function') {\n      fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {\n        var result = WebAssembly.instantiateStreaming(response, info);\n        return result.then(receiveInstantiatedSource, function(reason) {\n            // We expect the most common failure cause to be a bad MIME type for the binary,\n            // in which case falling back to ArrayBuffer instantiation should work.\n            err('wasm streaming compile failed: ' + reason);\n            err('falling back to ArrayBuffer instantiation');\n            instantiateArrayBuffer(receiveInstantiatedSource);\n          });\n      });\n    } else {\n      return instantiateArrayBuffer(receiveInstantiatedSource);\n    }\n  }\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n  // to any other async startup actions they are performing.\n  if (Module['instantiateWasm']) {\n    try {\n      var exports = Module['instantiateWasm'](info, receiveInstance);\n      return exports;\n    } catch(e) {\n      err('Module.instantiateWasm callback failed with error: ' + e);\n      return false;\n    }\n  }\n\n  instantiateAsync();\n  return {}; // no exports yet; we'll fill them in later\n}\n\n\n// Globals used by JS i64 conversions\nvar tempDouble;\nvar tempI64;\n\n// === Body ===\n\nvar ASM_CONSTS = {\n  \n};\n\n\n\n\n// STATICTOP = STATIC_BASE + 2736;\n/* global initializers */  __ATINIT__.push({ func: function() { ___wasm_call_ctors() } });\n\n\n\n\n/* no memory initializer */\n// {{PRE_LIBRARY}}\n\n\n  function demangle(func) {\n      warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\n      return func;\n    }\n\n  function demangleAll(text) {\n      var regex =\n        /\\b_Z[\\w\\d_]+/g;\n      return text.replace(regex,\n        function(x) {\n          var y = demangle(x);\n          return x === y ? x : (y + ' [' + x + ']');\n        });\n    }\n\n  function jsStackTrace() {\n      var err = new Error();\n      if (!err.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n        // so try that as a special-case.\n        try {\n          throw new Error();\n        } catch(e) {\n          err = e;\n        }\n        if (!err.stack) {\n          return '(no stack trace available)';\n        }\n      }\n      return err.stack.toString();\n    }\n\n  function stackTrace() {\n      var js = jsStackTrace();\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n      return demangleAll(js);\n    }\n\n  function ___handle_stack_overflow() {\n      abort('stack overflow')\n    }\n\n  function ___lock() {}\n\n  function ___unlock() {}\n\n  function _emscripten_get_heap_size() {\n      return HEAPU8.length;\n    }\n\n  function _emscripten_get_sbrk_ptr() {\n      return 3600;\n    }\n\n  function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n    }\n\n  \n  function abortOnCannotGrowMemory(requestedSize) {\n      abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n    }function _emscripten_resize_heap(requestedSize) {\n      abortOnCannotGrowMemory(requestedSize);\n    }\n\n  \n  function flush_NO_FILESYSTEM() {\n      // flush anything remaining in the buffers during shutdown\n      if (typeof _fflush !== 'undefined') _fflush(0);\n      var buffers = SYSCALLS.buffers;\n      if (buffers[1].length) SYSCALLS.printChar(1, 10);\n      if (buffers[2].length) SYSCALLS.printChar(2, 10);\n    }\n  \n  \n  var PATH={splitPath:function(filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },normalizeArray:function(parts, allowAboveRoot) {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        // if the path is allowed to go above the root, restore leading ..s\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },normalize:function(path) {\n        var isAbsolute = path.charAt(0) === '/',\n            trailingSlash = path.substr(-1) === '/';\n        // Normalize the path\n        path = PATH.normalizeArray(path.split('/').filter(function(p) {\n          return !!p;\n        }), !isAbsolute).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },dirname:function(path) {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },basename:function(path) {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash+1);\n      },extname:function(path) {\n        return PATH.splitPath(path)[3];\n      },join:function() {\n        var paths = Array.prototype.slice.call(arguments, 0);\n        return PATH.normalize(paths.join('/'));\n      },join2:function(l, r) {\n        return PATH.normalize(l + '/' + r);\n      }};var SYSCALLS={buffers:[null,[],[]],printChar:function(stream, curr) {\n        var buffer = SYSCALLS.buffers[stream];\n        assert(buffer);\n        if (curr === 0 || curr === 10) {\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n          buffer.length = 0;\n        } else {\n          buffer.push(curr);\n        }\n      },varargs:0,get:function(varargs) {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\n        return ret;\n      },getStr:function() {\n        var ret = UTF8ToString(SYSCALLS.get());\n        return ret;\n      },get64:function() {\n        var low = SYSCALLS.get(), high = SYSCALLS.get();\n        if (low >= 0) assert(high === 0);\n        else assert(high === -1);\n        return low;\n      },getZero:function() {\n        assert(SYSCALLS.get() === 0);\n      }};function _fd_write(fd, iov, iovcnt, pnum) {try {\n  \n      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n      var num = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAP32[(((iov)+(i*8))>>2)];\n        var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\n        for (var j = 0; j < len; j++) {\n          SYSCALLS.printChar(fd, HEAPU8[ptr+j]);\n        }\n        num += len;\n      }\n      HEAP32[((pnum)>>2)]=num\n      return 0;\n    } catch (e) {\n    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n    return e.errno;\n  }\n  }\n\n  \n  function _memcpy(dest, src, num) {\n      dest = dest|0; src = src|0; num = num|0;\n      var ret = 0;\n      var aligned_dest_end = 0;\n      var block_aligned_dest_end = 0;\n      var dest_end = 0;\n      // Test against a benchmarked cutoff limit for when HEAPU8.set() becomes faster to use.\n      if ((num|0) >= 8192) {\n        _emscripten_memcpy_big(dest|0, src|0, num|0)|0;\n        return dest|0;\n      }\n  \n      ret = dest|0;\n      dest_end = (dest + num)|0;\n      if ((dest&3) == (src&3)) {\n        // The initial unaligned < 4-byte front.\n        while (dest & 3) {\n          if ((num|0) == 0) return ret|0;\n          HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);\n          dest = (dest+1)|0;\n          src = (src+1)|0;\n          num = (num-1)|0;\n        }\n        aligned_dest_end = (dest_end & -4)|0;\n        block_aligned_dest_end = (aligned_dest_end - 64)|0;\n        while ((dest|0) <= (block_aligned_dest_end|0) ) {\n          HEAP32[((dest)>>2)]=((HEAP32[((src)>>2)])|0);\n          HEAP32[(((dest)+(4))>>2)]=((HEAP32[(((src)+(4))>>2)])|0);\n          HEAP32[(((dest)+(8))>>2)]=((HEAP32[(((src)+(8))>>2)])|0);\n          HEAP32[(((dest)+(12))>>2)]=((HEAP32[(((src)+(12))>>2)])|0);\n          HEAP32[(((dest)+(16))>>2)]=((HEAP32[(((src)+(16))>>2)])|0);\n          HEAP32[(((dest)+(20))>>2)]=((HEAP32[(((src)+(20))>>2)])|0);\n          HEAP32[(((dest)+(24))>>2)]=((HEAP32[(((src)+(24))>>2)])|0);\n          HEAP32[(((dest)+(28))>>2)]=((HEAP32[(((src)+(28))>>2)])|0);\n          HEAP32[(((dest)+(32))>>2)]=((HEAP32[(((src)+(32))>>2)])|0);\n          HEAP32[(((dest)+(36))>>2)]=((HEAP32[(((src)+(36))>>2)])|0);\n          HEAP32[(((dest)+(40))>>2)]=((HEAP32[(((src)+(40))>>2)])|0);\n          HEAP32[(((dest)+(44))>>2)]=((HEAP32[(((src)+(44))>>2)])|0);\n          HEAP32[(((dest)+(48))>>2)]=((HEAP32[(((src)+(48))>>2)])|0);\n          HEAP32[(((dest)+(52))>>2)]=((HEAP32[(((src)+(52))>>2)])|0);\n          HEAP32[(((dest)+(56))>>2)]=((HEAP32[(((src)+(56))>>2)])|0);\n          HEAP32[(((dest)+(60))>>2)]=((HEAP32[(((src)+(60))>>2)])|0);\n          dest = (dest+64)|0;\n          src = (src+64)|0;\n        }\n        while ((dest|0) < (aligned_dest_end|0) ) {\n          HEAP32[((dest)>>2)]=((HEAP32[((src)>>2)])|0);\n          dest = (dest+4)|0;\n          src = (src+4)|0;\n        }\n      } else {\n        // In the unaligned copy case, unroll a bit as well.\n        aligned_dest_end = (dest_end - 4)|0;\n        while ((dest|0) < (aligned_dest_end|0) ) {\n          HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);\n          HEAP8[(((dest)+(1))>>0)]=((HEAP8[(((src)+(1))>>0)])|0);\n          HEAP8[(((dest)+(2))>>0)]=((HEAP8[(((src)+(2))>>0)])|0);\n          HEAP8[(((dest)+(3))>>0)]=((HEAP8[(((src)+(3))>>0)])|0);\n          dest = (dest+4)|0;\n          src = (src+4)|0;\n        }\n      }\n      // The remaining unaligned < 4 byte tail.\n      while ((dest|0) < (dest_end|0)) {\n        HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);\n        dest = (dest+1)|0;\n        src = (src+1)|0;\n      }\n      return ret|0;\n    }\n\n  function _memset(ptr, value, num) {\n      ptr = ptr|0; value = value|0; num = num|0;\n      var end = 0, aligned_end = 0, block_aligned_end = 0, value4 = 0;\n      end = (ptr + num)|0;\n  \n      value = value & 0xff;\n      if ((num|0) >= 67 /* 64 bytes for an unrolled loop + 3 bytes for unaligned head*/) {\n        while ((ptr&3) != 0) {\n          HEAP8[((ptr)>>0)]=value;\n          ptr = (ptr+1)|0;\n        }\n  \n        aligned_end = (end & -4)|0;\n        value4 = value | (value << 8) | (value << 16) | (value << 24);\n  \n        block_aligned_end = (aligned_end - 64)|0;\n  \n        while((ptr|0) <= (block_aligned_end|0)) {\n          HEAP32[((ptr)>>2)]=value4;\n          HEAP32[(((ptr)+(4))>>2)]=value4;\n          HEAP32[(((ptr)+(8))>>2)]=value4;\n          HEAP32[(((ptr)+(12))>>2)]=value4;\n          HEAP32[(((ptr)+(16))>>2)]=value4;\n          HEAP32[(((ptr)+(20))>>2)]=value4;\n          HEAP32[(((ptr)+(24))>>2)]=value4;\n          HEAP32[(((ptr)+(28))>>2)]=value4;\n          HEAP32[(((ptr)+(32))>>2)]=value4;\n          HEAP32[(((ptr)+(36))>>2)]=value4;\n          HEAP32[(((ptr)+(40))>>2)]=value4;\n          HEAP32[(((ptr)+(44))>>2)]=value4;\n          HEAP32[(((ptr)+(48))>>2)]=value4;\n          HEAP32[(((ptr)+(52))>>2)]=value4;\n          HEAP32[(((ptr)+(56))>>2)]=value4;\n          HEAP32[(((ptr)+(60))>>2)]=value4;\n          ptr = (ptr + 64)|0;\n        }\n  \n        while ((ptr|0) < (aligned_end|0) ) {\n          HEAP32[((ptr)>>2)]=value4;\n          ptr = (ptr+4)|0;\n        }\n      }\n      // The remaining bytes.\n      while ((ptr|0) < (end|0)) {\n        HEAP8[((ptr)>>0)]=value;\n        ptr = (ptr+1)|0;\n      }\n      return (end-num)|0;\n    }\n\n  function _setTempRet0($i) {\n      setTempRet0(($i) | 0);\n    }\nvar ASSERTIONS = true;\n\n// Copyright 2017 The Emscripten Authors.  All rights reserved.\n// Emscripten is available under two separate licenses, the MIT license and the\n// University of Illinois/NCSA Open Source License.  Both these licenses can be\n// found in the LICENSE file.\n\n/** @type {function(string, boolean=, number=)} */\nfunction intArrayFromString(stringy, dontAddNull, length) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\n\nfunction intArrayToString(array) {\n  var ret = [];\n  for (var i = 0; i < array.length; i++) {\n    var chr = array[i];\n    if (chr > 0xFF) {\n      if (ASSERTIONS) {\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n      }\n      chr &= 0xFF;\n    }\n    ret.push(String.fromCharCode(chr));\n  }\n  return ret.join('');\n}\n\n\n// ASM_LIBRARY EXTERN PRIMITIVES: Int8Array,Int32Array\n\nvar asmGlobalArg = {};\nvar asmLibraryArg = { \"__handle_stack_overflow\": ___handle_stack_overflow, \"__lock\": ___lock, \"__unlock\": ___unlock, \"emscripten_get_sbrk_ptr\": _emscripten_get_sbrk_ptr, \"emscripten_memcpy_big\": _emscripten_memcpy_big, \"emscripten_resize_heap\": _emscripten_resize_heap, \"fd_write\": _fd_write, \"memory\": wasmMemory, \"setTempRet0\": _setTempRet0, \"table\": wasmTable };\nvar asm = createWasm();\nModule[\"asm\"] = asm;\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__wasm_call_ctors\"].apply(null, arguments)\n};\n\nvar _main = Module[\"_main\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"main\"].apply(null, arguments)\n};\n\nvar ___errno_location = Module[\"___errno_location\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__errno_location\"].apply(null, arguments)\n};\n\nvar _fflush = Module[\"_fflush\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"fflush\"].apply(null, arguments)\n};\n\nvar _setThrew = Module[\"_setThrew\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"setThrew\"].apply(null, arguments)\n};\n\nvar _malloc = Module[\"_malloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"malloc\"].apply(null, arguments)\n};\n\nvar _free = Module[\"_free\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"free\"].apply(null, arguments)\n};\n\nvar ___set_stack_limit = Module[\"___set_stack_limit\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__set_stack_limit\"].apply(null, arguments)\n};\n\nvar stackSave = Module[\"stackSave\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackSave\"].apply(null, arguments)\n};\n\nvar stackAlloc = Module[\"stackAlloc\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackAlloc\"].apply(null, arguments)\n};\n\nvar stackRestore = Module[\"stackRestore\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"stackRestore\"].apply(null, arguments)\n};\n\nvar __growWasmMemory = Module[\"__growWasmMemory\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"__growWasmMemory\"].apply(null, arguments)\n};\n\nvar dynCall_ii = Module[\"dynCall_ii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments)\n};\n\nvar dynCall_iiii = Module[\"dynCall_iiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments)\n};\n\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_jiji\"].apply(null, arguments)\n};\n\nvar dynCall_iidiiii = Module[\"dynCall_iidiiii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_iidiiii\"].apply(null, arguments)\n};\n\nvar dynCall_vii = Module[\"dynCall_vii\"] = function() {\n  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n  return Module[\"asm\"][\"dynCall_vii\"].apply(null, arguments)\n};\n\n\n\n\n// === Auto-generated postamble setup entry stuff ===\n\nModule['asm'] = asm;\n\nif (!Object.getOwnPropertyDescriptor(Module, \"intArrayFromString\")) Module[\"intArrayFromString\"] = function() { abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"intArrayToString\")) Module[\"intArrayToString\"] = function() { abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"ccall\")) Module[\"ccall\"] = function() { abort(\"'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"cwrap\")) Module[\"cwrap\"] = function() { abort(\"'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"setValue\")) Module[\"setValue\"] = function() { abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getValue\")) Module[\"getValue\"] = function() { abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"allocate\")) Module[\"allocate\"] = function() { abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getMemory\")) Module[\"getMemory\"] = function() { abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF8ArrayToString\")) Module[\"UTF8ArrayToString\"] = function() { abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF8ToString\")) Module[\"UTF8ToString\"] = function() { abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8Array\")) Module[\"stringToUTF8Array\"] = function() { abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF8\")) Module[\"stringToUTF8\"] = function() { abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF8\")) Module[\"lengthBytesUTF8\"] = function() { abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function() { abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPreRun\")) Module[\"addOnPreRun\"] = function() { abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnInit\")) Module[\"addOnInit\"] = function() { abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPreMain\")) Module[\"addOnPreMain\"] = function() { abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnExit\")) Module[\"addOnExit\"] = function() { abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addOnPostRun\")) Module[\"addOnPostRun\"] = function() { abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeStringToMemory\")) Module[\"writeStringToMemory\"] = function() { abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeArrayToMemory\")) Module[\"writeArrayToMemory\"] = function() { abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeAsciiToMemory\")) Module[\"writeAsciiToMemory\"] = function() { abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addRunDependency\")) Module[\"addRunDependency\"] = function() { abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"removeRunDependency\")) Module[\"removeRunDependency\"] = function() { abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createFolder\")) Module[\"FS_createFolder\"] = function() { abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createPath\")) Module[\"FS_createPath\"] = function() { abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createDataFile\")) Module[\"FS_createDataFile\"] = function() { abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createPreloadedFile\")) Module[\"FS_createPreloadedFile\"] = function() { abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createLazyFile\")) Module[\"FS_createLazyFile\"] = function() { abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createLink\")) Module[\"FS_createLink\"] = function() { abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_createDevice\")) Module[\"FS_createDevice\"] = function() { abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS_unlink\")) Module[\"FS_unlink\"] = function() { abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"dynamicAlloc\")) Module[\"dynamicAlloc\"] = function() { abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"loadDynamicLibrary\")) Module[\"loadDynamicLibrary\"] = function() { abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"loadWebAssemblyModule\")) Module[\"loadWebAssemblyModule\"] = function() { abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getLEB\")) Module[\"getLEB\"] = function() { abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getFunctionTables\")) Module[\"getFunctionTables\"] = function() { abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"alignFunctionTables\")) Module[\"alignFunctionTables\"] = function() { abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"registerFunctions\")) Module[\"registerFunctions\"] = function() { abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"addFunction\")) Module[\"addFunction\"] = function() { abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"removeFunction\")) Module[\"removeFunction\"] = function() { abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getFuncWrapper\")) Module[\"getFuncWrapper\"] = function() { abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"prettyPrint\")) Module[\"prettyPrint\"] = function() { abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"makeBigInt\")) Module[\"makeBigInt\"] = function() { abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"dynCall\")) Module[\"dynCall\"] = function() { abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getCompilerSetting\")) Module[\"getCompilerSetting\"] = function() { abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"print\")) Module[\"print\"] = function() { abort(\"'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"printErr\")) Module[\"printErr\"] = function() { abort(\"'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"getTempRet0\")) Module[\"getTempRet0\"] = function() { abort(\"'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"setTempRet0\")) Module[\"setTempRet0\"] = function() { abort(\"'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"callMain\")) Module[\"callMain\"] = function() { abort(\"'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"abort\")) Module[\"abort\"] = function() { abort(\"'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PROCINFO\")) Module[\"PROCINFO\"] = function() { abort(\"'PROCINFO' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToNewUTF8\")) Module[\"stringToNewUTF8\"] = function() { abort(\"'stringToNewUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"abortOnCannotGrowMemory\")) Module[\"abortOnCannotGrowMemory\"] = function() { abort(\"'abortOnCannotGrowMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscripten_realloc_buffer\")) Module[\"emscripten_realloc_buffer\"] = function() { abort(\"'emscripten_realloc_buffer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"ENV\")) Module[\"ENV\"] = function() { abort(\"'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"setjmpId\")) Module[\"setjmpId\"] = function() { abort(\"'setjmpId' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_CODES\")) Module[\"ERRNO_CODES\"] = function() { abort(\"'ERRNO_CODES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"ERRNO_MESSAGES\")) Module[\"ERRNO_MESSAGES\"] = function() { abort(\"'ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"DNS__deps\")) Module[\"DNS__deps\"] = function() { abort(\"'DNS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"DNS\")) Module[\"DNS\"] = function() { abort(\"'DNS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GAI_ERRNO_MESSAGES\")) Module[\"GAI_ERRNO_MESSAGES\"] = function() { abort(\"'GAI_ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Protocols\")) Module[\"Protocols\"] = function() { abort(\"'Protocols' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Sockets__deps\")) Module[\"Sockets__deps\"] = function() { abort(\"'Sockets__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Sockets\")) Module[\"Sockets\"] = function() { abort(\"'Sockets' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UNWIND_CACHE\")) Module[\"UNWIND_CACHE\"] = function() { abort(\"'UNWIND_CACHE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"readAsmConstArgs\")) Module[\"readAsmConstArgs\"] = function() { abort(\"'readAsmConstArgs' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PATH\")) Module[\"PATH\"] = function() { abort(\"'PATH' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PATH_FS__deps\")) Module[\"PATH_FS__deps\"] = function() { abort(\"'PATH_FS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PATH_FS\")) Module[\"PATH_FS\"] = function() { abort(\"'PATH_FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SYSCALLS__deps\")) Module[\"SYSCALLS__deps\"] = function() { abort(\"'SYSCALLS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SYSCALLS\")) Module[\"SYSCALLS\"] = function() { abort(\"'SYSCALLS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"flush_NO_FILESYSTEM\")) Module[\"flush_NO_FILESYSTEM\"] = function() { abort(\"'flush_NO_FILESYSTEM' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"JSEvents\")) Module[\"JSEvents\"] = function() { abort(\"'JSEvents' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"demangle__deps\")) Module[\"demangle__deps\"] = function() { abort(\"'demangle__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"demangle\")) Module[\"demangle\"] = function() { abort(\"'demangle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"demangleAll\")) Module[\"demangleAll\"] = function() { abort(\"'demangleAll' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"jsStackTrace\")) Module[\"jsStackTrace\"] = function() { abort(\"'jsStackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackTrace\")) Module[\"stackTrace\"] = function() { abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64__deps\")) Module[\"writeI53ToI64__deps\"] = function() { abort(\"'writeI53ToI64__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64\")) Module[\"writeI53ToI64\"] = function() { abort(\"'writeI53ToI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Clamped\")) Module[\"writeI53ToI64Clamped\"] = function() { abort(\"'writeI53ToI64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToI64Signaling\")) Module[\"writeI53ToI64Signaling\"] = function() { abort(\"'writeI53ToI64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Clamped\")) Module[\"writeI53ToU64Clamped\"] = function() { abort(\"'writeI53ToU64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"writeI53ToU64Signaling\")) Module[\"writeI53ToU64Signaling\"] = function() { abort(\"'writeI53ToU64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"readI53FromI64\")) Module[\"readI53FromI64\"] = function() { abort(\"'readI53FromI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"readI53FromU64\")) Module[\"readI53FromU64\"] = function() { abort(\"'readI53FromU64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"convertI32PairToI53\")) Module[\"convertI32PairToI53\"] = function() { abort(\"'convertI32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"convertU32PairToI53\")) Module[\"convertU32PairToI53\"] = function() { abort(\"'convertU32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Browser__deps\")) Module[\"Browser__deps\"] = function() { abort(\"'Browser__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Browser__postset\")) Module[\"Browser__postset\"] = function() { abort(\"'Browser__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Browser\")) Module[\"Browser\"] = function() { abort(\"'Browser' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"Browser__postset__deps\")) Module[\"Browser__postset__deps\"] = function() { abort(\"'Browser__postset__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS__deps\")) Module[\"FS__deps\"] = function() { abort(\"'FS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS__postset\")) Module[\"FS__postset\"] = function() { abort(\"'FS__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"FS\")) Module[\"FS\"] = function() { abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"MEMFS__deps\")) Module[\"MEMFS__deps\"] = function() { abort(\"'MEMFS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"MEMFS\")) Module[\"MEMFS\"] = function() { abort(\"'MEMFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"TTY__deps\")) Module[\"TTY__deps\"] = function() { abort(\"'TTY__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"TTY__postset\")) Module[\"TTY__postset\"] = function() { abort(\"'TTY__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"TTY\")) Module[\"TTY\"] = function() { abort(\"'TTY' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PIPEFS__postset\")) Module[\"PIPEFS__postset\"] = function() { abort(\"'PIPEFS__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PIPEFS__deps\")) Module[\"PIPEFS__deps\"] = function() { abort(\"'PIPEFS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"PIPEFS\")) Module[\"PIPEFS\"] = function() { abort(\"'PIPEFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SOCKFS__postset\")) Module[\"SOCKFS__postset\"] = function() { abort(\"'SOCKFS__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SOCKFS__deps\")) Module[\"SOCKFS__deps\"] = function() { abort(\"'SOCKFS__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SOCKFS\")) Module[\"SOCKFS\"] = function() { abort(\"'SOCKFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GL__postset\")) Module[\"GL__postset\"] = function() { abort(\"'GL__postset' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GL__deps\")) Module[\"GL__deps\"] = function() { abort(\"'GL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GL\")) Module[\"GL\"] = function() { abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet__deps\")) Module[\"emscriptenWebGLGet__deps\"] = function() { abort(\"'emscriptenWebGLGet__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGet\")) Module[\"emscriptenWebGLGet\"] = function() { abort(\"'emscriptenWebGLGet' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData__deps\")) Module[\"emscriptenWebGLGetTexPixelData__deps\"] = function() { abort(\"'emscriptenWebGLGetTexPixelData__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetTexPixelData\")) Module[\"emscriptenWebGLGetTexPixelData\"] = function() { abort(\"'emscriptenWebGLGetTexPixelData' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform\")) Module[\"emscriptenWebGLGetUniform\"] = function() { abort(\"'emscriptenWebGLGetUniform' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib\")) Module[\"emscriptenWebGLGetVertexAttrib\"] = function() { abort(\"'emscriptenWebGLGetVertexAttrib' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GL__postset__deps\")) Module[\"GL__postset__deps\"] = function() { abort(\"'GL__postset__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetUniform__deps\")) Module[\"emscriptenWebGLGetUniform__deps\"] = function() { abort(\"'emscriptenWebGLGetUniform__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"emscriptenWebGLGetVertexAttrib__deps\")) Module[\"emscriptenWebGLGetVertexAttrib__deps\"] = function() { abort(\"'emscriptenWebGLGetVertexAttrib__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"AL__deps\")) Module[\"AL__deps\"] = function() { abort(\"'AL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"AL\")) Module[\"AL\"] = function() { abort(\"'AL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"WebVR\")) Module[\"WebVR\"] = function() { abort(\"'WebVR' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"WebVR__deps\")) Module[\"WebVR__deps\"] = function() { abort(\"'WebVR__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL__deps\")) Module[\"SDL__deps\"] = function() { abort(\"'SDL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL\")) Module[\"SDL\"] = function() { abort(\"'SDL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_gfx\")) Module[\"SDL_gfx\"] = function() { abort(\"'SDL_gfx' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"SDL_gfx__deps\")) Module[\"SDL_gfx__deps\"] = function() { abort(\"'SDL_gfx__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GLUT__deps\")) Module[\"GLUT__deps\"] = function() { abort(\"'GLUT__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GLUT\")) Module[\"GLUT\"] = function() { abort(\"'GLUT' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"EGL__deps\")) Module[\"EGL__deps\"] = function() { abort(\"'EGL__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"EGL\")) Module[\"EGL\"] = function() { abort(\"'EGL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GLFW__deps\")) Module[\"GLFW__deps\"] = function() { abort(\"'GLFW__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GLFW\")) Module[\"GLFW\"] = function() { abort(\"'GLFW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GLEW__deps\")) Module[\"GLEW__deps\"] = function() { abort(\"'GLEW__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"GLEW\")) Module[\"GLEW\"] = function() { abort(\"'GLEW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"IDBStore\")) Module[\"IDBStore\"] = function() { abort(\"'IDBStore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"IDBStore__deps\")) Module[\"IDBStore__deps\"] = function() { abort(\"'IDBStore__deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"runAndAbortIfError\")) Module[\"runAndAbortIfError\"] = function() { abort(\"'runAndAbortIfError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"warnOnce\")) Module[\"warnOnce\"] = function() { abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackSave\")) Module[\"stackSave\"] = function() { abort(\"'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackRestore\")) Module[\"stackRestore\"] = function() { abort(\"'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stackAlloc\")) Module[\"stackAlloc\"] = function() { abort(\"'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"AsciiToString\")) Module[\"AsciiToString\"] = function() { abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToAscii\")) Module[\"stringToAscii\"] = function() { abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF16ToString\")) Module[\"UTF16ToString\"] = function() { abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF16\")) Module[\"stringToUTF16\"] = function() { abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF16\")) Module[\"lengthBytesUTF16\"] = function() { abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"UTF32ToString\")) Module[\"UTF32ToString\"] = function() { abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"stringToUTF32\")) Module[\"stringToUTF32\"] = function() { abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"lengthBytesUTF32\")) Module[\"lengthBytesUTF32\"] = function() { abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8\")) Module[\"allocateUTF8\"] = function() { abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nif (!Object.getOwnPropertyDescriptor(Module, \"allocateUTF8OnStack\")) Module[\"allocateUTF8OnStack\"] = function() { abort(\"'allocateUTF8OnStack' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") };\nModule[\"writeStackCookie\"] = writeStackCookie;\nModule[\"checkStackCookie\"] = checkStackCookie;\nModule[\"abortStackOverflow\"] = abortStackOverflow;if (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NORMAL\")) Object.defineProperty(Module, \"ALLOC_NORMAL\", { configurable: true, get: function() { abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_STACK\")) Object.defineProperty(Module, \"ALLOC_STACK\", { configurable: true, get: function() { abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_DYNAMIC\")) Object.defineProperty(Module, \"ALLOC_DYNAMIC\", { configurable: true, get: function() { abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Object.getOwnPropertyDescriptor(Module, \"ALLOC_NONE\")) Object.defineProperty(Module, \"ALLOC_NONE\", { configurable: true, get: function() { abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\") } });\nif (!Object.getOwnPropertyDescriptor(Module, \"calledRun\")) Object.defineProperty(Module, \"calledRun\", { configurable: true, get: function() { abort(\"'calledRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\") } });\n\n\n\nvar calledRun;\n\n// Modularize mode returns a function, which can be called to\n// create instances. The instances provide a then() method,\n// must like a Promise, that receives a callback. The callback\n// is called when the module is ready to run, with the module\n// as a parameter. (Like a Promise, it also returns the module\n// so you can use the output of .then(..)).\nModule['then'] = function(func) {\n  // We may already be ready to run code at this time. if\n  // so, just queue a call to the callback.\n  if (calledRun) {\n    func(Module);\n  } else {\n    // we are not ready to call then() yet. we must call it\n    // at the same time we would call onRuntimeInitialized.\n    var old = Module['onRuntimeInitialized'];\n    Module['onRuntimeInitialized'] = function() {\n      if (old) old();\n      func(Module);\n    };\n  }\n  return Module;\n};\n\n/**\n * @constructor\n * @this {ExitStatus}\n */\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\" + status + \")\";\n  this.status = status;\n}\n\nvar calledMain = false;\n\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n};\n\nfunction callMain(args) {\n  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])');\n  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');\n\n  var entryFunction = Module['_main'];\n\n\n  args = args || [];\n\n  var argc = args.length+1;\n  var argv = stackAlloc((argc + 1) * 4);\n  HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);\n  for (var i = 1; i < argc; i++) {\n    HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);\n  }\n  HEAP32[(argv >> 2) + argc] = 0;\n\n\n  try {\n\n    Module['___set_stack_limit'](STACK_MAX);\n\n    var ret = entryFunction(argc, argv);\n\n\n    // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as execution is asynchronously handed\n    // off to a pthread.\n    // if we're not running an evented main loop, it's time to exit\n      exit(ret, /* implicit = */ true);\n  }\n  catch(e) {\n    if (e instanceof ExitStatus) {\n      // exit() throws this once it's done to make sure execution\n      // has been stopped completely\n      return;\n    } else if (e == 'unwind') {\n      // running an evented main loop, don't immediately exit\n      noExitRuntime = true;\n      return;\n    } else {\n      var toLog = e;\n      if (e && typeof e === 'object' && e.stack) {\n        toLog = [e, e.stack];\n      }\n      err('exception thrown: ' + toLog);\n      quit_(1, e);\n    }\n  } finally {\n    calledMain = true;\n  }\n}\n\n\n\n\n/** @type {function(Array=)} */\nfunction run(args) {\n  args = args || arguments_;\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n  writeStackCookie();\n\n  preRun();\n\n  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    if (calledRun) return;\n    calledRun = true;\n\n    if (ABORT) return;\n\n    initRuntime();\n\n    preMain();\n\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n\n    if (shouldRunNow) callMain(args);\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else\n  {\n    doRun();\n  }\n  checkStackCookie();\n}\nModule['run'] = run;\n\nfunction checkUnflushedContent() {\n  // Compiler settings do not allow exiting the runtime, so flushing\n  // the streams is not possible. but in ASSERTIONS mode we check\n  // if there was something to flush, and if so tell the user they\n  // should request that the runtime be exitable.\n  // Normally we would not even include flush() at all, but in ASSERTIONS\n  // builds we do so just for this check, and here we see if there is any\n  // content to flush, that is, we check if there would have been\n  // something a non-ASSERTIONS build would have not seen.\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n  // mode (which has its own special function for this; otherwise, all\n  // the code is inside libc)\n  var print = out;\n  var printErr = err;\n  var has = false;\n  out = err = function(x) {\n    has = true;\n  }\n  try { // it doesn't matter if it fails\n    var flush = flush_NO_FILESYSTEM;\n    if (flush) flush(0);\n  } catch(e) {}\n  out = print;\n  err = printErr;\n  if (has) {\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');\n    warnOnce('(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)');\n  }\n}\n\nfunction exit(status, implicit) {\n  checkUnflushedContent();\n\n  // if this is just main exit-ing implicitly, and the status is 0, then we\n  // don't need to do anything here and can just leave. if the status is\n  // non-zero, though, then we need to report it.\n  // (we may have warned about this earlier, if a situation justifies doing so)\n  if (implicit && noExitRuntime && status === 0) {\n    return;\n  }\n\n  if (noExitRuntime) {\n    // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n    if (!implicit) {\n      err('program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');\n    }\n  } else {\n\n    ABORT = true;\n    EXITSTATUS = status;\n\n    exitRuntime();\n\n    if (Module['onExit']) Module['onExit'](status);\n  }\n\n  quit_(status, new ExitStatus(status));\n}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\n// shouldRunNow refers to calling main(), not run().\nvar shouldRunNow = true;\n\nif (Module['noInitialRun']) shouldRunNow = false;\n\n\n  noExitRuntime = true;\n\nrun();\n\n\n\n\n\n// {{MODULE_ADDITIONS}}\n\n\n\n\n\n  return Module\n}\n);\n})();\nif (typeof exports === 'object' && typeof module === 'object')\n      module.exports = Module;\n    else if (typeof define === 'function' && define['amd'])\n      define([], function() { return Module; });\n    else if (typeof exports === 'object')\n      exports[\"Module\"] = Module;\n    "]},"metadata":{},"sourceType":"script"}